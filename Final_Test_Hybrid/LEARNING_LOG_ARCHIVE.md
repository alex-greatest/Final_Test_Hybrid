# LEARNING LOG ARCHIVE

Полный архив развернутых записей из LEARNING_LOG.md.

Правило: в активном LEARNING_LOG.md храним только короткие и актуальные записи, подробности переносим сюда без потери контекста.

---

# LEARNING LOG

## 2026-02-07

### Контекст
- Проверили, покрываются ли ошибки из `111.txt` в цепочке диагностики Modbus.
- Разобрали роли `PingCommand`, `EcuErrorSyncService` и `ErrorDefinitions.DiagnosticEcu`.

### Что сделали
- Подтвердили, что `PingCommand` читает данные (`LastErrorId`, `ChTemperature`) и не выполняет полную причинно-следственную валидацию условий аварий.
- Подтвердили, что маппинг ошибок ЭБУ идёт по `LastErrorId` через `GetEcuErrorById(1..26)`.
- Подтвердили отдельную спец-обработку для `E9` по температуре CH (вариант `E9-STB`).

### Решение
- Отказались от внедрения дополнительного диагностического контекста на данном этапе.

### Причина решения
- Источник истины для ошибок в проде: сам котёл/ЭБУ (`LastErrorId`).
- Локальные эвристики без полного автомата ЭБУ могут давать ложные интерпретации.

### Урок
- Не приписывать `PingCommand` проверки, которых в нём нет: это слой чтения, а не слой классификации причин.

### Статус
- Тема отложена до нового инцидента или отдельного требования.

## 2026-02-07 (реализация BoilerLock runtime)

### Контекст
- Реализована новая логика обработки блокировок котла по `Ping` на основе `1005` и ошибок из `111.txt`.
- Требование: управлять поведением через `appsettings`, не останавливать ping и не добавлять новые ошибки в `ErrorService`.

### Что сделали
- Добавлены флаги в `appsettings.json`:
  - `Diagnostic:BoilerLock:Enabled`
  - `Diagnostic:BoilerLock:PauseOnStatus1Enabled`
  - `Diagnostic:BoilerLock:PlcSignalOnStatus2Enabled`
  - дефолты: все `false`.
- Добавлен `BoilerLockRuntimeService`:
  - слушает `IModbusDispatcher.PingDataUpdated`;
  - фильтрует только коды из `111.txt`;
  - ветка `1005 == 1`: pause через `InterruptReason.BoilerLock`, ожидание `WriteVerifyDelayMs`, запись `1153=0`, повторное чтение `1005`;
  - ветка `1005 == 2`: только PLC signal stub (лог + TODO), без паузы.
- Добавлен новый interrupt:
  - `InterruptReason.BoilerLock`;
  - `BoilerLockBehavior` (pause + уведомление, без `AssociatedError`).
- Добавлено сообщение в `MessageService` и `MessageServiceDescription.md`:
  - приоритет `125`, ниже reset/auto-ready.

### Критические решения
- Для новой логики зафиксировано `1153 = 0` (по согласованному требованию), несмотря на старый путь в `BoilerSettingsService`, где используется `1`.
- Для `status=2` пауза не применяется.

### Защита от зависания
- Добавлен recovery-check на каждом ping:
  - если активен `BoilerLock`, но условие паузы (`status=1 + ошибка из whitelist + флаги + активный test execution`) больше не выполняется, вызывается `ForceStop()`.
- Это закрывает риск вечной паузы при уходе блокировки между циклами ping.

### Урок
- Для pause-механики важно разделять:
  - условие постановки на паузу;
  - условие снятия паузы.
- Если эти условия несимметричны и нет recovery-check, система почти гарантированно рано или поздно зависнет в paused-состоянии.

## 2026-02-07 (документация BoilerLock)

### Что сделали
- Создали отдельный источник истины: `Docs/BoilerLockGuide.md`.
- Добавили краткие ссылки/сводки в:
  - `Docs/DiagnosticGuide.md`
  - `Docs/ErrorCoordinatorGuide.md`
  - `MessageServiceDescription.md`

### Почему так
- Полный дубль в нескольких файлах быстро расходится с кодом.
- Один подробный guide + короткие ссылки в соседних документах снижает риск противоречий.

### Урок
- Для новой runtime-логики сначала фиксировать «где главный документ», иначе через 1-2 итерации появляется неуправляемый рассинхрон описаний.

## 2026-02-07 (спиннер PLC-подписок только при реальной подписке)

### Контекст
- На старте без PLC показывался спиннер `Выполняется подписка...`, хотя реальная подписка ещё не выполнялась.
- Требование проекта: показывать спиннер только после готовности соединения и только на фактической фазе подписок.

### Что сделали
- Изменили `PlcSubscriptionState`:
  - дефолтное состояние теперь не включает `IsInitializing`;
  - `IsInitializing` больше не вычисляется как `!IsCompleted`;
  - `SetInitializing/SetCompleted` теперь явно управляют только фазой показа спиннера.
- Перенесли управление спиннером в `PlcInitializationCoordinator`:
  - `SetInitializing()` включается перед реальной фазой runtime-подписок;
  - `SetCompleted()` выполняется в `finally`;
  - ожидание подключения (`WaitForConnectionAsync`) и pre-execution валидации идут без спиннера.
- Синхронизировали описание в `ARCHITECTURE.md`.

### Причина решения
- Предыдущая семантика state-модели смешивала «инициализация не завершена» и «идёт реальная подписка».
- Из-за этого UI давал ложный сигнал оператору в фазе reconnect/retry при недоступном PLC.

### Урок
- Для UI-индикаторов нельзя использовать инверсный флаг «ещё не завершено» как прокси «операция выполняется сейчас».
- В критичных сценариях SCADA индикатор должен быть привязан к конкретной фазе исполнения, а не к косвенному состоянию.

