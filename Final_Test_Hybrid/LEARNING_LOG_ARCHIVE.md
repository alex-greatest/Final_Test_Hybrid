# LEARNING LOG ARCHIVE

Полный архив развернутых записей из LEARNING_LOG.md.

Правило: в активном LEARNING_LOG.md храним только короткие и актуальные записи, подробности переносим сюда без потери контекста.

---

# LEARNING LOG

## 2026-02-07

### Контекст
- Проверили, покрываются ли ошибки из `111.txt` в цепочке диагностики Modbus.
- Разобрали роли `PingCommand`, `EcuErrorSyncService` и `ErrorDefinitions.DiagnosticEcu`.

### Что сделали
- Подтвердили, что `PingCommand` читает данные (`LastErrorId`, `ChTemperature`) и не выполняет полную причинно-следственную валидацию условий аварий.
- Подтвердили, что маппинг ошибок ЭБУ идёт по `LastErrorId` через `GetEcuErrorById(1..26)`.
- Подтвердили отдельную спец-обработку для `E9` по температуре CH (вариант `E9-STB`).

### Решение
- Отказались от внедрения дополнительного диагностического контекста на данном этапе.

### Причина решения
- Источник истины для ошибок в проде: сам котёл/ЭБУ (`LastErrorId`).
- Локальные эвристики без полного автомата ЭБУ могут давать ложные интерпретации.

### Урок
- Не приписывать `PingCommand` проверки, которых в нём нет: это слой чтения, а не слой классификации причин.

### Статус
- Тема отложена до нового инцидента или отдельного требования.

## 2026-02-07 (реализация BoilerLock runtime)

### Контекст
- Реализована новая логика обработки блокировок котла по `Ping` на основе `1005` и ошибок из `111.txt`.
- Требование: управлять поведением через `appsettings`, не останавливать ping и не добавлять новые ошибки в `ErrorService`.

### Что сделали
- Добавлены флаги в `appsettings.json`:
  - `Diagnostic:BoilerLock:Enabled`
  - `Diagnostic:BoilerLock:PauseOnStatus1Enabled`
  - `Diagnostic:BoilerLock:PlcSignalOnStatus2Enabled`
  - дефолты: все `false`.
- Добавлен `BoilerLockRuntimeService`:
  - слушает `IModbusDispatcher.PingDataUpdated`;
  - фильтрует только коды из `111.txt`;
  - ветка `1005 == 1`: pause через `InterruptReason.BoilerLock`, ожидание `WriteVerifyDelayMs`, запись `1153=0`, повторное чтение `1005`;
  - ветка `1005 == 2`: только PLC signal stub (лог + TODO), без паузы.
- Добавлен новый interrupt:
  - `InterruptReason.BoilerLock`;
  - `BoilerLockBehavior` (pause + уведомление, без `AssociatedError`).
- Добавлено сообщение в `MessageService` и `MessageServiceDescription.md`:
  - приоритет `125`, ниже reset/auto-ready.

### Критические решения
- Для новой логики зафиксировано `1153 = 0` (по согласованному требованию), несмотря на старый путь в `BoilerSettingsService`, где используется `1`.
- Для `status=2` пауза не применяется.

### Защита от зависания
- Добавлен recovery-check на каждом ping:
  - если активен `BoilerLock`, но условие паузы (`status=1 + ошибка из whitelist + флаги + активный test execution`) больше не выполняется, вызывается `ForceStop()`.
- Это закрывает риск вечной паузы при уходе блокировки между циклами ping.

### Урок
- Для pause-механики важно разделять:
  - условие постановки на паузу;
  - условие снятия паузы.
- Если эти условия несимметричны и нет recovery-check, система почти гарантированно рано или поздно зависнет в paused-состоянии.

## 2026-02-07 (документация BoilerLock)

### Что сделали
- Создали отдельный источник истины: `Docs/BoilerLockGuide.md`.
- Добавили краткие ссылки/сводки в:
  - `Docs/DiagnosticGuide.md`
  - `Docs/ErrorCoordinatorGuide.md`
  - `MessageServiceDescription.md`

### Почему так
- Полный дубль в нескольких файлах быстро расходится с кодом.
- Один подробный guide + короткие ссылки в соседних документах снижает риск противоречий.

### Урок
- Для новой runtime-логики сначала фиксировать «где главный документ», иначе через 1-2 итерации появляется неуправляемый рассинхрон описаний.

## 2026-02-07 (спиннер PLC-подписок только при реальной подписке)

### Контекст
- На старте без PLC показывался спиннер `Выполняется подписка...`, хотя реальная подписка ещё не выполнялась.
- Требование проекта: показывать спиннер только после готовности соединения и только на фактической фазе подписок.

### Что сделали
- Изменили `PlcSubscriptionState`:
  - дефолтное состояние теперь не включает `IsInitializing`;
  - `IsInitializing` больше не вычисляется как `!IsCompleted`;
  - `SetInitializing/SetCompleted` теперь явно управляют только фазой показа спиннера.
- Перенесли управление спиннером в `PlcInitializationCoordinator`:
  - `SetInitializing()` включается перед реальной фазой runtime-подписок;
  - `SetCompleted()` выполняется в `finally`;
  - ожидание подключения (`WaitForConnectionAsync`) и pre-execution валидации идут без спиннера.
- Синхронизировали описание в `ARCHITECTURE.md`.

### Причина решения
- Предыдущая семантика state-модели смешивала «инициализация не завершена» и «идёт реальная подписка».
- Из-за этого UI давал ложный сигнал оператору в фазе reconnect/retry при недоступном PLC.

### Урок
- Для UI-индикаторов нельзя использовать инверсный флаг «ещё не завершено» как прокси «операция выполняется сейчас».
- В критичных сценариях SCADA индикатор должен быть привязан к конкретной фазе исполнения, а не к косвенному состоянию.


## 2026-02-08 (перенос кратких записей из активного LEARNING_LOG)

Источник: свёртка активного `LEARNING_LOG.md` для уменьшения объёма оперативного контекста без потери фактов.

### 2026-02-07 (оптимизация LEARNING_LOG)
- Что изменили: ввели ротацию и компактный формат активного лога; развернутую историю вынесли в архив.
- Почему: ограничили рост файла и снизили стоимость чтения контекста.
- Риск/урок: без лимитов и шаблона журнал быстро превращается в несопровождаемый narrative.
- Ссылки: `Final_Test_Hybrid/LEARNING_LOG.md`, `Final_Test_Hybrid/LEARNING_LOG_ARCHIVE.md`

### 2026-02-07 (фикс правил в AGENTS)
- Что изменили: добавили в `AGENTS.md` фиксацию про оптимизацию лога и обязательный контроль размера `LEARNING_LOG.md`.
- Почему: закрепили правило рядом с базовыми рабочими принципами, чтобы не терялось между задачами.
- Риск/урок: если правило не зафиксировано в core-инструкции, команда быстро возвращается к бесконтрольному росту файла.
- Ссылки: `AGENTS.md`, `Final_Test_Hybrid/LEARNING_LOG.md`

### 2026-02-07 (BoilerLock ping-flow: auto-stand + bounded retry)
- Что изменили: в `BoilerLockRuntimeService` добавили ping-flow с обязательной проверкой режима, авто-переходом в `Stand`, retry/cooldown/suppress для `1153=0` и расширенным логом `Doc/Modbus` адресов.
- Почему: убрать ложные/бесконечные попытки сброса в неподходящем режиме и остановить лог-шторм на `IllegalDataAddress`.
- Риск/урок: reset по ping должен быть stateful; без cooldown/suppress сервис в 500ms ping-интервале быстро превращается в генератор повторных ошибок.
- Ссылки: `Final_Test_Hybrid/Services/Diagnostic/Services/BoilerLockRuntimeService.cs`, `Final_Test_Hybrid/Services/Diagnostic/Connection/DiagnosticSettings.cs`, `Final_Test_Hybrid/appsettings.json`

### 2026-02-07 (ECU error flow: lock-only активация по ping)
- Что изменили: `EcuErrorSyncService` больше не трактует `1047` как всегда активную ошибку; взводит ECU-ошибку только при lock-контексте (`1005 in {1,2}` + whitelist `111.txt`) и очищает её вне lock.
- Почему: `1047` — последняя сохранённая ошибка, а не гарантированно активная; прежняя логика давала ложные активные ошибки в UI.
- Риск/урок: слой синхронизации ошибок обязан учитывать физический контекст статуса, иначе `ActiveErrorsGrid` показывает историю как текущую аварийность.
- Ссылки: `Final_Test_Hybrid/Services/Diagnostic/Services/EcuErrorSyncService.cs`, `Final_Test_Hybrid/Services/Diagnostic/Services/BoilerLockCriteria.cs`, `Final_Test_Hybrid/Docs/DiagnosticGuide.md`
