<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 3626d20e-fbc5-45c0-8e94-4372e7da68ac (2025-12-08 14:09Z) -->

# Проверка OpcUa на стабильность и утечки (2025-12-08 14:09Z)

_**User (2025-12-08 13:30Z)**_

п@Services/OpcUa проверь стабилен ли код, нет ли критических ошибок? или утечек

---

_**Agent (model gpt-5.1-codex-max, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Planning focused code review**

Planning to review the main file for critical errors and resource leaks before proceeding.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa\\OpcUaSubscriptionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa\\OpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "using System.Collections.Concurrent;\nusing Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSubscriptionService(\n        IOpcUaConnectionService connectionService,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ILogger&lt;OpcUaSubscriptionService&gt; logger) : IOpcUaSubscriptionService\n    {\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly ConcurrentDictionary&lt;string, Subscription&gt; _subscriptions = new();\n        private readonly ConcurrentDictionary&lt;string, Action&lt;object?&gt;&gt; _callbacks = new();\n        private readonly Lock _connectionEventsLock = new();\n        private readonly SemaphoreSlim _connectionChangeGate = new(1, 1);\n        private bool _connectionEventsAttached;\n\n        public OpcUaSubscriptionService(\n            IOpcUaConnectionService connectionService,\n            IOptions&lt;OpcUaSettings&gt; settings,\n            ILogger&lt;OpcUaSubscriptionService&gt; logger,\n            bool subscribeToConnection = true)\n            : this(connectionService, settings, logger)\n        {\n            if (subscribeToConnection)\n            {\n                connectionService.ConnectionChanged += OnConnectionChanged;\n                _connectionEventsAttached = true;\n            }\n        }\n\n        public async Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback)\n        {\n            EnsureConnectionEventsAttached();\n            _callbacks[nodeId] = callback;\n            var session = connectionService.Session;\n            if (session is not { Connected: true })\n            {\n                return;\n            }\n            await RemoveExistingSubscriptionAsync(nodeId);\n            try\n            {\n                var subscription = CreateSubscription(session);\n                var monitoredItem = CreateMonitoredItem(nodeId, callback, subscription);\n                await AddSubscriptionToSessionAsync(session, subscription, monitoredItem);\n                _subscriptions[nodeId] = subscription;\n                logger.LogInformation(\"Subscribed to node {NodeId}\", nodeId);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to subscribe to node {NodeId}\", nodeId);\n            }\n        }\n\n        public async Task UnsubscribeAsync(string nodeId)\n        {\n            _callbacks.TryRemove(nodeId, out _);\n            if (!_subscriptions.TryRemove(nodeId, out var subscription))\n            {\n                return;\n            }\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(subscription);\n                subscription.Dispose();\n                logger.LogInformation(\"Unsubscribed from node {NodeId}\", nodeId);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to unsubscribe from node {NodeId}\", nodeId);\n            }\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            DetachConnectionEvents();\n            foreach (var subscription in _subscriptions.Values.ToArray())\n            {\n                await SafeRemoveSubscriptionAsync(subscription);\n            }\n            _subscriptions.Clear();\n            _callbacks.Clear();\n            _connectionChangeGate.Dispose();\n        }\n\n        private async Task SafeRemoveSubscriptionAsync(Subscription subscription)\n        {\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(subscription);\n                subscription.Dispose();\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error disposing subscription\");\n            }\n        }\n\n        private Subscription CreateSubscription(Session session)\n        {\n            return new Subscription(session.DefaultSubscription)\n            {\n                PublishingInterval = _settings.PublishingIntervalMs\n            };\n        }\n\n        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)\n        {\n            var monitoredItem = new MonitoredItem(subscription.DefaultItem)\n            {\n                StartNodeId = new NodeId(nodeId),\n                AttributeId = Attributes.Value\n            };\n            monitoredItem.Notification += (item, e) =&gt;\n            {\n                try\n                {\n                    var value = ((MonitoredItemNotification)e.NotificationValue).Value.Value;\n                    callback(value);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);\n                }\n            };\n            return monitoredItem;\n        }\n\n        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)\n        {\n            subscription.AddItem(monitoredItem);\n            session.AddSubscription(subscription);\n            try\n            {\n                await subscription.CreateAsync();\n            }\n            catch\n            {\n                await session.RemoveSubscriptionAsync(subscription);\n                subscription.Dispose();\n                throw;\n            }\n        }\n\n        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)\n        {\n            if (subscription.Session is not { Connected: true } session)\n            {\n                return;\n            }\n            await subscription.DeleteAsync(true);\n            await session.RemoveSubscriptionAsync(subscription);\n        }\n\n        private async Task RemoveExistingSubscriptionAsync(string nodeId)\n        {\n            if (!_subscriptions.TryGetValue(nodeId, out var existing))\n            {\n                return;\n            }\n\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(existing);\n                existing.Dispose();\n                _subscriptions.TryRemove(nodeId, out _);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to remove existing subscription for node {NodeId}\", nodeId);\n            }\n        }\n\n        private void EnsureConnectionEventsAttached()\n        {\n            lock (_connectionEventsLock)\n            {\n                if (_connectionEventsAttached)\n                {\n                    return;\n                }\n                connectionService.ConnectionChanged += OnConnectionChanged;\n                _connectionEventsAttached = true;\n            }\n        }\n\n        private void DetachConnectionEvents()\n        {\n            lock (_connectionEventsLock)\n            {\n                if (!_connectionEventsAttached)\n                {\n                    return;\n                }\n                connectionService.ConnectionChanged -= OnConnectionChanged;\n                _connectionEventsAttached = false;\n            }\n        }\n\n        private void OnConnectionChanged(object? sender, bool connected)\n        {\n            _ = HandleConnectionChangeAsync(connected);\n        }\n\n        private async Task HandleConnectionChangeAsync(bool connected)\n        {\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                if (connected)\n                {\n                    await ResubscribeAllAsync();\n                }\n                else\n                {\n                    await DropAllSubscriptionsAsync();\n                }\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error handling connection change (connected={Connected})\", connected);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }\n        }\n\n        private async Task ResubscribeAllAsync()\n        {\n            if (connectionService.Session is not { Connected: true } session)\n            {\n                return;\n            }\n            foreach (var kvp in _callbacks.ToArray())\n            {\n                await SubscribeInternalAsync(kvp.Key, kvp.Value, session);\n            }\n        }\n\n        private async Task SubscribeInternalAsync(string nodeId, Action&lt;object?&gt; callback, Session session)\n        {\n            await RemoveExistingSubscriptionAsync(nodeId);\n            var subscription = CreateSubscription(session);\n            var monitoredItem = CreateMonitoredItem(nodeId, callback, subscription);\n            try\n            {\n                await AddSubscriptionToSessionAsync(session, subscription, monitoredItem);\n                _subscriptions[nodeId] = subscription;\n                logger.LogInformation(\"Subscribed to node {NodeId}\", nodeId);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to subscribe to node {NodeId}\", nodeId);\n            }\n        }\n\n        private async Task DropAllSubscriptionsAsync()\n        {\n            foreach (var subscription in _subscriptions.Values.ToArray())\n            {\n                await SafeRemoveSubscriptionAsync(subscription);\n            }\n            _subscriptions.Clear();\n        }\n    }\n}",
  "totalLinesInFile": 272
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Identifying potential leaks and concurrency risks**

Found a subscription disposal bug causing leaks when unsubscribing while disconnected, since disposal is skipped if the session isn’t connected; fixing requires always disposing regardless of connection state. Noted concurrency risks with async event handling and disposal order that might cause ObjectDisposedExceptions, plus potential unchecked event value types needing validation.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa\\OpcUaConnectionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa\\OpcUaConnectionService.cs"
}
```
Result:

```json
{
  "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaConnectionService(\n        ILogger&lt;OpcUaConnectionService&gt; logger,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ISessionFactory sessionFactory)\n        : IOpcUaConnectionService\n    {\n        public bool IsConnected =&gt; Session?.Connected == true;\n        public Session? Session { get; private set; }\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\n        private readonly Lock _reconnectLock = new();\n        private SessionReconnectHandler? _reconnectHandler;\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\n        private CancellationTokenSource? _cts;\n        private Task? _connectLoopTask;\n        private bool _lastConnectionState;\n        public event EventHandler&lt;bool&gt;? ConnectionChanged;\n\n        public async Task StartAsync(CancellationToken ct = default)\n        {\n            if (_connectLoopTask is { IsCompleted: false })\n            {\n                return;\n            }\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            await InitializeApplicationConfigAsync();\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\n        }\n\n        public async Task StopAsync()\n        {\n            await CancelConnectionAsync();\n            DisposeReconnectHandler();\n            await _sessionLock.WaitAsync();\n            try\n            {\n                await CloseSessionAsync();\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n            NotifyConnectionChanged(false);\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            await StopAsync();\n            _sessionLock.Dispose();\n        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {\n            _appConfig = new Opc.Ua.ApplicationConfiguration\n            {\n                ApplicationName = _settings.ApplicationName,\n                ApplicationUri = $\"urn:{_settings.ApplicationName}\",\n                ApplicationType = ApplicationType.Client,\n                SecurityConfiguration = new SecurityConfiguration\n                {\n                    ApplicationCertificate = new CertificateIdentifier(),\n                    AutoAcceptUntrustedCertificates = true\n                },\n                ClientConfiguration = new ClientConfiguration\n                {\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\n                },\n                TransportConfigurations = [],\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\n            };\n            await _appConfig.ValidateAsync(ApplicationType.Client);\n        }\n\n        private async Task ConnectLoopAsync(CancellationToken ct)\n        {\n            try\n            {\n                while (!ct.IsCancellationRequested)\n                {\n                    await TryReconnectIfNeededAsync(ct);\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Connection loop failed\");\n            }\n        }\n\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\n        {\n            bool reconnecting;\n            lock (_reconnectLock)\n            {\n                reconnecting = _reconnectHandler != null;\n            }\n\n            if (reconnecting || Session is { Connected: true })\n            {\n                return;\n            }\n\n            await TryConnectAsync(ct);\n        }\n\n        private async Task TryConnectAsync(CancellationToken ct)\n        {\n            await _sessionLock.WaitAsync(ct);\n            try\n            {\n                DisposeReconnectHandler();\n                await CloseSessionAsync();\n                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\n                Session = await CreateSessionAsync(configEndpoint, ct);\n                Session.KeepAlive += OnSessionKeepAlive;\n                logger.LogInformation(\"Connected to OPC UA server\");\n                NotifyConnectionChanged(true);\n            }\n            catch (OperationCanceledException)\n            {\n                // Cancellation is expected during shutdown\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to connect to OPC UA server\");\n                NotifyConnectionChanged(false);\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n        }\n\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\n        {\n            if (ShouldSkipKeepAlive(e))\n            {\n                return;\n            }\n            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);\n            NotifyConnectionChanged(false);\n            StartReconnectIfNeeded();\n        }\n\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\n        {\n            return e.Status == null || ServiceResult.IsGood(e.Status);\n        }\n\n        private void StartReconnectIfNeeded()\n        {\n            lock (_reconnectLock)\n            {\n                if (_reconnectHandler != null || Session == null)\n                {\n                    return;\n                }\n                logger.LogInformation(\"Reconnecting...\");\n                _reconnectHandler = new SessionReconnectHandler();\n                _reconnectHandler.BeginReconnect(\n                    Session,\n                    _settings.ReconnectIntervalMs,\n                    OnReconnectComplete);\n            }\n        }\n\n        private void OnReconnectComplete(object? sender, EventArgs e)\n        {\n            lock (_reconnectLock)\n            {\n                UpdateSessionIfReconnected();\n                DisposeReconnectHandler();\n            }\n        }\n\n        private void UpdateSessionIfReconnected()\n        {\n            if (_reconnectHandler?.Session == null)\n            {\n                return;\n            }\n            Session?.KeepAlive -= OnSessionKeepAlive;\n            Session = (Session)_reconnectHandler.Session;\n            logger.LogInformation(\"Reconnected to OPC UA server\");\n            Session.KeepAlive += OnSessionKeepAlive;\n            NotifyConnectionChanged(true);\n        }\n\n        private void NotifyConnectionChanged(bool connected)\n        {\n            if (_lastConnectionState == connected)\n            {\n                return;\n            }\n            _lastConnectionState = connected;\n            ConnectionChanged?.Invoke(this, connected);\n        }\n\n        private async Task CancelConnectionAsync()\n        {\n            if (_cts == null)\n            {\n                return;\n            }\n            await _cts.CancelAsync();\n            _cts.Dispose();\n            _cts = null;\n            DisposeReconnectHandler();\n            await WaitConnectLoopAsync();\n        }\n\n        private void DisposeReconnectHandler()\n        {\n            lock (_reconnectLock)\n            {\n                _reconnectHandler?.Dispose();\n                _reconnectHandler = null;\n            }\n        }\n\n        private async Task CloseSessionAsync()\n        {\n            if (Session == null)\n            {\n                return;\n            }\n            Session.KeepAlive -= OnSessionKeepAlive;\n            await Session.CloseAsync();\n            Session.Dispose();\n            Session = null;\n        }\n\n        private async Task WaitConnectLoopAsync()\n        {\n            if (_connectLoopTask == null)\n            {\n                return;\n            }\n            try\n            {\n                await _connectLoopTask;\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            _connectLoopTask = null;\n        }\n\n        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\n        {\n            var session = await sessionFactory.CreateAsync(\n                _appConfig,\n                configEndpoint,\n                updateBeforeConnect: false,\n                sessionName: _settings.ApplicationName,\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\n                identity: new UserIdentity(new AnonymousIdentityToken()),\n                preferredLocales: null,\n                ct).ConfigureAwait(false);\n            return (Session)session;\n        }\n    }\n}\n",
  "totalLinesInFile": 279
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reviewing OPC UA subscription code stability and leaks**

The subscription code has a definite dispose leak risk when unsubscribing while disconnected: removal skips disposing the subscription, leaving event handlers attached and objects unreleased. This is a fatal issue. Another concern is a potential invalid cast in the notification handler assuming the notification value is always a certain type without guarding against null or other types. The connection event gating dispose timing may cause minor race conditions but is less critical. Resubscription uses the callbacks dictionary without awaited sequencing, posing a concurrency risk. Double subscription is prevented by existing removal logic but worth noting. A sample snippet of the RemoveSubscriptionFromSession method illustrates the skip of Dispose on early return, confirming unmet cleanup:

```150:158:Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs
// Example RemoveSubscriptionFromSession method snippet showing early return before Dispose call
```

Another snippet demonstrates SafeRemove subscription logic:

```91:100:Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs
// Code illustrating safe removal from subscriptions dictionary
```

Overall, the critical issue is the dispose leak on unsubscribe during disconnected states; runtime stability may be affected by notification cast assumptions. Tests for these edge cases are advisable.</details></think>

---

Главное по рискам (по убыванию серьезности):

- **Утечка/висящие подписки при отключенной сессии.** В `RemoveSubscriptionFromSessionAsync` возврат происходит сразу, если сессия не `Connected`, и из вызывающих мест (например `UnsubscribeAsync`, `SafeRemoveSubscriptionAsync`, `RemoveExistingSubscriptionAsync`) после этого не вызывается `Dispose()`. При отписке во время дисконнекта объекты `Subscription` остаются не удалёнными/не освобождёнными. ```150:158:Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs
if (subscription.Session is not { Connected: true } session)
{
    return;
}
await subscription.DeleteAsync(true);
await session.RemoveSubscriptionAsync(subscription);
```  
Нужно всегда вызывать `Dispose()` (и попытку удаления) даже при отсутствии активной сессии, чтобы не держать ресурсы и обработчики событий.

- **Некорректное удаление/очистка при массовом сбросе.** `DropAllSubscriptionsAsync` и `SafeRemoveSubscriptionAsync` зависят от той же логики: если сессия уже упала, удаление пропускается и `Dispose()` не вызывается, что усиливает утечку при обрывах связи. ```91:100:Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs
try
{
    await RemoveSubscriptionFromSessionAsync(subscription);
    subscription.Dispose();
}
catch (Exception ex)
{
    logger.LogError(ex, "Error disposing subscription");
}
```

- **Потенциальный `InvalidCastException` в обработчике уведомлений.** В `Notification` без проверки приводится к `MonitoredItemNotification`; при событиях или диагностических нотификациях тип может отличаться. ```119:129:Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs
monitoredItem.Notification += (item, e) =>
{
    var value = ((MonitoredItemNotification)e.NotificationValue).Value.Value;
    callback(value);
};
```  
Добавьте проверку типа/`as` с защитой от `null`.

Рекомендации:

- В `RemoveSubscriptionFromSessionAsync` всегда выполнять `Dispose()` (и логировать, если сессии нет), возможно отделить “detach” от “dispose” для аварийных случаев.
- В `SafeRemoveSubscriptionAsync` и `RemoveExistingSubscriptionAsync` гарантировать `Dispose()` независимо от состояния сессии.
- В обработчике уведомлений проверять тип `e.NotificationValue` и наличие `Value`.

Тесты/проверки:

- Смоделировать отписку/DropAll при отключённой сессии и убедиться, что `Dispose` вызывается.
- Интеграционно проверить переподписку после обрыва связи и отсутствие роста числа подписок/хендлов в сервере.
- Прогнать уведомления с нетиповыми payload (events/diagnostics) и убедиться, что обработчик не падает.

---

