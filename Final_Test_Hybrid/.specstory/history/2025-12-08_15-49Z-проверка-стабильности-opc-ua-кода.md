<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 0f2552a2-634c-46f3-b9b5-acb1bdab3d29 (2025-12-08 15:49Z) -->

# Проверка стабильности opc ua кода (2025-12-08 15:49Z)

_**User (2025-12-08 13:30Z)**_

п@Services/OpcUa проверь стабилен ли код, нет ли критических ошибок? или утечек





Я ОДИН РАЗРАБОТЧИК И ЭТО НЕ МНОГОПОЛИЗОВАТЕЛЬСКОЕ ПРИЛОЖЕНИЕ А HMI. ТО ЕСТЬ ОНО БУДЕТ В ОДНОМ ЭКЗЕМПЛЯРЕ КОД НЕ НАДО ПЕРЕУСЛОЖНЯТЬ

---

_**Agent (model gpt-5.1-codex-max, mode Plan)**_

<think><details><summary>Thought Process</summary>
**Listing OpcUa service structure**</details></think>

---

Path does not exist: d:\projects\Final_Test_Hybrid\Services

---

<think><details><summary>Thought Process</summary>
**Listing project root folders**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "d:/projects/Final_Test_Hybrid"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "d:\\projects\\Final_Test_Hybrid",
    "childrenDirs": [
      {
        "absPath": "d:\\projects\\Final_Test_Hybrid\\.idea",
        "childrenDirs": [
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\.idea\\.idea.Final_Test_Hybrid",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\.idea\\.idea.Final_Test_Hybrid\\.idea",
                "childrenFiles": [
                  {
                    "name": ".gitignore"
                  },
                  {
                    "name": "copilot.data.migration.agent.xml"
                  },
                  {
                    "name": "copilot.data.migration.ask.xml"
                  },
                  {
                    "name": "copilot.data.migration.ask2agent.xml"
                  },
                  {
                    "name": "copilot.data.migration.edit.xml"
                  },
                  {
                    "name": "encodings.xml"
                  },
                  {
                    "name": "indexLayout.xml"
                  },
                  {
                    "name": "vcs.xml"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "d:\\projects\\Final_Test_Hybrid\\.specstory",
        "childrenDirs": [
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\.specstory\\history",
            "childrenFiles": [
              {
                "name": "2025-11-22_16-38Z-центрирование-элементов-в-razor.md"
              },
              {
                "name": "2025-11-22_16-44Z-добавить-текст-над-кнопкой-в-razor.md"
              },
              {
                "name": "2025-11-23_09-43Z-проверка-синтаксиса-для-стилей-div.md"
              },
              {
                "name": "2025-11-23_10-22Z-обсуждение-дизайна-масштабируемой-схемы.md"
              },
              {
                "name": "2025-11-23_15-49Z-svg-выходит-за-пределы-вкладки.md"
              },
              {
                "name": "2025-11-23_16-03Z-svg-выходит-за-пределы-вкладки.md"
              },
              {
                "name": "2025-11-24_08-03Z-настройка-масштаба-рисунка-в-razor.md"
              },
              {
                "name": "2025-11-24_09-35Z-оформление-интерфейса-с-компонентами-radzen.md"
              },
              {
                "name": "2025-11-24_14-18Z-centering-component-in-radzen.md"
              },
              {
                "name": "2025-11-25_07-16Z-проблема-с-индикаторами-в-компоненте.md"
              },
              {
                "name": "2025-11-25_07-33Z-уменьшение-высоты-заголовка-в-radzen-data-grid.md"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": ".gitignore"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "d:\\projects\\Final_Test_Hybrid\\.vs",
        "childrenDirs": [
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\.vs\\Final_Test_Hybrid.slnx",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\.vs\\Final_Test_Hybrid.slnx\\DesignTimeBuild",
                "childrenFiles": [
                  {
                    "name": ".dtbcache.v2"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\.vs\\Final_Test_Hybrid.slnx\\FileContentIndex",
                "childrenFiles": [
                  {
                    "name": "1c5aa6a5-90ca-4fe4-96e2-425f1e11431f.vsidx"
                  },
                  {
                    "name": "55b49fde-f548-459e-93ea-1020e8cf4747.vsidx"
                  },
                  {
                    "name": "5c6d3959-2f73-4fe0-84ad-fc003253aae2.vsidx"
                  },
                  {
                    "name": "71bde952-26ec-4fab-9cd5-3da9ba7e9598.vsidx"
                  },
                  {
                    "name": "af65db50-af9c-4b7c-95ad-7032814d1ee7.vsidx"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\.vs\\Final_Test_Hybrid.slnx\\v18",
                "childrenFiles": [
                  {
                    "name": ".futdcache.v2"
                  },
                  {
                    "name": ".suo"
                  },
                  {
                    "name": "DocumentLayout.backup.json"
                  },
                  {
                    "name": "DocumentLayout.json"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\.vs\\ProjectEvaluation",
            "childrenFiles": [
              {
                "name": "final_test_hybrid.metadata.v10.bin"
              },
              {
                "name": "final_test_hybrid.projects.v10.bin"
              },
              {
                "name": "final_test_hybrid.strings.v10.bin"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid",
        "childrenDirs": [
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\.config",
            "childrenFiles": [
              {
                "name": "dotnet-tools.json"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\.specstory",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\.specstory\\history",
                "childrenFiles": [
                  {
                    "name": "2025-11-21_07-09Z-настройка-высоты-дата-грида.md"
                  },
                  {
                    "name": "2025-11-22_16-09Z-add-div-wrapper-in-razor-component.md"
                  },
                  {
                    "name": "2025-11-27_12-35Z-как-растянуть-схему-в-mycomponent-razor.md"
                  },
                  {
                    "name": "2025-12-01_11-46Z-странное-отображение-в-компоненте-razor.md"
                  },
                  {
                    "name": "2025-12-01_11-54Z-проблемы-с-отображением-элементов.md"
                  },
                  {
                    "name": "2025-12-01_14-01Z-изменение-id-для-svg-в-отоплении.md"
                  }
                ],
                "fullSubtreeExtensionCounts": {
                  ".md": 80
                },
                "numFiles": 80
              }
            ],
            "childrenFiles": [
              {
                "name": ".gitignore"
              }
            ],
            "fullSubtreeExtensionCounts": {
              ".md": 80
            },
            "numFiles": 80
          },
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Components",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Components\\Base",
                "childrenFiles": [
                  {
                    "name": "GridInplaceEditorBase.cs"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Components\\Engineer",
                "childrenDirs": [
                  {
                    "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Components\\Engineer\\Sequence",
                    "fullSubtreeExtensionCounts": {
                      ".cs": 5,
                      ".css": 1,
                      ".razor": 1
                    },
                    "numFiles": 7
                  }
                ],
                "childrenFiles": [
                  {
                    "name": "MainEngineering.razor"
                  },
                  {
                    "name": "MainEngineering.razor.cs"
                  },
                  {
                    "name": "MainEngineering.razor.css"
                  }
                ],
                "childrenWereProcessed": true,
                "fullSubtreeExtensionCounts": {
                  ".cs": 5,
                  ".css": 1,
                  ".razor": 1
                },
                "numFiles": 7
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Components\\Indicators",
                "childrenFiles": [
                  {
                    "name": "PlcIndicator.razor"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Components\\Overview",
                "childrenFiles": [
                  {
                    "name": "AiCallCheck.razor"
                  },
                  {
                    "name": "AiCallCheck.razor.cs"
                  },
                  {
                    "name": "AiCallCheck.razor.css"
                  },
                  {
                    "name": "LampIndicator.razor"
                  },
                  {
                    "name": "LampIndicator.razor.css"
                  },
                  {
                    "name": "LampOutput.razor"
                  },
                  {
                    "name": "LampOutput.razor.css"
                  },
                  {
                    "name": "PanelBox.razor"
                  },
                  {
                    "name": "PanelBox.razor.css"
                  },
                  {
                    "name": "RtdCalCheck.razor"
                  },
                  {
                    "name": "RtdCalCheck.razor.cs"
                  },
                  {
                    "name": "RtdCalCheck.razor.css"
                  },
                  {
                    "name": "ValueIndicator.razor"
                  },
                  {
                    "name": "ValueIndicator.razor.css"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenWereProcessed": true,
            "fullSubtreeExtensionCounts": {
              ".cs": 5,
              ".css": 1,
              ".razor": 1
            },
            "numFiles": 7
          },
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Models",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Models\\Enum",
                "childrenFiles": [
                  {
                    "name": "SequenceContextAction.cs"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenFiles": [
              {
                "name": "SequenceRow.cs"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa",
                "childrenDirs": [
                  {
                    "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa\\Interface",
                    "fullSubtreeExtensionCounts": {
                      ".cs": 3
                    },
                    "numFiles": 3
                  }
                ],
                "childrenFiles": [
                  {
                    "name": "OpcUaConnectionService.cs"
                  },
                  {
                    "name": "OpcUaReadWriteService.cs"
                  },
                  {
                    "name": "OpcUaSettings.cs"
                  },
                  {
                    "name": "OpcUaSubscriptionService.cs"
                  }
                ],
                "childrenWereProcessed": true,
                "fullSubtreeExtensionCounts": {
                  ".cs": 3
                },
                "numFiles": 3
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\Sequence",
                "childrenFiles": [
                  {
                    "name": "ISequenceExcelService.cs"
                  },
                  {
                    "name": "SequenceExcelService.cs"
                  },
                  {
                    "name": "TestSequenceService.cs"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\Settings",
                "childrenDirs": [
                  {
                    "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\Settings\\IO",
                    "fullSubtreeExtensionCounts": {
                      ".cs": 2
                    },
                    "numFiles": 2
                  },
                  {
                    "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\Settings\\UI",
                    "fullSubtreeExtensionCounts": {
                      ".cs": 2
                    },
                    "numFiles": 2
                  }
                ],
                "childrenFiles": [
                  {
                    "name": "IndicatorHelper.cs"
                  }
                ],
                "childrenWereProcessed": true,
                "fullSubtreeExtensionCounts": {
                  ".cs": 4
                },
                "numFiles": 4
              }
            ],
            "childrenWereProcessed": true,
            "fullSubtreeExtensionCounts": {
              ".cs": 7
            },
            "numFiles": 7
          },
          {
            "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\wwwroot",
            "childrenDirs": [
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\wwwroot\\css",
                "childrenFiles": [
                  {
                    "name": "app.css"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\wwwroot\\images",
                "childrenFiles": [
                  {
                    "name": "GreenLamp.png"
                  },
                  {
                    "name": "RedLamp.png"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenFiles": [
              {
                "name": "index.html"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": "_Imports.razor"
          },
          {
            "name": ".cursorindexingignore"
          },
          {
            "name": ".cursorrules"
          },
          {
            "name": ".gitignore"
          },
          {
            "name": "appsettings.json"
          },
          {
            "name": "Final_Test_Hybrid.csproj"
          },
          {
            "name": "Form1.cs"
          },
          {
            "name": "Form1.Designer.cs"
          },
          {
            "name": "Form1.resx"
          },
          {
            "name": "MyComponent.razor"
          },
          {
            "name": "MyComponent.razor.css"
          },
          {
            "name": "Order.cs"
          },
          {
            "name": "Program.cs"
          }
        ],
        "fullSubtreeExtensionCounts": {
          ".md": 80,
          ".cs": 12,
          ".css": 1,
          ".razor": 1
        },
        "numFiles": 94
      }
    ],
    "childrenFiles": [
      {
        "name": ".cursorindexingignore"
      },
      {
        "name": "Final_Test_Hybrid.sln.DotSettings.user"
      },
      {
        "name": "Final_Test_Hybrid.slnx"
      }
    ],
    "fullSubtreeExtensionCounts": {
      ".md": 80,
      ".cs": 12,
      ".css": 1,
      ".razor": 1
    },
    "numFiles": 94
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Locating Services/OpcUa path**

Planning to use a glob search to find the Services/OpcUa directory under Final_Test_Hybrid.</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **15** results in **1** directory</summary>

Directory: **d:/projects/Final_Test_Hybrid/Final_Test_Hybrid** (15 files)

| File |
|------|
| `../../../../.\Services\OpcUa\OpcUaSubscriptionService.cs` |
| `../../../../.\Services\OpcUa\OpcUaReadWriteService.cs` |
| `../../../../.\Services\OpcUa\OpcUaConnectionService.cs` |
| `../../../../.\Services\Settings\IndicatorHelper.cs` |
| `../../../../.\Services\OpcUa\Interface\IOpcUaReadWriteService.cs` |
| `../../../../.\Services\OpcUa\Interface\IOpcUaSubscriptionService.cs` |
| `../../../../.\Services\OpcUa\Interface\IOpcUaConnectionService.cs` |
| `../../../../.\Services\OpcUa\OpcUaSettings.cs` |
| `../../../../.\Services\Sequence\TestSequenceService.cs` |
| `../../../../.\Services\Sequence\SequenceExcelService.cs` |
| `../../../../.\Services\Settings\IO\WinFormsFilePickerService.cs` |
| `../../../../.\Services\Sequence\ISequenceExcelService.cs` |
| `../../../../.\Services\Settings\UI\NotificationServiceWrapper.cs` |
| `../../../../.\Services\Settings\UI\INotificationService.cs` |
| `../../../../.\Services\Settings\IO\IFilePickerService.cs` |

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying absolute file paths**

Noticed the current paths may be Windows relative; I'll ensure the code uses absolute paths like "d:/projects/.../Final_Test_Hybrid/Services/OpcUa" when reading files to avoid path resolution issues.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaConnectionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaConnectionService.cs"
}
```
Result:

```json
{
  "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing Opc.Ua;\r\nusing Opc.Ua.Client;\r\n\r\nnamespace Final_Test_Hybrid.Services.OpcUa\r\n{\r\n    public class OpcUaConnectionService(\r\n        ILogger&lt;OpcUaConnectionService&gt; logger,\r\n        IOptions&lt;OpcUaSettings&gt; settings,\r\n        ISessionFactory sessionFactory)\r\n        : IOpcUaConnectionService\r\n    {\r\n        public bool IsConnected =&gt; Session?.Connected == true;\r\n        public Session? Session { get; private set; }\r\n        public event EventHandler&lt;bool&gt;? ConnectionChanged;\r\n        private readonly OpcUaSettings _settings = settings.Value;\r\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\r\n        private readonly Lock _reconnectLock = new();\r\n        private SessionReconnectHandler? _reconnectHandler;\r\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\r\n        private CancellationTokenSource? _cts;\r\n        private Task? _connectLoopTask;\r\n        private bool _lastConnectionState;\r\n        private int _currentDelayMs;\r\n\r\n        public async Task StartAsync(CancellationToken ct = default)\r\n        {\r\n            if (_connectLoopTask is { IsCompleted: false })\r\n            {\r\n                return;\r\n            }\r\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\r\n            await InitializeApplicationConfigAsync();\r\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\r\n        }\r\n\r\n        public async Task StopAsync()\r\n        {\r\n            await CancelConnectionAsync();\r\n            DisposeReconnectHandler();\r\n            await _sessionLock.WaitAsync();\r\n            try\r\n            {\r\n                await CloseSessionAsync();\r\n            }\r\n            finally\r\n            {\r\n                _sessionLock.Release();\r\n            }\r\n            NotifyConnectionChanged(false);\r\n        }\r\n\r\n        public async ValueTask DisposeAsync()\r\n        {\r\n            await StopAsync();\r\n            _sessionLock.Dispose();\r\n        }\r\n\r\n        private async Task InitializeApplicationConfigAsync()\r\n        {\r\n            _appConfig = new Opc.Ua.ApplicationConfiguration\r\n            {\r\n                ApplicationName = _settings.ApplicationName,\r\n                ApplicationUri = $\"urn:{_settings.ApplicationName}\",\r\n                ApplicationType = ApplicationType.Client,\r\n                SecurityConfiguration = new SecurityConfiguration\r\n                {\r\n                    ApplicationCertificate = new CertificateIdentifier(),\r\n                    AutoAcceptUntrustedCertificates = true\r\n                },\r\n                ClientConfiguration = new ClientConfiguration\r\n                {\r\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\r\n                },\r\n                TransportConfigurations = [],\r\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\r\n            };\r\n            await _appConfig.ValidateAsync(ApplicationType.Client);\r\n        }\r\n\r\n        private async Task ConnectLoopAsync(CancellationToken ct)\r\n        {\r\n            _currentDelayMs = _settings.ReconnectIntervalMs;\r\n            try\r\n            {\r\n                while (!ct.IsCancellationRequested)\r\n                {\r\n                    var connected = await TryReconnectIfNeededAsync(ct);\r\n                    UpdateBackoffDelay(connected);\r\n                    await Task.Delay(_currentDelayMs, ct);\r\n                }\r\n            }\r\n            catch (OperationCanceledException)\r\n            {\r\n                logger.LogInformation(\"Connection loop canceled\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Connection loop failed\");\r\n            }\r\n        }\r\n\r\n        private void UpdateBackoffDelay(bool connected)\r\n        {\r\n            if (connected)\r\n            {\r\n                _currentDelayMs = _settings.ReconnectIntervalMs;\r\n                return;\r\n            }\r\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\r\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\r\n        }\r\n\r\n        private async Task&lt;bool&gt; TryReconnectIfNeededAsync(CancellationToken ct)\r\n        {\r\n            if (IsReconnectingOrConnected())\r\n            {\r\n                return IsConnected;\r\n            }\r\n            await TryConnectAsync(ct);\r\n            return IsConnected;\r\n        }\r\n\r\n        private bool IsReconnectingOrConnected()\r\n        {\r\n            lock (_reconnectLock)\r\n            {\r\n                return _reconnectHandler != null || Session is { Connected: true };\r\n            }\r\n        }\r\n\r\n        private async Task TryConnectAsync(CancellationToken ct)\r\n        {\r\n            await _sessionLock.WaitAsync(ct);\r\n            try\r\n            {\r\n                DisposeReconnectHandler();\r\n                await CloseSessionAsync();\r\n                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);\r\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\r\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\r\n                Session = await CreateSessionAsync(configEndpoint, ct);\r\n                Session.KeepAlive += OnSessionKeepAlive;\r\n                logger.LogInformation(\"Connected to OPC UA server\");\r\n                NotifyConnectionChanged(true);\r\n            }\r\n            catch (OperationCanceledException)\r\n            {\r\n                // Cancellation is expected during shutdown\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Failed to connect to OPC UA server\");\r\n                NotifyConnectionChanged(false);\r\n            }\r\n            finally\r\n            {\r\n                _sessionLock.Release();\r\n            }\r\n        }\r\n\r\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\r\n        {\r\n            if (ShouldSkipKeepAlive(e))\r\n            {\r\n                return;\r\n            }\r\n            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);\r\n            NotifyConnectionChanged(false);\r\n            StartReconnectIfNeeded();\r\n        }\r\n\r\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\r\n        {\r\n            return e.Status == null || ServiceResult.IsGood(e.Status);\r\n        }\r\n\r\n        private void StartReconnectIfNeeded()\r\n        {\r\n            lock (_reconnectLock)\r\n            {\r\n                if (_reconnectHandler != null || Session == null)\r\n                {\r\n                    return;\r\n                }\r\n                logger.LogInformation(\"Reconnecting...\");\r\n                _reconnectHandler = new SessionReconnectHandler();\r\n                _reconnectHandler.BeginReconnect(\r\n                    Session,\r\n                    _settings.ReconnectIntervalMs,\r\n                    OnReconnectComplete);\r\n            }\r\n        }\r\n\r\n        private void OnReconnectComplete(object? sender, EventArgs e)\r\n        {\r\n            lock (_reconnectLock)\r\n            {\r\n                UpdateSessionIfReconnected();\r\n                DisposeReconnectHandler();\r\n            }\r\n        }\r\n\r\n        private void UpdateSessionIfReconnected()\r\n        {\r\n            if (_reconnectHandler?.Session is not Session newSession)\r\n            {\r\n                return;\r\n            }\r\n            var oldSession = Session;\r\n            if (ReferenceEquals(oldSession, newSession))\r\n            {\r\n                logger.LogInformation(\"Reconnected to OPC UA server (same session)\");\r\n                NotifyConnectionChanged(true);\r\n                return;\r\n            }\r\n            if (oldSession != null)\r\n            {\r\n                oldSession.KeepAlive -= OnSessionKeepAlive;\r\n                oldSession.Dispose();\r\n            }\r\n\r\n            Session = newSession;\r\n            Session.KeepAlive += OnSessionKeepAlive;\r\n            logger.LogInformation(\"Reconnected to OPC UA server\");\r\n            NotifyConnectionChanged(true);\r\n        }\r\n\r\n        private void NotifyConnectionChanged(bool connected)\r\n        {\r\n            if (_lastConnectionState == connected)\r\n            {\r\n                return;\r\n            }\r\n            _lastConnectionState = connected;\r\n            ConnectionChanged?.Invoke(this, connected);\r\n        }\r\n\r\n        private async Task CancelConnectionAsync()\r\n        {\r\n            if (_cts == null)\r\n            {\r\n                return;\r\n            }\r\n            await _cts.CancelAsync();\r\n            _cts.Dispose();\r\n            _cts = null;\r\n            DisposeReconnectHandler();\r\n            await WaitConnectLoopAsync();\r\n        }\r\n\r\n        private void DisposeReconnectHandler()\r\n        {\r\n            lock (_reconnectLock)\r\n            {\r\n                _reconnectHandler?.Dispose();\r\n                _reconnectHandler = null;\r\n            }\r\n        }\r\n\r\n        private async Task CloseSessionAsync()\r\n        {\r\n            if (Session == null)\r\n            {\r\n                return;\r\n            }\r\n            Session.KeepAlive -= OnSessionKeepAlive;\r\n            try\r\n            {\r\n                await Session.CloseAsync();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogWarning(ex, \"Error closing session\");\r\n            }\r\n            Session.Dispose();\r\n            Session = null;\r\n        }\r\n\r\n        private async Task WaitConnectLoopAsync()\r\n        {\r\n            if (_connectLoopTask == null)\r\n            {\r\n                return;\r\n            }\r\n            try\r\n            {\r\n                await _connectLoopTask;\r\n            }\r\n            catch (OperationCanceledException)\r\n            {\r\n                logger.LogInformation(\"Connection loop canceled\");\r\n            }\r\n            _connectLoopTask = null;\r\n        }\r\n\r\n        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\r\n        {\r\n            var session = await sessionFactory.CreateAsync(\r\n                _appConfig,\r\n                configEndpoint,\r\n                updateBeforeConnect: false,\r\n                sessionName: _settings.ApplicationName,\r\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\r\n                identity: new UserIdentity(new AnonymousIdentityToken()),\r\n                preferredLocales: null,\r\n                ct).ConfigureAwait(false);\r\n            return session switch\r\n            {\r\n                Session s =&gt; s,\r\n                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")\r\n            };\r\n        }\r\n    }\r\n}\r\n",
  "totalLinesInFile": 318
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Noting missing OpcUa files**

The current set of OpcUa files is incomplete, indicating a need to locate or obtain the remaining ones.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaReadWriteService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaReadWriteService.cs"
}
```
Result:

```json
{
  "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Opc.Ua;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaReadWriteService(\n        IOpcUaConnectionService connection,\n        ILogger&lt;OpcUaReadWriteService&gt; logger)\n        : IOpcUaReadWriteService\n    {\n        public async Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default)\n        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot read node {NodeId}: Session not connected\", nodeId);\n                return default;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var value = await session.ReadValueAsync(node, ct);\n                return GetValueOrDefault&lt;T&gt;(nodeId, value);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to read node {NodeId}\", nodeId);\n                return default;\n            }\n        }\n\n        private T? GetValueOrDefault&lt;T&gt;(string nodeId, DataValue value)\n        {\n            if (!StatusCode.IsBad(value.StatusCode))\n            {\n                return value.Value is T typedValue\n                    ? typedValue\n                    : LogAndReturnDefault&lt;T&gt;(nodeId);\n            }\n            logger.LogWarning(\"Read node {NodeId} returned bad status {Status}\", nodeId, value.StatusCode);\n            return default;\n        }\n\n        private T? LogAndReturnDefault&lt;T&gt;(string nodeId)\n        {\n            logger.LogWarning(\"Cannot cast value from node {NodeId} to type {Type}\", nodeId, typeof(T).Name);\n            return default;\n        }\n\n        public async Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default)\n        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot write node {NodeId}: Session not connected\", nodeId);\n                return;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var writeValue = CreateWriteValue(node, value);\n                var request = new WriteValueCollection { writeValue };\n                var response = await session.WriteAsync(null, request, ct);\n                LogWriteResult(nodeId, response.Results);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to write node {NodeId}\", nodeId);\n            }\n        }\n\n        private void LogWriteResult(string nodeId, StatusCodeCollection? results)\n        {\n            if (results == null || results.Count == 0)\n            {\n                logger.LogWarning(\"Write node {NodeId}: empty results\", nodeId);\n                return;\n            }\n            LogBadStatusIfNeeded(nodeId, results[0]);\n        }\n\n        private void LogBadStatusIfNeeded(string nodeId, StatusCode status)\n        {\n            if (StatusCode.IsBad(status))\n            {\n                logger.LogWarning(\"Write node {NodeId} failed with status {Status}\", nodeId, status);\n            }\n        }\n\n        private WriteValue CreateWriteValue&lt;T&gt;(NodeId node, T value)\n        {\n            return new WriteValue\n            {\n                NodeId = node,\n                AttributeId = Attributes.Value,\n                Value = new DataValue(new Variant(value))\n            };\n        }\n    }\n}",
  "totalLinesInFile": 101
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Identifying need for subscription service**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "using System.Collections.Concurrent;\r\nusing Final_Test_Hybrid.Services.OpcUa.Interface;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing Opc.Ua;\r\nusing Opc.Ua.Client;\r\n\r\nnamespace Final_Test_Hybrid.Services.OpcUa\r\n{\r\n    public class OpcUaSubscriptionService(\r\n        IOpcUaConnectionService connectionService,\r\n        IOptions&lt;OpcUaSettings&gt; settings,\r\n        ILogger&lt;OpcUaSubscriptionService&gt; logger) : IOpcUaSubscriptionService\r\n    {\r\n        private readonly OpcUaSettings _settings = settings.Value;\r\n        private readonly ConcurrentDictionary&lt;string, Subscription&gt; _subscriptions = new();\r\n        private readonly ConcurrentDictionary&lt;string, Action&lt;object?&gt;&gt; _callbacks = new();\r\n        private readonly Lock _connectionEventsLock = new();\r\n        private readonly SemaphoreSlim _connectionChangeGate = new(1, 1);\r\n        private readonly CancellationTokenSource _disposeCts = new();\r\n        private bool _connectionEventsAttached;\r\n        private bool _disposed;\r\n\r\n        public OpcUaSubscriptionService(\r\n            IOpcUaConnectionService connectionService,\r\n            IOptions&lt;OpcUaSettings&gt; settings,\r\n            ILogger&lt;OpcUaSubscriptionService&gt; logger,\r\n            bool subscribeToConnection = true)\r\n            : this(connectionService, settings, logger)\r\n        {\r\n            if (subscribeToConnection)\r\n            {\r\n                connectionService.ConnectionChanged += OnConnectionChanged;\r\n                _connectionEventsAttached = true;\r\n            }\r\n        }\r\n\r\n        public async Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback)\r\n        {\r\n            ObjectDisposedException.ThrowIf(_disposed, this);\r\n            EnsureConnectionEventsAttached();\r\n\r\n            await _connectionChangeGate.WaitAsync();\r\n            try\r\n            {\r\n                _callbacks[nodeId] = callback;\r\n                var session = connectionService.Session;\r\n                if (session is not { Connected: true })\r\n                {\r\n                    return;\r\n                }\r\n                await RemoveExistingSubscriptionAsync(nodeId);\r\n                await CreateAndAddSubscriptionAsync(nodeId, callback, session);\r\n            }\r\n            finally\r\n            {\r\n                _connectionChangeGate.Release();\r\n            }\r\n        }\r\n\r\n        private async Task CreateAndAddSubscriptionAsync(string nodeId, Action&lt;object?&gt; callback, Session session)\r\n        {\r\n            try\r\n            {\r\n                var subscription = CreateSubscription(session);\r\n                var monitoredItem = CreateMonitoredItem(nodeId, callback, subscription);\r\n                await AddSubscriptionToSessionAsync(session, subscription, monitoredItem);\r\n                _subscriptions[nodeId] = subscription;\r\n                logger.LogInformation(\"Subscribed to node {NodeId}\", nodeId);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Failed to subscribe to node {NodeId}\", nodeId);\r\n            }\r\n        }\r\n\r\n        public async Task UnsubscribeAsync(string nodeId)\r\n        {\r\n            await _connectionChangeGate.WaitAsync();\r\n            try\r\n            {\r\n                _callbacks.TryRemove(nodeId, out _);\r\n                if (!_subscriptions.TryRemove(nodeId, out var subscription))\r\n                {\r\n                    return;\r\n                }\r\n                await RemoveSubscriptionSafelyAsync(nodeId, subscription);\r\n            }\r\n            finally\r\n            {\r\n                _connectionChangeGate.Release();\r\n            }\r\n        }\r\n\r\n        private async Task RemoveSubscriptionSafelyAsync(string nodeId, Subscription subscription)\r\n        {\r\n            try\r\n            {\r\n                await RemoveSubscriptionFromSessionAsync(subscription);\r\n                subscription.Dispose();\r\n                logger.LogInformation(\"Unsubscribed from node {NodeId}\", nodeId);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Failed to unsubscribe from node {NodeId}\", nodeId);\r\n            }\r\n        }\r\n\r\n        public async ValueTask DisposeAsync()\r\n        {\r\n            if (_disposed)\r\n            {\r\n                return;\r\n            }\r\n            _disposed = true;\r\n            logger.LogInformation(\"Disposing OpcUaSubscriptionService with {Count} active subscriptions\", _subscriptions.Count);\r\n            await _disposeCts.CancelAsync();\r\n            DetachConnectionEvents();\r\n            await _connectionChangeGate.WaitAsync();\r\n            try\r\n            {\r\n                await DisposeAllSubscriptionsAsync();\r\n            }\r\n            finally\r\n            {\r\n                _connectionChangeGate.Release();\r\n                _connectionChangeGate.Dispose();\r\n                _disposeCts.Dispose();\r\n            }\r\n        }\r\n\r\n        private async Task DisposeAllSubscriptionsAsync(bool clearCallbacks = true)\r\n        {\r\n            foreach (var subscription in _subscriptions.Values.ToArray())\r\n            {\r\n                await SafeRemoveSubscriptionAsync(subscription);\r\n            }\r\n            _subscriptions.Clear();\r\n            if (clearCallbacks)\r\n            {\r\n                _callbacks.Clear();\r\n            }\r\n        }\r\n\r\n        private async Task SafeRemoveSubscriptionAsync(Subscription subscription)\r\n        {\r\n            try\r\n            {\r\n                await RemoveSubscriptionFromSessionAsync(subscription);\r\n                subscription.Dispose();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error disposing subscription\");\r\n            }\r\n        }\r\n\r\n        private Subscription CreateSubscription(Session session)\r\n        {\r\n            return new Subscription(session.DefaultSubscription)\r\n            {\r\n                PublishingInterval = _settings.PublishingIntervalMs\r\n            };\r\n        }\r\n\r\n        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)\r\n        {\r\n            var monitoredItem = new MonitoredItem(subscription.DefaultItem)\r\n            {\r\n                StartNodeId = new NodeId(nodeId),\r\n                AttributeId = Attributes.Value\r\n            };\r\n            monitoredItem.Notification += (item, e) =&gt;\r\n            {\r\n                try\r\n                {\r\n                    if (e.NotificationValue is not MonitoredItemNotification notification)\r\n                    {\r\n                        return;\r\n                    }\r\n                    callback(notification.Value.Value);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);\r\n                }\r\n            };\r\n            return monitoredItem;\r\n        }\r\n\r\n        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)\r\n        {\r\n            subscription.AddItem(monitoredItem);\r\n            session.AddSubscription(subscription);\r\n            try\r\n            {\r\n                await subscription.CreateAsync();\r\n            }\r\n            catch\r\n            {\r\n                await session.RemoveSubscriptionAsync(subscription);\r\n                subscription.Dispose();\r\n                throw;\r\n            }\r\n        }\r\n\r\n        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)\r\n        {\r\n            if (subscription.Session is not { Connected: true })\r\n            {\r\n                return;\r\n            }\r\n            await subscription.DeleteAsync(true); // true = removes from session automatically\r\n        }\r\n\r\n        private async Task RemoveExistingSubscriptionAsync(string nodeId)\r\n        {\r\n            if (!_subscriptions.TryGetValue(nodeId, out var existing))\r\n            {\r\n                return;\r\n            }\r\n            try\r\n            {\r\n                await RemoveSubscriptionFromSessionAsync(existing);\r\n                existing.Dispose();\r\n                _subscriptions.TryRemove(nodeId, out _);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Failed to remove existing subscription for node {NodeId}\", nodeId);\r\n            }\r\n        }\r\n\r\n        private void EnsureConnectionEventsAttached()\r\n        {\r\n            lock (_connectionEventsLock)\r\n            {\r\n                if (_connectionEventsAttached)\r\n                {\r\n                    return;\r\n                }\r\n                connectionService.ConnectionChanged += OnConnectionChanged;\r\n                _connectionEventsAttached = true;\r\n            }\r\n        }\r\n\r\n        private void DetachConnectionEvents()\r\n        {\r\n            lock (_connectionEventsLock)\r\n            {\r\n                if (!_connectionEventsAttached)\r\n                {\r\n                    return;\r\n                }\r\n                connectionService.ConnectionChanged -= OnConnectionChanged;\r\n                _connectionEventsAttached = false;\r\n            }\r\n        }\r\n\r\n        private void OnConnectionChanged(object? sender, bool connected)\r\n            =&gt; _ = OnConnectionChangedAsync(connected);\r\n\r\n        private async Task OnConnectionChangedAsync(bool connected)\r\n        {\r\n            if (_disposed)\r\n            {\r\n                return;\r\n            }\r\n\r\n            try\r\n            {\r\n                logger.LogDebug(\"Connection state changed: Connected={Connected}, ActiveSubscriptions={Count}\", connected, _callbacks.Count);\r\n                await HandleConnectionChangeSafelyAsync(connected);\r\n            }\r\n            catch (OperationCanceledException)\r\n            {\r\n                // Normal cancellation during dispose\r\n            }\r\n            catch (ObjectDisposedException)\r\n            {\r\n                // Service was disposed during event handling\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Unhandled error in connection change handler\");\r\n            }\r\n        }\r\n\r\n        private async Task HandleConnectionChangeSafelyAsync(bool connected)\r\n        {\r\n            await _connectionChangeGate.WaitAsync(_disposeCts.Token);\r\n            try\r\n            {\r\n                if (connected)\r\n                {\r\n                    await ResubscribeAllAsync();\r\n                }\r\n                else\r\n                {\r\n                    await DropAllSubscriptionsAsync();\r\n                }\r\n            }\r\n            catch (ObjectDisposedException)\r\n            {\r\n                logger.LogDebug(\"Connection change handling aborted: service was disposed during operation\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error handling connection change. Connected={Connected}, SubscriptionCount={Count}\", connected, _subscriptions.Count);\r\n            }\r\n            finally\r\n            {\r\n                _connectionChangeGate.Release();\r\n            }\r\n        }\r\n\r\n        private async Task ResubscribeAllAsync()\r\n        {\r\n            if (connectionService.Session is not { Connected: true } session)\r\n            {\r\n                return;\r\n            }\r\n            foreach (var kvp in _callbacks.ToArray())\r\n            {\r\n                await RemoveExistingSubscriptionAsync(kvp.Key);\r\n                await CreateAndAddSubscriptionAsync(kvp.Key, kvp.Value, session);\r\n            }\r\n        }\r\n\r\n        private async Task DropAllSubscriptionsAsync()\r\n        {\r\n            await DisposeAllSubscriptionsAsync(clearCallbacks: false);\r\n        }\r\n    }\r\n}",
  "totalLinesInFile": 335
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning creation of settings class**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaSettings.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/OpcUaSettings.cs"
}
```
Result:

```json
{
  "contents": "namespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSettings\n    {\n        public string EndpointUrl { get; set; } = \"opc.tcp://192.168.1.100:4840\";\n        public string ApplicationName { get; set; } = \"FinalTestHybrid\";\n        public int ReconnectIntervalMs { get; set; } = 5000;\n        public int SessionTimeoutMs { get; set; } = 60000;\n        public int PublishingIntervalMs { get; set; } = 1000;\n        public int OperationTimeoutMs { get; set; } = 15000;\n    }\n}",
  "totalLinesInFile": 12
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Identifying interface usage**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/Interface/IOpcUaConnectionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/Interface/IOpcUaConnectionService.cs"
}
```
Result:

```json
{
  "contents": "using Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaConnectionService : IAsyncDisposable\n    {\n        bool IsConnected { get; }\n        Session? Session { get; }\n        event EventHandler&lt;bool&gt;? ConnectionChanged;\n\n        Task StartAsync(CancellationToken ct = default);\n        Task StopAsync();\n    }\n}\n",
  "totalLinesInFile": 15
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/Interface/IOpcUaReadWriteService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/Interface/IOpcUaReadWriteService.cs"
}
```
Result:

```json
{
  "contents": "namespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaReadWriteService\n    {\n        Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default);\n        Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default);\n    }\n}\n",
  "totalLinesInFile": 9
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/Interface/IOpcUaSubscriptionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid/Services/OpcUa/Interface/IOpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "namespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaSubscriptionService : IAsyncDisposable\n    {\n        Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback);\n        Task UnsubscribeAsync(string nodeId);\n    }\n}\n",
  "totalLinesInFile": 9
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for SessionFactory type**

I'm looking for a SessionFactory definition or usage in the codebase to understand its presence and decide if it needs implementation or adjustment.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "class SessionFactory",
  "path": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "class SessionFactory",
    "path": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid",
    "outputMode": "content",
    "workspaceResults": {
      "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Exploring session factory options**

I'm checking for the presence of session factory interfaces or classes, and considering using Opc.Ua.Client or dependency injection for session management.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "ISessionFactory",
  "path": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "ISessionFactory",
    "path": "d:/projects/Final_Test_Hybrid/Final_Test_Hybrid",
    "outputMode": "content",
    "workspaceResults": {
      "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid": {
        "content": {
          "matches": [
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-49Z-проверка-стабильности-opc-ua-кода.md",
              "matches": [
                {
                  "lineNumber": 662,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\r\\nusing Microsoft.Extensions.Logging;\\r\\nusing Microsoft.Extensions.Options;\\r\\nusing Opc.Ua;\\r\\nusing Opc.Ua.Client;\\r\\n\\r\\nnamespace Final_Test_Hybrid.Services.OpcUa\\r\\n{\\r\\n    public class OpcUaConnectionService(\\r\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\r\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\r\\n        ISessionFactory sessionFactory)\\r\\n        : IOpcUaConnectionService\\r\\n    {\\r\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\r\\n        public Session? Session { get; private set; }\\r\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\r\\n        private readonly OpcUaSettings _settings = settings.Value;\\r\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\r\\n        private readonly Lock _reconnectLock = new();\\r\\n        private SessionReconnectHandler? _reconnectHandler;\\r\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\r\\n        private CancellationTokenSource? _cts;\\r\\n        private Task? _connectLoopTask;\\r\\n        private bool _lastConnectionState;\\r\\n        private int _currentDelayMs;\\r\\n\\r\\n        public async Task StartAsync(CancellationToken ct = default)\\r\\n        {\\r\\n            if (_connectLoopTask is { IsCompleted: false })\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\r\\n            await InitializeApplicationConfigAsync();\\r\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\r\\n        }\\r\\n\\r\\n        public async Task StopAsync()\\r\\n        {\\r\\n            await CancelConnectionAsync();\\r\\n            DisposeReconnectHandler();\\r\\n            await _sessionLock.WaitAsync();\\r\\n            try\\r\\n            {\\r\\n                await CloseSessionAsync();\\r\\n            }\\r\\n            finally\\r\\n            {\\r\\n                _sessionLock.Release();\\r\\n            }\\r\\n            NotifyConnectionChanged(false);\\r\\n        }\\r\\n\\r\\n        public async ValueTask DisposeAsync()\\r\\n        {\\r\\n            await StopAsync();\\r\\n            _sessionLock.Dispose();\\r\\n        }\\r\\n\\r\\n        private async Task InitializeApplicationConfigAsync()\\r\\n        {\\r\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\r\\n            {\\r\\n                ApplicationName = _settings.ApplicationName,\\r\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\r\\n                ApplicationType = ApplicationType.Client,\\r\\n                SecurityConfiguration = new SecurityConfiguration\\r\\n                {\\r\\n                    ApplicationCertificate = new CertificateIdentifier(),\\r\\n                    AutoAcceptUntrustedCertificates = true\\r\\n                },\\r\\n                ClientConfiguration = new ClientConfiguration\\r\\n                {\\r\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\r\\n                },\\r\\n                TransportConfigurations = [],\\r\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\r\\n            };\\r\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\r\\n        }\\r\\n\\r\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\r\\n        {\\r\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\r\\n            try\\r\\n            {\\r\\n                while (!ct.IsCancellationRequested)\\r\\n                {\\r\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\r\\n                    UpdateBackoffDelay(connected);\\r\\n                    await Task.Delay(_currentDelayMs, ct);\\r\\n                }\\r\\n            }\\r\\n            catch (OperationCanceledException)\\r\\n            {\\r\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\r\\n            }\\r\\n            catch (Exception ex)\\r\\n            {\\r\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private void UpdateBackoffDelay(bool connected)\\r\\n        {\\r\\n            if (connected)\\r\\n            {\\r\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\r\\n                return;\\r\\n            }\\r\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\r\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\r\\n        }\\r\\n\\r\\n        private async Task&amp;lt;bool&amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\r\\n        {\\r\\n            if (IsReconnectingOrConnected())\\r\\n            {\\r\\n                return IsConnected;\\r\\n            }\\r\\n            await TryConnectAsync(ct);\\r\\n            return IsConnected;\\r\\n        }\\r\\n\\r\\n        private bool IsReconnectingOrConnected()\\r\\n        {\\r\\n            lock (_reconnectLock)\\r\\n            {\\r\\n                return _reconnectHandler != null || Session is { Connected: true };\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private async Task TryConnectAsync(CancellationToken ct)\\r\\n        {\\r\\n            await _sessionLock.WaitAsync(ct);\\r\\n            try\\r\\n            {\\r\\n                DisposeReconnectHandler();\\r\\n                await CloseSessionAsync();\\r\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\r\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\r\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\r\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\r\\n                Session.KeepAlive += OnSessionKeepAlive;\\r\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\r\\n                NotifyConnectionChanged(true);\\r\\n            }\\r\\n            catch (OperationCanceledException)\\r\\n            {\\r\\n                // Cancellation is expected during shutdown\\r\\n            }\\r\\n            catch (Exception ex)\\r\\n            {\\r\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\r\\n                NotifyConnectionChanged(false);\\r\\n            }\\r\\n            finally\\r\\n            {\\r\\n                _sessionLock.Release();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\r\\n        {\\r\\n            if (ShouldSkipKeepAlive(e))\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\r\\n            NotifyConnectionChanged(false);\\r\\n            StartReconnectIfNeeded();\\r\\n        }\\r\\n\\r\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\r\\n        {\\r\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\r\\n        }\\r\\n\\r\\n        private void StartReconnectIfNeeded()\\r\\n        {\\r\\n            lock (_reconnectLock)\\r\\n            {\\r\\n                if (_reconnectHandler != null || Session == null)\\r\\n                {\\r\\n                    return;\\r\\n                }\\r\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\r\\n                _reconnectHandler = new SessionReconnectHandler();\\r\\n                _reconnectHandler.BeginReconnect(\\r\\n                    Session,\\r\\n                    _settings.ReconnectIntervalMs,\\r\\n                    OnReconnectComplete);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\r\\n        {\\r\\n            lock (_reconnectLock)\\r\\n            {\\r\\n                UpdateSessionIfReconnected();\\r\\n                DisposeReconnectHandler();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private void UpdateSessionIfReconnected()\\r\\n        {\\r\\n            if (_reconnectHandler?.Session is not Session newSession)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            var oldSession = Session;\\r\\n            if (ReferenceEquals(oldSession, newSession))\\r\\n            {\\r\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\r\\n                NotifyConnectionChanged(true);\\r\\n                return;\\r\\n            }\\r\\n            if (oldSession != null)\\r\\n            {\\r\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\r\\n                oldSession.Dispose();\\r\\n            }\\r\\n\\r\\n            Session = newSession;\\r\\n            Session.KeepAlive += OnSessionKeepAlive;\\r\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\r\\n            NotifyConnectionChanged(true);\\r\\n        }\\r\\n\\r\\n        private void NotifyConnectionChanged(bool connected)\\r\\n        {\\r\\n            if (_lastConnectionState == connected)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            _lastConnectionState = connected;\\r\\n            ConnectionChanged?.Invoke(this, connected);\\r\\n        }\\r\\n\\r\\n        private async Task CancelConnectionAsync()\\r\\n        {\\r\\n            if (_cts == null)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            await _cts.CancelAsync();\\r\\n            _cts.Dispose();\\r\\n            _cts = null;\\r\\n            DisposeReconnectHandler();\\r\\n            await WaitConnectLoopAsync();\\r\\n        }\\r\\n\\r\\n        private void DisposeReconnectHandler()\\r\\n        {\\r\\n            lock (_reconnectLock)\\r\\n            {\\r\\n                _reconnectHandler?.Dispose();\\r\\n                _reconnectHandler = null;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private async Task CloseSessionAsync()\\r\\n        {\\r\\n            if (Session == null)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            Session.KeepAlive -= OnSessionKeepAlive;\\r\\n            try\\r\\n            {\\r\\n                await Session.CloseAsync();\\r\\n            }\\r\\n            catch (Exception ex)\\r\\n            {\\r\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\r\\n            }\\r\\n            Session.Dispose();\\r\\n            Session = null;\\r\\n        }\\r\\n\\r\\n        private async Task WaitConnectLoopAsync()\\r\\n        {\\r\\n            if (_connectLoopTask == null)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n            try\\r\\n            {\\r\\n                await _connectLoopTask;\\r\\n            }\\r\\n            catch (OperationCanceledException)\\r\\n            {\\r\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\r\\n            }\\r\\n            _connectLoopTask = null;\\r\\n        }\\r\\n\\r\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\r\\n        {\\r\\n            var session = await sessionFactory.CreateAsync(\\r\\n                _appConfig,\\r\\n                configEndpoint,\\r\\n                updateBeforeConnect: false,\\r\\n                sessionName: _settings.ApplicationName,\\r\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\r\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\r\\n                preferredLocales: null,\\r\\n                ct).ConfigureAwait(false);\\r\\n            return session switch\\r\\n            {\\r\\n                Session s =&amp;gt; s,\\r\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\r\\n            };\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\","
                }
              ]
            },
            {
              "file": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
              "matches": [
                {
                  "lineNumber": 12,
                  "content": "        ISessionFactory sessionFactory)"
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-44Z-проверка-стабильности-opc-ua-кода.md",
              "matches": [
                {
                  "lineNumber": 138,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        private int _currentDelayMs;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\n                    UpdateBackoffDelay(connected);\\n                    await Task.Delay(_currentDelayMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private void UpdateBackoffDelay(bool connected)\\n        {\\n            if (connected)\\n            {\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\n                return;\\n            }\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\n        }\\n\\n        private async Task&amp;lt;bool&amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return IsConnected;\\n            }\\n            await TryConnectAsync(ct);\\n            return IsConnected;\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 349,
                  "content": "  \"query\": \"How is ISessionFactory implemented and used?\","
                },
                {
                  "lineNumber": 458,
                  "content": "        \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        private int _currentDelayMs;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\","
                },
                {
                  "lineNumber": 505,
                  "content": "            \"text\": \"        ISessionFactory sessionFactory)\","
                },
                {
                  "lineNumber": 4872,
                  "content": "  \"pattern\": \"ISessionFactory|SessionFactory\","
                },
                {
                  "lineNumber": 4882,
                  "content": "    \"pattern\": \"ISessionFactory|SessionFactory\","
                },
                {
                  "lineNumber": 4894,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            var oldSession = Session;\\\\n            if (ReferenceEquals(oldSession, newSession))\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Reconnected to OPC UA server (same session)\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n                return;\\\\n            }\\\\n\\\\n            if (oldSession != null)\\\\n            {\\\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\\\n                oldSession.Dispose();\\\\n            }\\\\n\\\\n            Session = newSession;\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4898,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        private int _currentDelayMs;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\\\n                    UpdateBackoffDelay(connected);\\\\n                    await Task.Delay(_currentDelayMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateBackoffDelay(bool connected)\\\\n        {\\\\n            if (connected)\\\\n            {\\\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\\\n                return;\\\\n            }\\\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;bool&amp;amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return IsConnected;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n            return IsConnected;\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            var oldSession = Session;\\\\n            if (ReferenceEquals(oldSession, newSession))\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Reconnected to OPC UA server (same session)\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n                return;\\\\n            }\\\\n            if (oldSession != null)\\\\n            {\\\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\\\n                oldSession.Dispose();\\\\n            }\\\\n\\\\n            Session = newSession;\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4907,
                  "content": "                  \"content\": \"        ISessionFactory sessionFactory)\""
                },
                {
                  "lineNumber": 4920,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4924,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            var oldSession = Session;\\\\n            if (oldSession != null &amp;amp;amp;&amp;amp;amp; !ReferenceEquals(oldSession, newSession))\\\\n            {\\\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\\\n                oldSession.Dispose();\\\\n            }\\\\n\\\\n            Session = newSession;\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4933,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4942,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4951,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4955,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4964,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4973,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4977,
                  "content": "                  \"content\": \"3. **Line 286**: Missing &amp;#96;ISessionFactory&amp;#96; interface definition - I should check if this exists somewhere, but it's injected so it should be defined.\""
                },
                {
                  "lineNumber": 4986,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            bool reconnecting;\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                reconnecting = _reconnectHandler != null;\\\\n            }\\\\n\\\\n            if (reconnecting || Session is { Connected: true })\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 4995,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            bool reconnecting;\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                reconnecting = _reconnectHandler != null;\\\\n            }\\\\n\\\\n            if (reconnecting || Session is { Connected: true })\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5004,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            bool reconnecting;\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                reconnecting = _reconnectHandler != null;\\\\n            }\\\\n\\\\n            if (reconnecting || Session is { Connected: true })\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5013,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (Session is not { Connected: true })\\\\n            {\\\\n                await TryConnectAsync(ct);\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5022,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (Session is not { Connected: true })\\\\n            {\\\\n                await TryConnectAsync(ct);\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5031,
                  "content": "                  \"content\": \"| 'Session.Create(ApplicationConfiguration, ConfiguredEndpoint, bool, string, uint, IUserIdentity, IList&amp;lt;string&amp;gt;, CancellationToken)' is obsolete: 'Use ISessionFactory.CreateAsync' | 151:34-159:24 | DIAGNOSTIC_SEVERITY_WARNING |\""
                },
                {
                  "lineNumber": 5035,
                  "content": "                  \"content\": \"| 'Session.Create(ApplicationConfiguration, ConfiguredEndpoint, bool, string, uint, IUserIdentity, IList&amp;lt;string&amp;gt;, CancellationToken)' is obsolete: 'Use ISessionFactory.CreateAsync' | 151:34-159:24 | DIAGNOSTIC_SEVERITY_WARNING |\""
                },
                {
                  "lineNumber": 5039,
                  "content": "                  \"content\": \"Это предупреждение, не ошибка. Для простоты оставлю так - код будет работать. Если нужно убрать предупреждение, можно использовать ISessionFactory, но это усложнит код. Предупреждение можно проигнорировать для MVP.\""
                },
                {
                  "lineNumber": 5098,
                  "content": "Ищу реализацию &#96;ISessionFactory&#96;:"
                },
                {
                  "lineNumber": 5112,
                  "content": "  \"pattern\": \"AddSingleton.*ISessionFactory|AddScoped.*ISessionFactory|AddTransient.*ISessionFactory|class.*SessionFactory|: ISessionFactory\","
                },
                {
                  "lineNumber": 5122,
                  "content": "    \"pattern\": \"AddSingleton.*ISessionFactory|AddScoped.*ISessionFactory|AddTransient.*ISessionFactory|class.*SessionFactory|: ISessionFactory\","
                },
                {
                  "lineNumber": 5134,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            var oldSession = Session;\\\\n            if (ReferenceEquals(oldSession, newSession))\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Reconnected to OPC UA server (same session)\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n                return;\\\\n            }\\\\n\\\\n            if (oldSession != null)\\\\n            {\\\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\\\n                oldSession.Dispose();\\\\n            }\\\\n\\\\n            Session = newSession;\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5138,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        private int _currentDelayMs;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\\\n                    UpdateBackoffDelay(connected);\\\\n                    await Task.Delay(_currentDelayMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateBackoffDelay(bool connected)\\\\n        {\\\\n            if (connected)\\\\n            {\\\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\\\n                return;\\\\n            }\\\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;bool&amp;amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return IsConnected;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n            return IsConnected;\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            var oldSession = Session;\\\\n            if (ReferenceEquals(oldSession, newSession))\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Reconnected to OPC UA server (same session)\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n                return;\\\\n            }\\\\n            if (oldSession != null)\\\\n            {\\\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\\\n                oldSession.Dispose();\\\\n            }\\\\n\\\\n            Session = newSession;\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5147,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5151,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            var oldSession = Session;\\\\n            if (oldSession != null &amp;amp;amp;&amp;amp;amp; !ReferenceEquals(oldSession, newSession))\\\\n            {\\\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\\\n                oldSession.Dispose();\\\\n            }\\\\n\\\\n            Session = newSession;\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5160,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5169,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5178,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5182,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session is not Session newSession)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = newSession;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return session switch\\\\n            {\\\\n                Session s =&amp;amp;gt; s,\\\\n                _ =&amp;amp;gt; throw new InvalidOperationException($\\\\\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\\\\\")\\\\n            };\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5191,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5200,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (IsReconnectingOrConnected())\\\\n            {\\\\n                return;\\\\n            }\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private bool IsReconnectingOrConnected()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                return _reconnectHandler != null || Session is { Connected: true };\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            try\\\\n            {\\\\n                await Session.CloseAsync();\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogWarning(ex, \\\\\\\"Error closing session\\\\\\\");\\\\n            }\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5209,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            bool reconnecting;\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                reconnecting = _reconnectHandler != null;\\\\n            }\\\\n\\\\n            if (reconnecting || Session is { Connected: true })\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5218,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            bool reconnecting;\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                reconnecting = _reconnectHandler != null;\\\\n            }\\\\n\\\\n            if (reconnecting || Session is { Connected: true })\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5227,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Final_Test_Hybrid.Services.OpcUa.Interface;\\\\nusing Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            bool reconnecting;\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                reconnecting = _reconnectHandler != null;\\\\n            }\\\\n\\\\n            if (reconnecting || Session is { Connected: true })\\\\n            {\\\\n                return;\\\\n            }\\\\n\\\\n            await TryConnectAsync(ct);\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5236,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (Session is not { Connected: true })\\\\n            {\\\\n                await TryConnectAsync(ct);\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5245,
                  "content": "                  \"content\": \"  \\\"contents\\\": \\\"using Microsoft.Extensions.Logging;\\\\nusing Microsoft.Extensions.Options;\\\\nusing Opc.Ua;\\\\nusing Opc.Ua.Client;\\\\n\\\\nnamespace Final_Test_Hybrid.Services.OpcUa\\\\n{\\\\n    public class OpcUaConnectionService(\\\\n        ILogger&amp;amp;lt;OpcUaConnectionService&amp;amp;gt; logger,\\\\n        IOptions&amp;amp;lt;OpcUaSettings&amp;amp;gt; settings,\\\\n        ISessionFactory sessionFactory)\\\\n        : IOpcUaConnectionService\\\\n    {\\\\n        public bool IsConnected =&amp;amp;gt; Session?.Connected == true;\\\\n        public Session? Session { get; private set; }\\\\n        private readonly OpcUaSettings _settings = settings.Value;\\\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\\\n        private readonly Lock _reconnectLock = new();\\\\n        private SessionReconnectHandler? _reconnectHandler;\\\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\\\n        private CancellationTokenSource? _cts;\\\\n        private Task? _connectLoopTask;\\\\n        private bool _lastConnectionState;\\\\n        public event EventHandler&amp;amp;lt;bool&amp;amp;gt;? ConnectionChanged;\\\\n\\\\n        public async Task StartAsync(CancellationToken ct = default)\\\\n        {\\\\n            if (_connectLoopTask is { IsCompleted: false })\\\\n            {\\\\n                return;\\\\n            }\\\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\\\n            await InitializeApplicationConfigAsync();\\\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\\\n        }\\\\n\\\\n        public async Task StopAsync()\\\\n        {\\\\n            await CancelConnectionAsync();\\\\n            DisposeReconnectHandler();\\\\n            await _sessionLock.WaitAsync();\\\\n            try\\\\n            {\\\\n                await CloseSessionAsync();\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n            NotifyConnectionChanged(false);\\\\n        }\\\\n\\\\n        public async ValueTask DisposeAsync()\\\\n        {\\\\n            await StopAsync();\\\\n            _sessionLock.Dispose();\\\\n        }\\\\n\\\\n        private async Task InitializeApplicationConfigAsync()\\\\n        {\\\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\\\n            {\\\\n                ApplicationName = _settings.ApplicationName,\\\\n                ApplicationUri = $\\\\\\\"urn:{_settings.ApplicationName}\\\\\\\",\\\\n                ApplicationType = ApplicationType.Client,\\\\n                SecurityConfiguration = new SecurityConfiguration\\\\n                {\\\\n                    ApplicationCertificate = new CertificateIdentifier(),\\\\n                    AutoAcceptUntrustedCertificates = true\\\\n                },\\\\n                ClientConfiguration = new ClientConfiguration\\\\n                {\\\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\\\n                },\\\\n                TransportConfigurations = [],\\\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\\\n            };\\\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\\\n        }\\\\n\\\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\\\n        {\\\\n            try\\\\n            {\\\\n                while (!ct.IsCancellationRequested)\\\\n                {\\\\n                    await TryReconnectIfNeededAsync(ct);\\\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\\\n                }\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Connection loop failed\\\\\\\");\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\\\n        {\\\\n            if (Session is not { Connected: true })\\\\n            {\\\\n                await TryConnectAsync(ct);\\\\n            }\\\\n        }\\\\n\\\\n        private async Task TryConnectAsync(CancellationToken ct)\\\\n        {\\\\n            await _sessionLock.WaitAsync(ct);\\\\n            try\\\\n            {\\\\n                DisposeReconnectHandler();\\\\n                await CloseSessionAsync();\\\\n                logger.LogInformation(\\\\\\\"Connecting to OPC UA server: {Endpoint}\\\\\\\", _settings.EndpointUrl);\\\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\\\n                Session.KeepAlive += OnSessionKeepAlive;\\\\n                logger.LogInformation(\\\\\\\"Connected to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(true);\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                // Cancellation is expected during shutdown\\\\n            }\\\\n            catch (Exception ex)\\\\n            {\\\\n                logger.LogError(ex, \\\\\\\"Failed to connect to OPC UA server\\\\\\\");\\\\n                NotifyConnectionChanged(false);\\\\n            }\\\\n            finally\\\\n            {\\\\n                _sessionLock.Release();\\\\n            }\\\\n        }\\\\n\\\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\\\n        {\\\\n            if (ShouldSkipKeepAlive(e))\\\\n            {\\\\n                return;\\\\n            }\\\\n            logger.LogWarning(\\\\\\\"Connection lost. Status: {Status}\\\\\\\", e.Status);\\\\n            NotifyConnectionChanged(false);\\\\n            StartReconnectIfNeeded();\\\\n        }\\\\n\\\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\\\n        {\\\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\\\n        }\\\\n\\\\n        private void StartReconnectIfNeeded()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                if (_reconnectHandler != null || Session == null)\\\\n                {\\\\n                    return;\\\\n                }\\\\n                logger.LogInformation(\\\\\\\"Reconnecting...\\\\\\\");\\\\n                _reconnectHandler = new SessionReconnectHandler();\\\\n                _reconnectHandler.BeginReconnect(\\\\n                    Session,\\\\n                    _settings.ReconnectIntervalMs,\\\\n                    OnReconnectComplete);\\\\n            }\\\\n        }\\\\n\\\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                UpdateSessionIfReconnected();\\\\n                DisposeReconnectHandler();\\\\n            }\\\\n        }\\\\n\\\\n        private void UpdateSessionIfReconnected()\\\\n        {\\\\n            if (_reconnectHandler?.Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\\\n            Session = (Session)_reconnectHandler.Session;\\\\n            logger.LogInformation(\\\\\\\"Reconnected to OPC UA server\\\\\\\");\\\\n            Session.KeepAlive += OnSessionKeepAlive;\\\\n            NotifyConnectionChanged(true);\\\\n        }\\\\n\\\\n        private void NotifyConnectionChanged(bool connected)\\\\n        {\\\\n            if (_lastConnectionState == connected)\\\\n            {\\\\n                return;\\\\n            }\\\\n            _lastConnectionState = connected;\\\\n            ConnectionChanged?.Invoke(this, connected);\\\\n        }\\\\n\\\\n        private async Task CancelConnectionAsync()\\\\n        {\\\\n            if (_cts == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            await _cts.CancelAsync();\\\\n            _cts.Dispose();\\\\n            _cts = null;\\\\n            DisposeReconnectHandler();\\\\n            await WaitConnectLoopAsync();\\\\n        }\\\\n\\\\n        private void DisposeReconnectHandler()\\\\n        {\\\\n            lock (_reconnectLock)\\\\n            {\\\\n                _reconnectHandler?.Dispose();\\\\n                _reconnectHandler = null;\\\\n            }\\\\n        }\\\\n\\\\n        private async Task CloseSessionAsync()\\\\n        {\\\\n            if (Session == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            Session.KeepAlive -= OnSessionKeepAlive;\\\\n            await Session.CloseAsync();\\\\n            Session.Dispose();\\\\n            Session = null;\\\\n        }\\\\n\\\\n        private async Task WaitConnectLoopAsync()\\\\n        {\\\\n            if (_connectLoopTask == null)\\\\n            {\\\\n                return;\\\\n            }\\\\n            try\\\\n            {\\\\n                await _connectLoopTask;\\\\n            }\\\\n            catch (OperationCanceledException)\\\\n            {\\\\n                logger.LogInformation(\\\\\\\"Connection loop canceled\\\\\\\");\\\\n            }\\\\n            _connectLoopTask = null;\\\\n        }\\\\n\\\\n        private async Task&amp;amp;lt;Session&amp;amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\\\n        {\\\\n            var session = await sessionFactory.CreateAsync(\\\\n                _appConfig,\\\\n                configEndpoint,\\\\n                updateBeforeConnect: false,\\\\n                sessionName: _settings.ApplicationName,\\\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\\\n                preferredLocales: null,\\\\n                ct).ConfigureAwait(false);\\\\n            return (Session)session;\\\\n        }\\\\n    }\\\\n}\\\\n\\\",\""
                },
                {
                  "lineNumber": 5275,
                  "content": "  \"query\": \"Where is ISessionFactory registered in dependency injection?\","
                },
                {
                  "lineNumber": 5686,
                  "content": "        \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        private int _currentDelayMs;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\","
                },
                {
                  "lineNumber": 5733,
                  "content": "            \"text\": \"        ISessionFactory sessionFactory)\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-25Z-проверка-стабильности-opc-ua-кода.md",
              "matches": [
                {
                  "lineNumber": 489,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 875,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        private int _currentDelayMs;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\n                    UpdateBackoffDelay(connected);\\n                    await Task.Delay(_currentDelayMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private void UpdateBackoffDelay(bool connected)\\n        {\\n            if (connected)\\n            {\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\n                return;\\n            }\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\n        }\\n\\n        private async Task&amp;lt;bool&amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return IsConnected;\\n            }\\n            await TryConnectAsync(ct);\\n            return IsConnected;\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-19Z-стабильность-и-утечки-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 72,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 408,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n\\n            var oldSession = Session;\\n            if (oldSession != null &amp;amp;&amp;amp; !ReferenceEquals(oldSession, newSession))\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-12Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-00Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-54Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 467,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-37Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-10Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 131,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 316,
                  "content": "3. **Line 286**: Missing &#96;ISessionFactory&#96; interface definition - I should check if this exists somewhere, but it's injected so it should be defined."
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-09Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 77,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-07Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 75,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-57Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 602,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-50Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 203,
                  "content": "  \"contents\": \"using Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (Session is not { Connected: true })\\n            {\\n                await TryConnectAsync(ct);\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-32Z-проверка-стабильности-кода-opcua.md",
              "matches": [
                {
                  "lineNumber": 658,
                  "content": "  \"contents\": \"using Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (Session is not { Connected: true })\\n            {\\n                await TryConnectAsync(ct);\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-06_15-27Z-выбор-библиотеки-для-opc-ua-с-plc.md",
              "matches": [
                {
                  "lineNumber": 1527,
                  "content": "| 'Session.Create(ApplicationConfiguration, ConfiguredEndpoint, bool, string, uint, IUserIdentity, IList&lt;string&gt;, CancellationToken)' is obsolete: 'Use ISessionFactory.CreateAsync' | 151:34-159:24 | DIAGNOSTIC_SEVERITY_WARNING |"
                },
                {
                  "lineNumber": 1617,
                  "content": "| 'Session.Create(ApplicationConfiguration, ConfiguredEndpoint, bool, string, uint, IUserIdentity, IList&lt;string&gt;, CancellationToken)' is obsolete: 'Use ISessionFactory.CreateAsync' | 151:34-159:24 | DIAGNOSTIC_SEVERITY_WARNING |"
                },
                {
                  "lineNumber": 1633,
                  "content": "Это предупреждение, не ошибка. Для простоты оставлю так - код будет работать. Если нужно убрать предупреждение, можно использовать ISessionFactory, но это усложнит код. Предупреждение можно проигнорировать для MVP."
                }
              ]
            }
          ],
          "totalLines": 68,
          "totalMatchedLines": 68
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Summarizing detailed stability review**

The code inspection of connection, subscription, and read/write services found possible cancellation token disposal and concurrency edge cases but no critical errors or leaks; next, I'll create a concise plan for delivering the stability assessment and minimal recommendations.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# Review OPC UA Services\n\n- Inspect &#96;Services/OpcUa/OpcUaConnectionService.cs&#96; for reconnection flow, session lifetime, locks, and disposal coverage.\n- Inspect &#96;Services/OpcUa/OpcUaReadWriteService.cs&#96; for read/write error handling, type safety, and session checks.\n- Inspect &#96;Services/OpcUa/OpcUaSubscriptionService.cs&#96; for subscription lifecycle, callback safety, reconnection resubscribe logic, and disposal to prevent leaks.\n- Summarize findings (critical issues, leak risks, behavior risks) and propose minimal, practical fixes suitable for a single-instance HMI.\n",
  "name": "opcua-stability-review",
  "overview": "Review OPC UA service classes for stability, critical errors, and leaks without adding complexity for single-user HMI use."
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///c%3A/Users/Alexander/.cursor/plans/opcua-stability-review_347db8c2.plan.md",
  "hasOpenedEditor": true
}
```
Result:

```json
{
  "rejected": {}
}
```
Status: **completed**


</details>
</tool-use>

---

