<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session dddb4318-2510-4498-beaf-93e886486940 (2025-12-08 15:44Z) -->

# Проверка стабильности opc ua кода (2025-12-08 15:44Z)

_**User (2025-12-08 13:30Z)**_

п@Services/OpcUa проверь стабилен ли код, нет ли критических ошибок? или утечек


Я ОДИН РАЗРАБОТЧИК И ЭТО НЕ МНОГОПОЛИЗОВАТЕЛЬСКОЕ ПРИЛОЖЕНИЕ А HMI. ТО ЕСТЬ ОНО БУДЕТ В ОДНОМ ЭКЗЕМПЛЯРЕ КОД НЕ НАДО ПЕРЕУСЛОЖНЯТЬ

---

_**Agent (model composer-1, mode Agent)**_



---


Проверяю код в `Services/OpcUa` на стабильность, критические ошибки и утечки.


---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "Services/OpcUa"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa",
    "childrenDirs": [
      {
        "absPath": "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid\\Services\\OpcUa\\Interface",
        "childrenFiles": [
          {
            "name": "IOpcUaConnectionService.cs"
          },
          {
            "name": "IOpcUaReadWriteService.cs"
          },
          {
            "name": "IOpcUaSubscriptionService.cs"
          }
        ],
        "childrenWereProcessed": true
      }
    ],
    "childrenFiles": [
      {
        "name": "OpcUaConnectionService.cs"
      },
      {
        "name": "OpcUaReadWriteService.cs"
      },
      {
        "name": "OpcUaSettings.cs"
      },
      {
        "name": "OpcUaSubscriptionService.cs"
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **7** results in **1** directory</summary>

Directory: **undefined** (7 files)

| File |
|------|
| `.\Services\OpcUa\OpcUaReadWriteService.cs` |
| `.\Services\OpcUa\OpcUaConnectionService.cs` |
| `.\Services\OpcUa\OpcUaSubscriptionService.cs` |
| `.\Services\OpcUa\Interface\IOpcUaReadWriteService.cs` |
| `.\Services\OpcUa\Interface\IOpcUaSubscriptionService.cs` |
| `.\Services\OpcUa\Interface\IOpcUaConnectionService.cs` |
| `.\Services\OpcUa\OpcUaSettings.cs` |

</details>
</tool-use>

---



---


Читаю основные файлы реализации для анализа:


---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaConnectionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaConnectionService.cs"
}
```
Result:

```json
{
  "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaConnectionService(\n        ILogger&lt;OpcUaConnectionService&gt; logger,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ISessionFactory sessionFactory)\n        : IOpcUaConnectionService\n    {\n        public bool IsConnected =&gt; Session?.Connected == true;\n        public Session? Session { get; private set; }\n        public event EventHandler&lt;bool&gt;? ConnectionChanged;\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\n        private readonly Lock _reconnectLock = new();\n        private SessionReconnectHandler? _reconnectHandler;\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\n        private CancellationTokenSource? _cts;\n        private Task? _connectLoopTask;\n        private bool _lastConnectionState;\n        private int _currentDelayMs;\n\n        public async Task StartAsync(CancellationToken ct = default)\n        {\n            if (_connectLoopTask is { IsCompleted: false })\n            {\n                return;\n            }\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            await InitializeApplicationConfigAsync();\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\n        }\n\n        public async Task StopAsync()\n        {\n            await CancelConnectionAsync();\n            DisposeReconnectHandler();\n            await _sessionLock.WaitAsync();\n            try\n            {\n                await CloseSessionAsync();\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n            NotifyConnectionChanged(false);\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            await StopAsync();\n            _sessionLock.Dispose();\n        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {\n            _appConfig = new Opc.Ua.ApplicationConfiguration\n            {\n                ApplicationName = _settings.ApplicationName,\n                ApplicationUri = $\"urn:{_settings.ApplicationName}\",\n                ApplicationType = ApplicationType.Client,\n                SecurityConfiguration = new SecurityConfiguration\n                {\n                    ApplicationCertificate = new CertificateIdentifier(),\n                    AutoAcceptUntrustedCertificates = true\n                },\n                ClientConfiguration = new ClientConfiguration\n                {\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\n                },\n                TransportConfigurations = [],\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\n            };\n            await _appConfig.ValidateAsync(ApplicationType.Client);\n        }\n\n        private async Task ConnectLoopAsync(CancellationToken ct)\n        {\n            _currentDelayMs = _settings.ReconnectIntervalMs;\n            try\n            {\n                while (!ct.IsCancellationRequested)\n                {\n                    var connected = await TryReconnectIfNeededAsync(ct);\n                    UpdateBackoffDelay(connected);\n                    await Task.Delay(_currentDelayMs, ct);\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Connection loop failed\");\n            }\n        }\n\n        private void UpdateBackoffDelay(bool connected)\n        {\n            if (connected)\n            {\n                _currentDelayMs = _settings.ReconnectIntervalMs;\n                return;\n            }\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\n        }\n\n        private async Task&lt;bool&gt; TryReconnectIfNeededAsync(CancellationToken ct)\n        {\n            if (IsReconnectingOrConnected())\n            {\n                return IsConnected;\n            }\n            await TryConnectAsync(ct);\n            return IsConnected;\n        }\n\n        private bool IsReconnectingOrConnected()\n        {\n            lock (_reconnectLock)\n            {\n                return _reconnectHandler != null || Session is { Connected: true };\n            }\n        }\n\n        private async Task TryConnectAsync(CancellationToken ct)\n        {\n            await _sessionLock.WaitAsync(ct);\n            try\n            {\n                DisposeReconnectHandler();\n                await CloseSessionAsync();\n                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\n                Session = await CreateSessionAsync(configEndpoint, ct);\n                Session.KeepAlive += OnSessionKeepAlive;\n                logger.LogInformation(\"Connected to OPC UA server\");\n                NotifyConnectionChanged(true);\n            }\n            catch (OperationCanceledException)\n            {\n                // Cancellation is expected during shutdown\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to connect to OPC UA server\");\n                NotifyConnectionChanged(false);\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n        }\n\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\n        {\n            if (ShouldSkipKeepAlive(e))\n            {\n                return;\n            }\n            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);\n            NotifyConnectionChanged(false);\n            StartReconnectIfNeeded();\n        }\n\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\n        {\n            return e.Status == null || ServiceResult.IsGood(e.Status);\n        }\n\n        private void StartReconnectIfNeeded()\n        {\n            lock (_reconnectLock)\n            {\n                if (_reconnectHandler != null || Session == null)\n                {\n                    return;\n                }\n                logger.LogInformation(\"Reconnecting...\");\n                _reconnectHandler = new SessionReconnectHandler();\n                _reconnectHandler.BeginReconnect(\n                    Session,\n                    _settings.ReconnectIntervalMs,\n                    OnReconnectComplete);\n            }\n        }\n\n        private void OnReconnectComplete(object? sender, EventArgs e)\n        {\n            lock (_reconnectLock)\n            {\n                UpdateSessionIfReconnected();\n                DisposeReconnectHandler();\n            }\n        }\n\n        private void UpdateSessionIfReconnected()\n        {\n            if (_reconnectHandler?.Session is not Session newSession)\n            {\n                return;\n            }\n            var oldSession = Session;\n            if (ReferenceEquals(oldSession, newSession))\n            {\n                logger.LogInformation(\"Reconnected to OPC UA server (same session)\");\n                NotifyConnectionChanged(true);\n                return;\n            }\n            if (oldSession != null)\n            {\n                oldSession.KeepAlive -= OnSessionKeepAlive;\n                oldSession.Dispose();\n            }\n\n            Session = newSession;\n            Session.KeepAlive += OnSessionKeepAlive;\n            logger.LogInformation(\"Reconnected to OPC UA server\");\n            NotifyConnectionChanged(true);\n        }\n\n        private void NotifyConnectionChanged(bool connected)\n        {\n            if (_lastConnectionState == connected)\n            {\n                return;\n            }\n            _lastConnectionState = connected;\n            ConnectionChanged?.Invoke(this, connected);\n        }\n\n        private async Task CancelConnectionAsync()\n        {\n            if (_cts == null)\n            {\n                return;\n            }\n            await _cts.CancelAsync();\n            _cts.Dispose();\n            _cts = null;\n            DisposeReconnectHandler();\n            await WaitConnectLoopAsync();\n        }\n\n        private void DisposeReconnectHandler()\n        {\n            lock (_reconnectLock)\n            {\n                _reconnectHandler?.Dispose();\n                _reconnectHandler = null;\n            }\n        }\n\n        private async Task CloseSessionAsync()\n        {\n            if (Session == null)\n            {\n                return;\n            }\n            Session.KeepAlive -= OnSessionKeepAlive;\n            try\n            {\n                await Session.CloseAsync();\n            }\n            catch (Exception ex)\n            {\n                logger.LogWarning(ex, \"Error closing session\");\n            }\n            Session.Dispose();\n            Session = null;\n        }\n\n        private async Task WaitConnectLoopAsync()\n        {\n            if (_connectLoopTask == null)\n            {\n                return;\n            }\n            try\n            {\n                await _connectLoopTask;\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            _connectLoopTask = null;\n        }\n\n        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\n        {\n            var session = await sessionFactory.CreateAsync(\n                _appConfig,\n                configEndpoint,\n                updateBeforeConnect: false,\n                sessionName: _settings.ApplicationName,\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\n                identity: new UserIdentity(new AnonymousIdentityToken()),\n                preferredLocales: null,\n                ct).ConfigureAwait(false);\n            return session switch\n            {\n                Session s =&gt; s,\n                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")\n            };\n        }\n    }\n}\n",
  "totalLinesInFile": 318
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaReadWriteService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaReadWriteService.cs"
}
```
Result:

```json
{
  "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Opc.Ua;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaReadWriteService(\n        IOpcUaConnectionService connection,\n        ILogger&lt;OpcUaReadWriteService&gt; logger)\n        : IOpcUaReadWriteService\n    {\n        public async Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default)\n        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot read node {NodeId}: Session not connected\", nodeId);\n                return default;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var value = await session.ReadValueAsync(node, ct);\n                return GetValueOrDefault&lt;T&gt;(nodeId, value);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to read node {NodeId}\", nodeId);\n                return default;\n            }\n        }\n\n        private T? GetValueOrDefault&lt;T&gt;(string nodeId, DataValue value)\n        {\n            if (!StatusCode.IsBad(value.StatusCode))\n            {\n                return value.Value is T typedValue\n                    ? typedValue\n                    : LogAndReturnDefault&lt;T&gt;(nodeId);\n            }\n            logger.LogWarning(\"Read node {NodeId} returned bad status {Status}\", nodeId, value.StatusCode);\n            return default;\n        }\n\n        private T? LogAndReturnDefault&lt;T&gt;(string nodeId)\n        {\n            logger.LogWarning(\"Cannot cast value from node {NodeId} to type {Type}\", nodeId, typeof(T).Name);\n            return default;\n        }\n\n        public async Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default)\n        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot write node {NodeId}: Session not connected\", nodeId);\n                return;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var writeValue = CreateWriteValue(node, value);\n                var request = new WriteValueCollection { writeValue };\n                var response = await session.WriteAsync(null, request, ct);\n                LogWriteResult(nodeId, response.Results);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to write node {NodeId}\", nodeId);\n            }\n        }\n\n        private void LogWriteResult(string nodeId, StatusCodeCollection? results)\n        {\n            if (results == null || results.Count == 0)\n            {\n                logger.LogWarning(\"Write node {NodeId}: empty results\", nodeId);\n                return;\n            }\n            LogBadStatusIfNeeded(nodeId, results[0]);\n        }\n\n        private void LogBadStatusIfNeeded(string nodeId, StatusCode status)\n        {\n            if (StatusCode.IsBad(status))\n            {\n                logger.LogWarning(\"Write node {NodeId} failed with status {Status}\", nodeId, status);\n            }\n        }\n\n        private WriteValue CreateWriteValue&lt;T&gt;(NodeId node, T value)\n        {\n            return new WriteValue\n            {\n                NodeId = node,\n                AttributeId = Attributes.Value,\n                Value = new DataValue(new Variant(value))\n            };\n        }\n    }\n}",
  "totalLinesInFile": 101
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaSubscriptionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "using System.Collections.Concurrent;\nusing Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSubscriptionService(\n        IOpcUaConnectionService connectionService,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ILogger&lt;OpcUaSubscriptionService&gt; logger) : IOpcUaSubscriptionService\n    {\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly ConcurrentDictionary&lt;string, Subscription&gt; _subscriptions = new();\n        private readonly ConcurrentDictionary&lt;string, Action&lt;object?&gt;&gt; _callbacks = new();\n        private readonly Lock _connectionEventsLock = new();\n        private readonly SemaphoreSlim _connectionChangeGate = new(1, 1);\n        private readonly CancellationTokenSource _disposeCts = new();\n        private bool _connectionEventsAttached;\n        private bool _disposed;\n\n        public OpcUaSubscriptionService(\n            IOpcUaConnectionService connectionService,\n            IOptions&lt;OpcUaSettings&gt; settings,\n            ILogger&lt;OpcUaSubscriptionService&gt; logger,\n            bool subscribeToConnection = true)\n            : this(connectionService, settings, logger)\n        {\n            if (subscribeToConnection)\n            {\n                connectionService.ConnectionChanged += OnConnectionChanged;\n                _connectionEventsAttached = true;\n            }\n        }\n\n        public async Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback)\n        {\n            ObjectDisposedException.ThrowIf(_disposed, this);\n            EnsureConnectionEventsAttached();\n\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                _callbacks[nodeId] = callback;\n                var session = connectionService.Session;\n                if (session is not { Connected: true })\n                {\n                    return;\n                }\n                await RemoveExistingSubscriptionAsync(nodeId);\n                await CreateAndAddSubscriptionAsync(nodeId, callback, session);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }\n        }\n\n        private async Task CreateAndAddSubscriptionAsync(string nodeId, Action&lt;object?&gt; callback, Session session)\n        {\n            try\n            {\n                var subscription = CreateSubscription(session);\n                var monitoredItem = CreateMonitoredItem(nodeId, callback, subscription);\n                await AddSubscriptionToSessionAsync(session, subscription, monitoredItem);\n                _subscriptions[nodeId] = subscription;\n                logger.LogInformation(\"Subscribed to node {NodeId}\", nodeId);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to subscribe to node {NodeId}\", nodeId);\n            }\n        }\n\n        public async Task UnsubscribeAsync(string nodeId)\n        {\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                _callbacks.TryRemove(nodeId, out _);\n                if (!_subscriptions.TryRemove(nodeId, out var subscription))\n                {\n                    return;\n                }\n                await RemoveSubscriptionSafelyAsync(nodeId, subscription);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }\n        }\n\n        private async Task RemoveSubscriptionSafelyAsync(string nodeId, Subscription subscription)\n        {\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(subscription);\n                subscription.Dispose();\n                logger.LogInformation(\"Unsubscribed from node {NodeId}\", nodeId);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to unsubscribe from node {NodeId}\", nodeId);\n            }\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            if (_disposed)\n            {\n                return;\n            }\n            _disposed = true;\n            logger.LogInformation(\"Disposing OpcUaSubscriptionService with {Count} active subscriptions\", _subscriptions.Count);\n            await _disposeCts.CancelAsync();\n            DetachConnectionEvents();\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                await DisposeAllSubscriptionsAsync();\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n                _connectionChangeGate.Dispose();\n                _disposeCts.Dispose();\n            }\n        }\n\n        private async Task DisposeAllSubscriptionsAsync(bool clearCallbacks = true)\n        {\n            foreach (var subscription in _subscriptions.Values.ToArray())\n            {\n                await SafeRemoveSubscriptionAsync(subscription);\n            }\n            _subscriptions.Clear();\n            if (clearCallbacks)\n            {\n                _callbacks.Clear();\n            }\n        }\n\n        private async Task SafeRemoveSubscriptionAsync(Subscription subscription)\n        {\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(subscription);\n                subscription.Dispose();\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error disposing subscription\");\n            }\n        }\n\n        private Subscription CreateSubscription(Session session)\n        {\n            return new Subscription(session.DefaultSubscription)\n            {\n                PublishingInterval = _settings.PublishingIntervalMs\n            };\n        }\n\n        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)\n        {\n            var monitoredItem = new MonitoredItem(subscription.DefaultItem)\n            {\n                StartNodeId = new NodeId(nodeId),\n                AttributeId = Attributes.Value\n            };\n            monitoredItem.Notification += (item, e) =&gt;\n            {\n                try\n                {\n                    if (e.NotificationValue is not MonitoredItemNotification notification)\n                    {\n                        return;\n                    }\n                    callback(notification.Value.Value);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);\n                }\n            };\n            return monitoredItem;\n        }\n\n        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)\n        {\n            subscription.AddItem(monitoredItem);\n            session.AddSubscription(subscription);\n            try\n            {\n                await subscription.CreateAsync();\n            }\n            catch\n            {\n                await session.RemoveSubscriptionAsync(subscription);\n                subscription.Dispose();\n                throw;\n            }\n        }\n\n        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)\n        {\n            if (subscription.Session is not { Connected: true })\n            {\n                return;\n            }\n            await subscription.DeleteAsync(true); // true = removes from session automatically\n        }\n\n        private async Task RemoveExistingSubscriptionAsync(string nodeId)\n        {\n            if (!_subscriptions.TryGetValue(nodeId, out var existing))\n            {\n                return;\n            }\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(existing);\n                existing.Dispose();\n                _subscriptions.TryRemove(nodeId, out _);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to remove existing subscription for node {NodeId}\", nodeId);\n            }\n        }\n\n        private void EnsureConnectionEventsAttached()\n        {\n            lock (_connectionEventsLock)\n            {\n                if (_connectionEventsAttached)\n                {\n                    return;\n                }\n                connectionService.ConnectionChanged += OnConnectionChanged;\n                _connectionEventsAttached = true;\n            }\n        }\n\n        private void DetachConnectionEvents()\n        {\n            lock (_connectionEventsLock)\n            {\n                if (!_connectionEventsAttached)\n                {\n                    return;\n                }\n                connectionService.ConnectionChanged -= OnConnectionChanged;\n                _connectionEventsAttached = false;\n            }\n        }\n\n        private void OnConnectionChanged(object? sender, bool connected)\n            =&gt; _ = OnConnectionChangedAsync(connected);\n\n        private async Task OnConnectionChangedAsync(bool connected)\n        {\n            if (_disposed)\n            {\n                return;\n            }\n\n            try\n            {\n                logger.LogDebug(\"Connection state changed: Connected={Connected}, ActiveSubscriptions={Count}\", connected, _callbacks.Count);\n                await HandleConnectionChangeSafelyAsync(connected);\n            }\n            catch (OperationCanceledException)\n            {\n                // Normal cancellation during dispose\n            }\n            catch (ObjectDisposedException)\n            {\n                // Service was disposed during event handling\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Unhandled error in connection change handler\");\n            }\n        }\n\n        private async Task HandleConnectionChangeSafelyAsync(bool connected)\n        {\n            await _connectionChangeGate.WaitAsync(_disposeCts.Token);\n            try\n            {\n                if (connected)\n                {\n                    await ResubscribeAllAsync();\n                }\n                else\n                {\n                    await DropAllSubscriptionsAsync();\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n                logger.LogDebug(\"Connection change handling aborted: service was disposed during operation\");\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error handling connection change. Connected={Connected}, SubscriptionCount={Count}\", connected, _subscriptions.Count);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }\n        }\n\n        private async Task ResubscribeAllAsync()\n        {\n            if (connectionService.Session is not { Connected: true } session)\n            {\n                return;\n            }\n            foreach (var kvp in _callbacks.ToArray())\n            {\n                await RemoveExistingSubscriptionAsync(kvp.Key);\n                await CreateAndAddSubscriptionAsync(kvp.Key, kvp.Value, session);\n            }\n        }\n\n        private async Task DropAllSubscriptionsAsync()\n        {\n            await DisposeAllSubscriptionsAsync(clearCallbacks: false);\n        }\n    }\n}",
  "totalLinesInFile": 335
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaSettings.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaSettings.cs"
}
```
Result:

```json
{
  "contents": "namespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSettings\n    {\n        public string EndpointUrl { get; set; } = \"opc.tcp://192.168.1.100:4840\";\n        public string ApplicationName { get; set; } = \"FinalTestHybrid\";\n        public int ReconnectIntervalMs { get; set; } = 5000;\n        public int SessionTimeoutMs { get; set; } = 60000;\n        public int PublishingIntervalMs { get; set; } = 1000;\n        public int OperationTimeoutMs { get; set; } = 15000;\n    }\n}",
  "totalLinesInFile": 12
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/Interface/IOpcUaConnectionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/Interface/IOpcUaConnectionService.cs"
}
```
Result:

```json
{
  "contents": "using Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaConnectionService : IAsyncDisposable\n    {\n        bool IsConnected { get; }\n        Session? Session { get; }\n        event EventHandler&lt;bool&gt;? ConnectionChanged;\n\n        Task StartAsync(CancellationToken ct = default);\n        Task StopAsync();\n    }\n}\n",
  "totalLinesInFile": 15
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/Interface/IOpcUaReadWriteService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/Interface/IOpcUaReadWriteService.cs"
}
```
Result:

```json
{
  "contents": "namespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaReadWriteService\n    {\n        Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default);\n        Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default);\n    }\n}\n",
  "totalLinesInFile": 9
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/Interface/IOpcUaSubscriptionService.cs",
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/Interface/IOpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "namespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaSubscriptionService : IAsyncDisposable\n    {\n        Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback);\n        Task UnsubscribeAsync(string nodeId);\n    }\n}\n",
  "totalLinesInFile": 9
}
```
Status: **completed**


</details>
</tool-use>

---



---


Проверяю использование этих сервисов и возможные проблемы с зависимостями:


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How is ISessionFactory implemented and used?",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 299
          },
          "endPosition": {
            "line": 317
          }
        },
        "contents": "        {\n            var session = await sessionFactory.CreateAsync(\n                _appConfig,\n                configEndpoint,\n                updateBeforeConnect: false,\n                sessionName: _settings.ApplicationName,\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\n                identity: new UserIdentity(new AnonymousIdentityToken()),\n                preferredLocales: null,\n                ct).ConfigureAwait(false);\n            return session switch\n            {\n                Session s =&gt; s,\n                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")\n            };\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 300
          },
          {
            "text": "            var session = await sessionFactory.CreateAsync(",
            "lineNumber": 301
          },
          {
            "text": "                _appConfig,",
            "lineNumber": 302
          },
          {
            "text": "                configEndpoint,",
            "lineNumber": 303
          },
          {
            "text": "                updateBeforeConnect: false,",
            "lineNumber": 304
          },
          {
            "text": "                sessionName: _settings.ApplicationName,",
            "lineNumber": 305
          },
          {
            "text": "                sessionTimeout: (uint)_settings.SessionTimeoutMs,",
            "lineNumber": 306
          },
          {
            "text": "                identity: new UserIdentity(new AnonymousIdentityToken()),",
            "lineNumber": 307
          },
          {
            "text": "                preferredLocales: null,",
            "lineNumber": 308
          },
          {
            "text": "                ct).ConfigureAwait(false);",
            "lineNumber": 309
          },
          {
            "text": "            return session switch",
            "lineNumber": 310
          },
          {
            "text": "            {",
            "lineNumber": 311
          },
          {
            "text": "                Session s =&gt; s,",
            "lineNumber": 312
          },
          {
            "text": "                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")",
            "lineNumber": 313
          },
          {
            "text": "            };",
            "lineNumber": 314
          },
          {
            "text": "        }",
            "lineNumber": 315
          },
          {
            "text": "    }",
            "lineNumber": 316
          },
          {
            "text": "}",
            "lineNumber": 317
          }
        ]
      },
      "score": 0.37066650390625
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 63
          }
        },
        "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaConnectionService(\n        ILogger&lt;OpcUaConnectionService&gt; logger,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ISessionFactory sessionFactory)\n        : IOpcUaConnectionService\n    {\n        public bool IsConnected =&gt; Session?.Connected == true;\n        public Session? Session { get; private set; }\n        public event EventHandler&lt;bool&gt;? ConnectionChanged;\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\n        private readonly Lock _reconnectLock = new();\n        private SessionReconnectHandler? _reconnectHandler;\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\n        private CancellationTokenSource? _cts;\n        private Task? _connectLoopTask;\n        private bool _lastConnectionState;\n        private int _currentDelayMs;\n\n        public async Task StartAsync(CancellationToken ct = default)\n        {\n            if (_connectLoopTask is { IsCompleted: false })\n            {\n                return;\n            }\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            await InitializeApplicationConfigAsync();\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\n        }\n\n        public async Task StopAsync()\n        {\n            await CancelConnectionAsync();\n            DisposeReconnectHandler();\n            await _sessionLock.WaitAsync();\n            try\n            {\n                await CloseSessionAsync();\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n            NotifyConnectionChanged(false);\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            await StopAsync();\n            _sessionLock.Dispose();\n        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {\n            _appConfig = new Opc.Ua.ApplicationConfiguration",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 2
          },
          {
            "text": "using Microsoft.Extensions.Options;",
            "lineNumber": 3
          },
          {
            "text": "using Opc.Ua;",
            "lineNumber": 4
          },
          {
            "text": "using Opc.Ua.Client;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 7
          },
          {
            "text": "{",
            "lineNumber": 8
          },
          {
            "text": "    public class OpcUaConnectionService(",
            "lineNumber": 9
          },
          {
            "text": "        ILogger&lt;OpcUaConnectionService&gt; logger,",
            "lineNumber": 10
          },
          {
            "text": "        IOptions&lt;OpcUaSettings&gt; settings,",
            "lineNumber": 11
          },
          {
            "text": "        ISessionFactory sessionFactory)",
            "lineNumber": 12
          },
          {
            "text": "        : IOpcUaConnectionService",
            "lineNumber": 13
          },
          {
            "text": "    {",
            "lineNumber": 14
          },
          {
            "text": "        public bool IsConnected =&gt; Session?.Connected == true;",
            "lineNumber": 15
          },
          {
            "text": "        public Session? Session { get; private set; }",
            "lineNumber": 16
          },
          {
            "text": "        public event EventHandler&lt;bool&gt;? ConnectionChanged;",
            "lineNumber": 17
          },
          {
            "text": "        private readonly OpcUaSettings _settings = settings.Value;",
            "lineNumber": 18
          },
          {
            "text": "        private readonly SemaphoreSlim _sessionLock = new(1, 1);",
            "lineNumber": 19
          },
          {
            "text": "        private readonly Lock _reconnectLock = new();",
            "lineNumber": 20
          },
          {
            "text": "        private SessionReconnectHandler? _reconnectHandler;",
            "lineNumber": 21
          },
          {
            "text": "        private Opc.Ua.ApplicationConfiguration? _appConfig;",
            "lineNumber": 22
          },
          {
            "text": "        private CancellationTokenSource? _cts;",
            "lineNumber": 23
          },
          {
            "text": "        private Task? _connectLoopTask;",
            "lineNumber": 24
          },
          {
            "text": "        private bool _lastConnectionState;",
            "lineNumber": 25
          },
          {
            "text": "        private int _currentDelayMs;",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "        public async Task StartAsync(CancellationToken ct = default)",
            "lineNumber": 28
          },
          {
            "text": "        {",
            "lineNumber": 29
          },
          {
            "text": "            if (_connectLoopTask is { IsCompleted: false })",
            "lineNumber": 30
          },
          {
            "text": "            {",
            "lineNumber": 31
          },
          {
            "text": "                return;",
            "lineNumber": 32
          },
          {
            "text": "            }",
            "lineNumber": 33
          },
          {
            "text": "            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);",
            "lineNumber": 34
          },
          {
            "text": "            await InitializeApplicationConfigAsync();",
            "lineNumber": 35
          },
          {
            "text": "            _connectLoopTask = ConnectLoopAsync(_cts.Token);",
            "lineNumber": 36
          },
          {
            "text": "        }",
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "        public async Task StopAsync()",
            "lineNumber": 39
          },
          {
            "text": "        {",
            "lineNumber": 40
          },
          {
            "text": "            await CancelConnectionAsync();",
            "lineNumber": 41
          },
          {
            "text": "            DisposeReconnectHandler();",
            "lineNumber": 42
          },
          {
            "text": "            await _sessionLock.WaitAsync();",
            "lineNumber": 43
          },
          {
            "text": "            try",
            "lineNumber": 44
          },
          {
            "text": "            {",
            "lineNumber": 45
          },
          {
            "text": "                await CloseSessionAsync();",
            "lineNumber": 46
          },
          {
            "text": "            }",
            "lineNumber": 47
          },
          {
            "text": "            finally",
            "lineNumber": 48
          },
          {
            "text": "            {",
            "lineNumber": 49
          },
          {
            "text": "                _sessionLock.Release();",
            "lineNumber": 50
          },
          {
            "text": "            }",
            "lineNumber": 51
          },
          {
            "text": "            NotifyConnectionChanged(false);",
            "lineNumber": 52
          },
          {
            "text": "        }",
            "lineNumber": 53
          },
          {
            "lineNumber": 54
          },
          {
            "text": "        public async ValueTask DisposeAsync()",
            "lineNumber": 55
          },
          {
            "text": "        {",
            "lineNumber": 56
          },
          {
            "text": "            await StopAsync();",
            "lineNumber": 57
          },
          {
            "text": "            _sessionLock.Dispose();",
            "lineNumber": 58
          },
          {
            "text": "        }",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "        private async Task InitializeApplicationConfigAsync()",
            "lineNumber": 61
          },
          {
            "text": "        {",
            "lineNumber": 62
          },
          {
            "text": "            _appConfig = new Opc.Ua.ApplicationConfiguration",
            "lineNumber": 63
          }
        ]
      },
      "score": 0.35484930872917175
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 134
          },
          "endPosition": {
            "line": 182
          }
        },
        "contents": "        {\n            await _sessionLock.WaitAsync(ct);\n            try\n            {\n                DisposeReconnectHandler();\n                await CloseSessionAsync();\n                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\n                Session = await CreateSessionAsync(configEndpoint, ct);\n                Session.KeepAlive += OnSessionKeepAlive;\n                logger.LogInformation(\"Connected to OPC UA server\");\n                NotifyConnectionChanged(true);\n            }\n            catch (OperationCanceledException)\n            {\n                // Cancellation is expected during shutdown\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to connect to OPC UA server\");\n                NotifyConnectionChanged(false);\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n        }\n\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\n        {\n            if (ShouldSkipKeepAlive(e))\n            {\n                return;\n            }\n            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);\n            NotifyConnectionChanged(false);\n            StartReconnectIfNeeded();\n        }\n\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\n        {\n            return e.Status == null || ServiceResult.IsGood(e.Status);\n        }\n\n        private void StartReconnectIfNeeded()\n        {\n            lock (_reconnectLock)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 135
          },
          {
            "text": "            await _sessionLock.WaitAsync(ct);",
            "lineNumber": 136
          },
          {
            "text": "            try",
            "lineNumber": 137
          },
          {
            "text": "            {",
            "lineNumber": 138
          },
          {
            "text": "                DisposeReconnectHandler();",
            "lineNumber": 139
          },
          {
            "text": "                await CloseSessionAsync();",
            "lineNumber": 140
          },
          {
            "text": "                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);",
            "lineNumber": 141
          },
          {
            "text": "                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);",
            "lineNumber": 142
          },
          {
            "text": "                var configEndpoint = new ConfiguredEndpoint(null, endpoint);",
            "lineNumber": 143
          },
          {
            "text": "                Session = await CreateSessionAsync(configEndpoint, ct);",
            "lineNumber": 144
          },
          {
            "text": "                Session.KeepAlive += OnSessionKeepAlive;",
            "lineNumber": 145
          },
          {
            "text": "                logger.LogInformation(\"Connected to OPC UA server\");",
            "lineNumber": 146
          },
          {
            "text": "                NotifyConnectionChanged(true);",
            "lineNumber": 147
          },
          {
            "text": "            }",
            "lineNumber": 148
          },
          {
            "text": "            catch (OperationCanceledException)",
            "lineNumber": 149
          },
          {
            "text": "            {",
            "lineNumber": 150
          },
          {
            "text": "                // Cancellation is expected during shutdown",
            "lineNumber": 151
          },
          {
            "text": "            }",
            "lineNumber": 152
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 153
          },
          {
            "text": "            {",
            "lineNumber": 154
          },
          {
            "text": "                logger.LogError(ex, \"Failed to connect to OPC UA server\");",
            "lineNumber": 155
          },
          {
            "text": "                NotifyConnectionChanged(false);",
            "lineNumber": 156
          },
          {
            "text": "            }",
            "lineNumber": 157
          },
          {
            "text": "            finally",
            "lineNumber": 158
          },
          {
            "text": "            {",
            "lineNumber": 159
          },
          {
            "text": "                _sessionLock.Release();",
            "lineNumber": 160
          },
          {
            "text": "            }",
            "lineNumber": 161
          },
          {
            "text": "        }",
            "lineNumber": 162
          },
          {
            "lineNumber": 163
          },
          {
            "text": "        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)",
            "lineNumber": 164
          },
          {
            "text": "        {",
            "lineNumber": 165
          },
          {
            "text": "            if (ShouldSkipKeepAlive(e))",
            "lineNumber": 166
          },
          {
            "text": "            {",
            "lineNumber": 167
          },
          {
            "text": "                return;",
            "lineNumber": 168
          },
          {
            "text": "            }",
            "lineNumber": 169
          },
          {
            "text": "            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);",
            "lineNumber": 170
          },
          {
            "text": "            NotifyConnectionChanged(false);",
            "lineNumber": 171
          },
          {
            "text": "            StartReconnectIfNeeded();",
            "lineNumber": 172
          },
          {
            "text": "        }",
            "lineNumber": 173
          },
          {
            "lineNumber": 174
          },
          {
            "text": "        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)",
            "lineNumber": 175
          },
          {
            "text": "        {",
            "lineNumber": 176
          },
          {
            "text": "            return e.Status == null || ServiceResult.IsGood(e.Status);",
            "lineNumber": 177
          },
          {
            "text": "        }",
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "        private void StartReconnectIfNeeded()",
            "lineNumber": 180
          },
          {
            "text": "        {",
            "lineNumber": 181
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 182
          }
        ]
      },
      "score": 0.2421635389328003
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Form1.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 44
          }
        },
        "contents": "using Final_Test_Hybrid.Services.IO;\nusing Final_Test_Hybrid.Services.OpcUa;\nusing Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Final_Test_Hybrid.Services.Sequence;\nusing Final_Test_Hybrid.Services.Settings.IO;\nusing Final_Test_Hybrid.Services.UI;\nusing Microsoft.AspNetCore.Components.WebView.WindowsForms;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Radzen;\n\nnamespace Final_Test_Hybrid\n{\n    public partial class Form1 : Form\n    {\n        private IConfiguration? _config;\n        \n        public Form1()\n        {\n            InitializeComponent();\n            HandleException();\n            var services = new ServiceCollection();\n            SettingConfiguration(services);\n            SettingDevTools(services);\n            services.AddScoped&lt;IFilePickerService, WinFormsFilePickerService&gt;();\n            services.AddScoped&lt;ISequenceExcelService, SequenceExcelService&gt;();\n            services.AddScoped&lt;INotificationService, NotificationServiceWrapper&gt;();\n            services.AddScoped&lt;TestSequenceService&gt;();\n            services.Configure&lt;OpcUaSettings&gt;(_config!.GetSection(\"OpcUa\"));\n            services.AddSingleton&lt;IOpcUaConnectionService, OpcUaConnectionService&gt;();\n            services.AddSingleton&lt;IOpcUaReadWriteService, OpcUaReadWriteService&gt;();\n            services.AddSingleton&lt;IOpcUaSubscriptionService, OpcUaSubscriptionService&gt;();\n            services.AddBlazorWebViewDeveloperTools();\n            services.AddWindowsFormsBlazorWebView();\n            services.AddRadzenComponents();\n            blazorWebView1.HostPage = \"wwwroot\\\\index.html\";\n            var serviceProvider = services.BuildServiceProvider();\n            blazorWebView1.Services = serviceProvider;\n            \n            // Автозапуск OPC UA подключения\n            var connectionService = serviceProvider.GetRequiredService&lt;IOpcUaConnectionService&gt;();\n            _ = connectionService.StartAsync();\n            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Services.IO;",
            "lineNumber": 1
          },
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa;",
            "lineNumber": 2
          },
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 3
          },
          {
            "text": "using Final_Test_Hybrid.Services.Sequence;",
            "lineNumber": 4
          },
          {
            "text": "using Final_Test_Hybrid.Services.Settings.IO;",
            "lineNumber": 5
          },
          {
            "text": "using Final_Test_Hybrid.Services.UI;",
            "lineNumber": 6
          },
          {
            "text": "using Microsoft.AspNetCore.Components.WebView.WindowsForms;",
            "lineNumber": 7
          },
          {
            "text": "using Microsoft.Extensions.Configuration;",
            "lineNumber": 8
          },
          {
            "text": "using Microsoft.Extensions.DependencyInjection;",
            "lineNumber": 9
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 10
          },
          {
            "text": "using Radzen;",
            "lineNumber": 11
          },
          {
            "lineNumber": 12
          },
          {
            "text": "namespace Final_Test_Hybrid",
            "lineNumber": 13
          },
          {
            "text": "{",
            "lineNumber": 14
          },
          {
            "text": "    public partial class Form1 : Form",
            "lineNumber": 15
          },
          {
            "text": "    {",
            "lineNumber": 16
          },
          {
            "text": "        private IConfiguration? _config;",
            "lineNumber": 17
          },
          {
            "text": "        ",
            "lineNumber": 18
          },
          {
            "text": "        public Form1()",
            "lineNumber": 19
          },
          {
            "text": "        {",
            "lineNumber": 20
          },
          {
            "text": "            InitializeComponent();",
            "lineNumber": 21
          },
          {
            "text": "            HandleException();",
            "lineNumber": 22
          },
          {
            "text": "            var services = new ServiceCollection();",
            "lineNumber": 23
          },
          {
            "text": "            SettingConfiguration(services);",
            "lineNumber": 24
          },
          {
            "text": "            SettingDevTools(services);",
            "lineNumber": 25
          },
          {
            "text": "            services.AddScoped&lt;IFilePickerService, WinFormsFilePickerService&gt;();",
            "lineNumber": 26
          },
          {
            "text": "            services.AddScoped&lt;ISequenceExcelService, SequenceExcelService&gt;();",
            "lineNumber": 27
          },
          {
            "text": "            services.AddScoped&lt;INotificationService, NotificationServiceWrapper&gt;();",
            "lineNumber": 28
          },
          {
            "text": "            services.AddScoped&lt;TestSequenceService&gt;();",
            "lineNumber": 29
          },
          {
            "text": "            services.Configure&lt;OpcUaSettings&gt;(_config!.GetSection(\"OpcUa\"));",
            "lineNumber": 30
          },
          {
            "text": "            services.AddSingleton&lt;IOpcUaConnectionService, OpcUaConnectionService&gt;();",
            "lineNumber": 31
          },
          {
            "text": "            services.AddSingleton&lt;IOpcUaReadWriteService, OpcUaReadWriteService&gt;();",
            "lineNumber": 32
          },
          {
            "text": "            services.AddSingleton&lt;IOpcUaSubscriptionService, OpcUaSubscriptionService&gt;();",
            "lineNumber": 33
          },
          {
            "text": "            services.AddBlazorWebViewDeveloperTools();",
            "lineNumber": 34
          },
          {
            "text": "            services.AddWindowsFormsBlazorWebView();",
            "lineNumber": 35
          },
          {
            "text": "            services.AddRadzenComponents();",
            "lineNumber": 36
          },
          {
            "text": "            blazorWebView1.HostPage = \"wwwroot\\\\index.html\";",
            "lineNumber": 37
          },
          {
            "text": "            var serviceProvider = services.BuildServiceProvider();",
            "lineNumber": 38
          },
          {
            "text": "            blazorWebView1.Services = serviceProvider;",
            "lineNumber": 39
          },
          {
            "text": "            ",
            "lineNumber": 40
          },
          {
            "text": "            // Автозапуск OPC UA подключения",
            "lineNumber": 41
          },
          {
            "text": "            var connectionService = serviceProvider.GetRequiredService&lt;IOpcUaConnectionService&gt;();",
            "lineNumber": 42
          },
          {
            "text": "            _ = connectionService.StartAsync();",
            "lineNumber": 43
          },
          {
            "text": "            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.2413439005613327
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Form1.cs",
        "range": {
          "startPosition": {
            "line": 42
          },
          "endPosition": {
            "line": 88
          }
        },
        "contents": "            _ = connectionService.StartAsync();\n            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");\n            blazorWebView1.RootComponents.Add&lt;MyComponent&gt;(\"#app\");\n        }\n\n        private static void HandleException()\n        {\n            AppDomain.CurrentDomain.UnhandledException += (_, error) =&gt;\n            {\n                #if DEBUG\n                    MessageBox.Show(text: error.ExceptionObject.ToString(), caption: @\"������\");\n                #else\n                    MessageBox.Show(text: \"An error has occurred.\", caption: \"Error\");\n                #endif\n            };\n        }\n        \n        private void SettingConfiguration(ServiceCollection services)\n        {\n            _config = new ConfigurationBuilder()\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .Build();\n            services.AddSingleton&lt;IConfiguration&gt;(_config);\n        }\n        \n        private void SettingDevTools(ServiceCollection services)\n        {\n#if DEBUG\n            services.AddBlazorWebViewDeveloperTools();\n            services.AddLogging(logging =&gt;\n            {\n                logging.SetMinimumLevel(LogLevel.Information);\n                logging.AddDebug();\n                logging.AddConsole();\n                logging.AddFile(_config?.GetSection(\"Logging\")!);\n            });\n#else\n                services.AddLogging(logging =&gt;\n                {\n                    logging.SetMinimumLevel(LogLevel.Error);\n                    logging.AddFile(_config?.GetSection(\"Logging\"));\n                });\n#endif\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "            _ = connectionService.StartAsync();",
            "lineNumber": 43
          },
          {
            "text": "            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");",
            "lineNumber": 44
          },
          {
            "text": "            blazorWebView1.RootComponents.Add&lt;MyComponent&gt;(\"#app\");",
            "lineNumber": 45
          },
          {
            "text": "        }",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "        private static void HandleException()",
            "lineNumber": 48
          },
          {
            "text": "        {",
            "lineNumber": 49
          },
          {
            "text": "            AppDomain.CurrentDomain.UnhandledException += (_, error) =&gt;",
            "lineNumber": 50
          },
          {
            "text": "            {",
            "lineNumber": 51
          },
          {
            "text": "                #if DEBUG",
            "lineNumber": 52
          },
          {
            "text": "                    MessageBox.Show(text: error.ExceptionObject.ToString(), caption: @\"������\");",
            "lineNumber": 53
          },
          {
            "text": "                #else",
            "lineNumber": 54
          },
          {
            "text": "                    MessageBox.Show(text: \"An error has occurred.\", caption: \"Error\");",
            "lineNumber": 55
          },
          {
            "text": "                #endif",
            "lineNumber": 56
          },
          {
            "text": "            };",
            "lineNumber": 57
          },
          {
            "text": "        }",
            "lineNumber": 58
          },
          {
            "text": "        ",
            "lineNumber": 59
          },
          {
            "text": "        private void SettingConfiguration(ServiceCollection services)",
            "lineNumber": 60
          },
          {
            "text": "        {",
            "lineNumber": 61
          },
          {
            "text": "            _config = new ConfigurationBuilder()",
            "lineNumber": 62
          },
          {
            "text": "                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)",
            "lineNumber": 63
          },
          {
            "text": "                .Build();",
            "lineNumber": 64
          },
          {
            "text": "            services.AddSingleton&lt;IConfiguration&gt;(_config);",
            "lineNumber": 65
          },
          {
            "text": "        }",
            "lineNumber": 66
          },
          {
            "text": "        ",
            "lineNumber": 67
          },
          {
            "text": "        private void SettingDevTools(ServiceCollection services)",
            "lineNumber": 68
          },
          {
            "text": "        {",
            "lineNumber": 69
          },
          {
            "text": "#if DEBUG",
            "lineNumber": 70
          },
          {
            "text": "            services.AddBlazorWebViewDeveloperTools();",
            "lineNumber": 71
          },
          {
            "text": "            services.AddLogging(logging =&gt;",
            "lineNumber": 72
          },
          {
            "text": "            {",
            "lineNumber": 73
          },
          {
            "text": "                logging.SetMinimumLevel(LogLevel.Information);",
            "lineNumber": 74
          },
          {
            "text": "                logging.AddDebug();",
            "lineNumber": 75
          },
          {
            "text": "                logging.AddConsole();",
            "lineNumber": 76
          },
          {
            "text": "                logging.AddFile(_config?.GetSection(\"Logging\")!);",
            "lineNumber": 77
          },
          {
            "text": "            });",
            "lineNumber": 78
          },
          {
            "text": "#else",
            "lineNumber": 79
          },
          {
            "text": "                services.AddLogging(logging =&gt;",
            "lineNumber": 80
          },
          {
            "text": "                {",
            "lineNumber": 81
          },
          {
            "text": "                    logging.SetMinimumLevel(LogLevel.Error);",
            "lineNumber": 82
          },
          {
            "text": "                    logging.AddFile(_config?.GetSection(\"Logging\"));",
            "lineNumber": 83
          },
          {
            "text": "                });",
            "lineNumber": 84
          },
          {
            "text": "#endif",
            "lineNumber": 85
          },
          {
            "text": "        }",
            "lineNumber": 86
          },
          {
            "text": "    }",
            "lineNumber": 87
          },
          {
            "text": "}",
            "lineNumber": 88
          }
        ]
      },
      "score": 0.20163209736347198
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\Interface\\IOpcUaConnectionService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 14
          }
        },
        "contents": "using Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaConnectionService : IAsyncDisposable\n    {\n        bool IsConnected { get; }\n        Session? Session { get; }\n        event EventHandler&lt;bool&gt;? ConnectionChanged;\n\n        Task StartAsync(CancellationToken ct = default);\n        Task StopAsync();\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Opc.Ua.Client;",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa.Interface",
            "lineNumber": 3
          },
          {
            "text": "{",
            "lineNumber": 4
          },
          {
            "text": "    public interface IOpcUaConnectionService : IAsyncDisposable",
            "lineNumber": 5
          },
          {
            "text": "    {",
            "lineNumber": 6
          },
          {
            "text": "        bool IsConnected { get; }",
            "lineNumber": 7
          },
          {
            "text": "        Session? Session { get; }",
            "lineNumber": 8
          },
          {
            "text": "        event EventHandler&lt;bool&gt;? ConnectionChanged;",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "        Task StartAsync(CancellationToken ct = default);",
            "lineNumber": 11
          },
          {
            "text": "        Task StopAsync();",
            "lineNumber": 12
          },
          {
            "text": "    }",
            "lineNumber": 13
          },
          {
            "text": "}",
            "lineNumber": 14
          }
        ]
      },
      "score": 0.18971014022827148
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 241
          },
          "endPosition": {
            "line": 301,
            "column": 16
          }
        },
        "contents": "        {\n            if (_cts == null)\n            {\n                return;\n            }\n            await _cts.CancelAsync();\n            _cts.Dispose();\n            _cts = null;\n            DisposeReconnectHandler();\n            await WaitConnectLoopAsync();\n        }\n\n        private void DisposeReconnectHandler()\n        {\n            lock (_reconnectLock)\n            {\n                _reconnectHandler?.Dispose();\n                _reconnectHandler = null;\n            }\n        }\n\n        private async Task CloseSessionAsync()\n        {\n            if (Session == null)\n            {\n                return;\n            }\n            Session.KeepAlive -= OnSessionKeepAlive;\n            try\n            {\n                await Session.CloseAsync();\n            }\n            catch (Exception ex)\n            {\n                logger.LogWarning(ex, \"Error closing session\");\n            }\n            Session.Dispose();\n            Session = null;\n        }\n\n        private async Task WaitConnectLoopAsync()\n        {\n            if (_connectLoopTask == null)\n            {\n                return;\n            }\n            try\n            {\n                await _connectLoopTask;\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            _connectLoopTask = null;\n        }\n\n        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\n        {\n            var session = await sessionFactory.CreateAsync(\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 242
          },
          {
            "text": "            if (_cts == null)",
            "lineNumber": 243
          },
          {
            "text": "            {",
            "lineNumber": 244
          },
          {
            "text": "                return;",
            "lineNumber": 245
          },
          {
            "text": "            }",
            "lineNumber": 246
          },
          {
            "text": "            await _cts.CancelAsync();",
            "lineNumber": 247
          },
          {
            "text": "            _cts.Dispose();",
            "lineNumber": 248
          },
          {
            "text": "            _cts = null;",
            "lineNumber": 249
          },
          {
            "text": "            DisposeReconnectHandler();",
            "lineNumber": 250
          },
          {
            "text": "            await WaitConnectLoopAsync();",
            "lineNumber": 251
          },
          {
            "text": "        }",
            "lineNumber": 252
          },
          {
            "lineNumber": 253
          },
          {
            "text": "        private void DisposeReconnectHandler()",
            "lineNumber": 254
          },
          {
            "text": "        {",
            "lineNumber": 255
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 256
          },
          {
            "text": "            {",
            "lineNumber": 257
          },
          {
            "text": "                _reconnectHandler?.Dispose();",
            "lineNumber": 258
          },
          {
            "text": "                _reconnectHandler = null;",
            "lineNumber": 259
          },
          {
            "text": "            }",
            "lineNumber": 260
          },
          {
            "text": "        }",
            "lineNumber": 261
          },
          {
            "lineNumber": 262
          },
          {
            "text": "        private async Task CloseSessionAsync()",
            "lineNumber": 263
          },
          {
            "text": "        {",
            "lineNumber": 264
          },
          {
            "text": "            if (Session == null)",
            "lineNumber": 265
          },
          {
            "text": "            {",
            "lineNumber": 266
          },
          {
            "text": "                return;",
            "lineNumber": 267
          },
          {
            "text": "            }",
            "lineNumber": 268
          },
          {
            "text": "            Session.KeepAlive -= OnSessionKeepAlive;",
            "lineNumber": 269
          },
          {
            "text": "            try",
            "lineNumber": 270
          },
          {
            "text": "            {",
            "lineNumber": 271
          },
          {
            "text": "                await Session.CloseAsync();",
            "lineNumber": 272
          },
          {
            "text": "            }",
            "lineNumber": 273
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 274
          },
          {
            "text": "            {",
            "lineNumber": 275
          },
          {
            "text": "                logger.LogWarning(ex, \"Error closing session\");",
            "lineNumber": 276
          },
          {
            "text": "            }",
            "lineNumber": 277
          },
          {
            "text": "            Session.Dispose();",
            "lineNumber": 278
          },
          {
            "text": "            Session = null;",
            "lineNumber": 279
          },
          {
            "text": "        }",
            "lineNumber": 280
          },
          {
            "lineNumber": 281
          },
          {
            "text": "        private async Task WaitConnectLoopAsync()",
            "lineNumber": 282
          },
          {
            "text": "        {",
            "lineNumber": 283
          },
          {
            "text": "            if (_connectLoopTask == null)",
            "lineNumber": 284
          },
          {
            "text": "            {",
            "lineNumber": 285
          },
          {
            "text": "                return;",
            "lineNumber": 286
          },
          {
            "text": "            }",
            "lineNumber": 287
          },
          {
            "text": "            try",
            "lineNumber": 288
          },
          {
            "text": "            {",
            "lineNumber": 289
          },
          {
            "text": "                await _connectLoopTask;",
            "lineNumber": 290
          },
          {
            "text": "            }",
            "lineNumber": 291
          },
          {
            "text": "            catch (OperationCanceledException)",
            "lineNumber": 292
          },
          {
            "text": "            {",
            "lineNumber": 293
          },
          {
            "text": "                logger.LogInformation(\"Connection loop canceled\");",
            "lineNumber": 294
          },
          {
            "text": "            }",
            "lineNumber": 295
          },
          {
            "text": "            _connectLoopTask = null;",
            "lineNumber": 296
          },
          {
            "text": "        }",
            "lineNumber": 297
          },
          {
            "lineNumber": 298
          },
          {
            "text": "        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)",
            "lineNumber": 299
          },
          {
            "text": "        {",
            "lineNumber": 300
          },
          {
            "text": "            var session = await sessionFactory.CreateAsync(",
            "lineNumber": 301
          },
          {
            "text": "                ",
            "lineNumber": 302
          }
        ]
      },
      "score": 0.18966810405254364
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaReadWriteService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 53
          }
        },
        "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Opc.Ua;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaReadWriteService(\n        IOpcUaConnectionService connection,\n        ILogger&lt;OpcUaReadWriteService&gt; logger)\n        : IOpcUaReadWriteService\n    {\n        public async Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default)\n        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot read node {NodeId}: Session not connected\", nodeId);\n                return default;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var value = await session.ReadValueAsync(node, ct);\n                return GetValueOrDefault&lt;T&gt;(nodeId, value);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to read node {NodeId}\", nodeId);\n                return default;\n            }\n        }\n\n        private T? GetValueOrDefault&lt;T&gt;(string nodeId, DataValue value)\n        {\n            if (!StatusCode.IsBad(value.StatusCode))\n            {\n                return value.Value is T typedValue\n                    ? typedValue\n                    : LogAndReturnDefault&lt;T&gt;(nodeId);\n            }\n            logger.LogWarning(\"Read node {NodeId} returned bad status {Status}\", nodeId, value.StatusCode);\n            return default;\n        }\n\n        private T? LogAndReturnDefault&lt;T&gt;(string nodeId)\n        {\n            logger.LogWarning(\"Cannot cast value from node {NodeId} to type {Type}\", nodeId, typeof(T).Name);\n            return default;\n        }\n\n        public async Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default)\n        {\n            var session = connection.Session;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 2
          },
          {
            "text": "using Opc.Ua;",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 5
          },
          {
            "text": "{",
            "lineNumber": 6
          },
          {
            "text": "    public class OpcUaReadWriteService(",
            "lineNumber": 7
          },
          {
            "text": "        IOpcUaConnectionService connection,",
            "lineNumber": 8
          },
          {
            "text": "        ILogger&lt;OpcUaReadWriteService&gt; logger)",
            "lineNumber": 9
          },
          {
            "text": "        : IOpcUaReadWriteService",
            "lineNumber": 10
          },
          {
            "text": "    {",
            "lineNumber": 11
          },
          {
            "text": "        public async Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default)",
            "lineNumber": 12
          },
          {
            "text": "        {",
            "lineNumber": 13
          },
          {
            "text": "            var session = connection.Session;",
            "lineNumber": 14
          },
          {
            "text": "            if (session is not { Connected: true })",
            "lineNumber": 15
          },
          {
            "text": "            {",
            "lineNumber": 16
          },
          {
            "text": "                logger.LogWarning(\"Cannot read node {NodeId}: Session not connected\", nodeId);",
            "lineNumber": 17
          },
          {
            "text": "                return default;",
            "lineNumber": 18
          },
          {
            "text": "            }",
            "lineNumber": 19
          },
          {
            "text": "            try",
            "lineNumber": 20
          },
          {
            "text": "            {",
            "lineNumber": 21
          },
          {
            "text": "                var node = new NodeId(nodeId);",
            "lineNumber": 22
          },
          {
            "text": "                var value = await session.ReadValueAsync(node, ct);",
            "lineNumber": 23
          },
          {
            "text": "                return GetValueOrDefault&lt;T&gt;(nodeId, value);",
            "lineNumber": 24
          },
          {
            "text": "            }",
            "lineNumber": 25
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 26
          },
          {
            "text": "            {",
            "lineNumber": 27
          },
          {
            "text": "                logger.LogError(ex, \"Failed to read node {NodeId}\", nodeId);",
            "lineNumber": 28
          },
          {
            "text": "                return default;",
            "lineNumber": 29
          },
          {
            "text": "            }",
            "lineNumber": 30
          },
          {
            "text": "        }",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "        private T? GetValueOrDefault&lt;T&gt;(string nodeId, DataValue value)",
            "lineNumber": 33
          },
          {
            "text": "        {",
            "lineNumber": 34
          },
          {
            "text": "            if (!StatusCode.IsBad(value.StatusCode))",
            "lineNumber": 35
          },
          {
            "text": "            {",
            "lineNumber": 36
          },
          {
            "text": "                return value.Value is T typedValue",
            "lineNumber": 37
          },
          {
            "text": "                    ? typedValue",
            "lineNumber": 38
          },
          {
            "text": "                    : LogAndReturnDefault&lt;T&gt;(nodeId);",
            "lineNumber": 39
          },
          {
            "text": "            }",
            "lineNumber": 40
          },
          {
            "text": "            logger.LogWarning(\"Read node {NodeId} returned bad status {Status}\", nodeId, value.StatusCode);",
            "lineNumber": 41
          },
          {
            "text": "            return default;",
            "lineNumber": 42
          },
          {
            "text": "        }",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "        private T? LogAndReturnDefault&lt;T&gt;(string nodeId)",
            "lineNumber": 45
          },
          {
            "text": "        {",
            "lineNumber": 46
          },
          {
            "text": "            logger.LogWarning(\"Cannot cast value from node {NodeId} to type {Type}\", nodeId, typeof(T).Name);",
            "lineNumber": 47
          },
          {
            "text": "            return default;",
            "lineNumber": 48
          },
          {
            "text": "        }",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "        public async Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default)",
            "lineNumber": 51
          },
          {
            "text": "        {",
            "lineNumber": 52
          },
          {
            "text": "            var session = connection.Session;",
            "lineNumber": 53
          }
        ]
      },
      "score": 0.18374216556549072
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 58
          },
          "endPosition": {
            "line": 108,
            "column": 16
          }
        },
        "contents": "        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {\n            _appConfig = new Opc.Ua.ApplicationConfiguration\n            {\n                ApplicationName = _settings.ApplicationName,\n                ApplicationUri = $\"urn:{_settings.ApplicationName}\",\n                ApplicationType = ApplicationType.Client,\n                SecurityConfiguration = new SecurityConfiguration\n                {\n                    ApplicationCertificate = new CertificateIdentifier(),\n                    AutoAcceptUntrustedCertificates = true\n                },\n                ClientConfiguration = new ClientConfiguration\n                {\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\n                },\n                TransportConfigurations = [],\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\n            };\n            await _appConfig.ValidateAsync(ApplicationType.Client);\n        }\n\n        private async Task ConnectLoopAsync(CancellationToken ct)\n        {\n            _currentDelayMs = _settings.ReconnectIntervalMs;\n            try\n            {\n                while (!ct.IsCancellationRequested)\n                {\n                    var connected = await TryReconnectIfNeededAsync(ct);\n                    UpdateBackoffDelay(connected);\n                    await Task.Delay(_currentDelayMs, ct);\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Connection loop failed\");\n            }\n        }\n\n        private void UpdateBackoffDelay(bool connected)\n        {\n            if (connected)\n            {\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        }",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "        private async Task InitializeApplicationConfigAsync()",
            "lineNumber": 61
          },
          {
            "text": "        {",
            "lineNumber": 62
          },
          {
            "text": "            _appConfig = new Opc.Ua.ApplicationConfiguration",
            "lineNumber": 63
          },
          {
            "text": "            {",
            "lineNumber": 64
          },
          {
            "text": "                ApplicationName = _settings.ApplicationName,",
            "lineNumber": 65
          },
          {
            "text": "                ApplicationUri = $\"urn:{_settings.ApplicationName}\",",
            "lineNumber": 66
          },
          {
            "text": "                ApplicationType = ApplicationType.Client,",
            "lineNumber": 67
          },
          {
            "text": "                SecurityConfiguration = new SecurityConfiguration",
            "lineNumber": 68
          },
          {
            "text": "                {",
            "lineNumber": 69
          },
          {
            "text": "                    ApplicationCertificate = new CertificateIdentifier(),",
            "lineNumber": 70
          },
          {
            "text": "                    AutoAcceptUntrustedCertificates = true",
            "lineNumber": 71
          },
          {
            "text": "                },",
            "lineNumber": 72
          },
          {
            "text": "                ClientConfiguration = new ClientConfiguration",
            "lineNumber": 73
          },
          {
            "text": "                {",
            "lineNumber": 74
          },
          {
            "text": "                    DefaultSessionTimeout = _settings.SessionTimeoutMs",
            "lineNumber": 75
          },
          {
            "text": "                },",
            "lineNumber": 76
          },
          {
            "text": "                TransportConfigurations = [],",
            "lineNumber": 77
          },
          {
            "text": "                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }",
            "lineNumber": 78
          },
          {
            "text": "            };",
            "lineNumber": 79
          },
          {
            "text": "            await _appConfig.ValidateAsync(ApplicationType.Client);",
            "lineNumber": 80
          },
          {
            "text": "        }",
            "lineNumber": 81
          },
          {
            "lineNumber": 82
          },
          {
            "text": "        private async Task ConnectLoopAsync(CancellationToken ct)",
            "lineNumber": 83
          },
          {
            "text": "        {",
            "lineNumber": 84
          },
          {
            "text": "            _currentDelayMs = _settings.ReconnectIntervalMs;",
            "lineNumber": 85
          },
          {
            "text": "            try",
            "lineNumber": 86
          },
          {
            "text": "            {",
            "lineNumber": 87
          },
          {
            "text": "                while (!ct.IsCancellationRequested)",
            "lineNumber": 88
          },
          {
            "text": "                {",
            "lineNumber": 89
          },
          {
            "text": "                    var connected = await TryReconnectIfNeededAsync(ct);",
            "lineNumber": 90
          },
          {
            "text": "                    UpdateBackoffDelay(connected);",
            "lineNumber": 91
          },
          {
            "text": "                    await Task.Delay(_currentDelayMs, ct);",
            "lineNumber": 92
          },
          {
            "text": "                }",
            "lineNumber": 93
          },
          {
            "text": "            }",
            "lineNumber": 94
          },
          {
            "text": "            catch (OperationCanceledException)",
            "lineNumber": 95
          },
          {
            "text": "            {",
            "lineNumber": 96
          },
          {
            "text": "                logger.LogInformation(\"Connection loop canceled\");",
            "lineNumber": 97
          },
          {
            "text": "            }",
            "lineNumber": 98
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 99
          },
          {
            "text": "            {",
            "lineNumber": 100
          },
          {
            "text": "                logger.LogError(ex, \"Connection loop failed\");",
            "lineNumber": 101
          },
          {
            "text": "            }",
            "lineNumber": 102
          },
          {
            "text": "        }",
            "lineNumber": 103
          },
          {
            "lineNumber": 104
          },
          {
            "text": "        private void UpdateBackoffDelay(bool connected)",
            "lineNumber": 105
          },
          {
            "text": "        {",
            "lineNumber": 106
          },
          {
            "text": "            if (connected)",
            "lineNumber": 107
          },
          {
            "text": "            {",
            "lineNumber": 108
          },
          {
            "text": "                ",
            "lineNumber": 109
          }
        ]
      },
      "score": 0.18036794662475586
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 180
          },
          "endPosition": {
            "line": 245
          }
        },
        "contents": "        {\n            lock (_reconnectLock)\n            {\n                if (_reconnectHandler != null || Session == null)\n                {\n                    return;\n                }\n                logger.LogInformation(\"Reconnecting...\");\n                _reconnectHandler = new SessionReconnectHandler();\n                _reconnectHandler.BeginReconnect(\n                    Session,\n                    _settings.ReconnectIntervalMs,\n                    OnReconnectComplete);\n            }\n        }\n\n        private void OnReconnectComplete(object? sender, EventArgs e)\n        {\n            lock (_reconnectLock)\n            {\n                UpdateSessionIfReconnected();\n                DisposeReconnectHandler();\n            }\n        }\n\n        private void UpdateSessionIfReconnected()\n        {\n            if (_reconnectHandler?.Session is not Session newSession)\n            {\n                return;\n            }\n            var oldSession = Session;\n            if (ReferenceEquals(oldSession, newSession))\n            {\n                logger.LogInformation(\"Reconnected to OPC UA server (same session)\");\n                NotifyConnectionChanged(true);\n                return;\n            }\n            if (oldSession != null)\n            {\n                oldSession.KeepAlive -= OnSessionKeepAlive;\n                oldSession.Dispose();\n            }\n\n            Session = newSession;\n            Session.KeepAlive += OnSessionKeepAlive;\n            logger.LogInformation(\"Reconnected to OPC UA server\");\n            NotifyConnectionChanged(true);\n        }\n\n        private void NotifyConnectionChanged(bool connected)\n        {\n            if (_lastConnectionState == connected)\n            {\n                return;\n            }\n            _lastConnectionState = connected;\n            ConnectionChanged?.Invoke(this, connected);\n        }\n\n        private async Task CancelConnectionAsync()\n        {\n            if (_cts == null)\n            {\n                return;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 181
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 182
          },
          {
            "text": "            {",
            "lineNumber": 183
          },
          {
            "text": "                if (_reconnectHandler != null || Session == null)",
            "lineNumber": 184
          },
          {
            "text": "                {",
            "lineNumber": 185
          },
          {
            "text": "                    return;",
            "lineNumber": 186
          },
          {
            "text": "                }",
            "lineNumber": 187
          },
          {
            "text": "                logger.LogInformation(\"Reconnecting...\");",
            "lineNumber": 188
          },
          {
            "text": "                _reconnectHandler = new SessionReconnectHandler();",
            "lineNumber": 189
          },
          {
            "text": "                _reconnectHandler.BeginReconnect(",
            "lineNumber": 190
          },
          {
            "text": "                    Session,",
            "lineNumber": 191
          },
          {
            "text": "                    _settings.ReconnectIntervalMs,",
            "lineNumber": 192
          },
          {
            "text": "                    OnReconnectComplete);",
            "lineNumber": 193
          },
          {
            "text": "            }",
            "lineNumber": 194
          },
          {
            "text": "        }",
            "lineNumber": 195
          },
          {
            "lineNumber": 196
          },
          {
            "text": "        private void OnReconnectComplete(object? sender, EventArgs e)",
            "lineNumber": 197
          },
          {
            "text": "        {",
            "lineNumber": 198
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 199
          },
          {
            "text": "            {",
            "lineNumber": 200
          },
          {
            "text": "                UpdateSessionIfReconnected();",
            "lineNumber": 201
          },
          {
            "text": "                DisposeReconnectHandler();",
            "lineNumber": 202
          },
          {
            "text": "            }",
            "lineNumber": 203
          },
          {
            "text": "        }",
            "lineNumber": 204
          },
          {
            "lineNumber": 205
          },
          {
            "text": "        private void UpdateSessionIfReconnected()",
            "lineNumber": 206
          },
          {
            "text": "        {",
            "lineNumber": 207
          },
          {
            "text": "            if (_reconnectHandler?.Session is not Session newSession)",
            "lineNumber": 208
          },
          {
            "text": "            {",
            "lineNumber": 209
          },
          {
            "text": "                return;",
            "lineNumber": 210
          },
          {
            "text": "            }",
            "lineNumber": 211
          },
          {
            "text": "            var oldSession = Session;",
            "lineNumber": 212
          },
          {
            "text": "            if (ReferenceEquals(oldSession, newSession))",
            "lineNumber": 213
          },
          {
            "text": "            {",
            "lineNumber": 214
          },
          {
            "text": "                logger.LogInformation(\"Reconnected to OPC UA server (same session)\");",
            "lineNumber": 215
          },
          {
            "text": "                NotifyConnectionChanged(true);",
            "lineNumber": 216
          },
          {
            "text": "                return;",
            "lineNumber": 217
          },
          {
            "text": "            }",
            "lineNumber": 218
          },
          {
            "text": "            if (oldSession != null)",
            "lineNumber": 219
          },
          {
            "text": "            {",
            "lineNumber": 220
          },
          {
            "text": "                oldSession.KeepAlive -= OnSessionKeepAlive;",
            "lineNumber": 221
          },
          {
            "text": "                oldSession.Dispose();",
            "lineNumber": 222
          },
          {
            "text": "            }",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "            Session = newSession;",
            "lineNumber": 225
          },
          {
            "text": "            Session.KeepAlive += OnSessionKeepAlive;",
            "lineNumber": 226
          },
          {
            "text": "            logger.LogInformation(\"Reconnected to OPC UA server\");",
            "lineNumber": 227
          },
          {
            "text": "            NotifyConnectionChanged(true);",
            "lineNumber": 228
          },
          {
            "text": "        }",
            "lineNumber": 229
          },
          {
            "lineNumber": 230
          },
          {
            "text": "        private void NotifyConnectionChanged(bool connected)",
            "lineNumber": 231
          },
          {
            "text": "        {",
            "lineNumber": 232
          },
          {
            "text": "            if (_lastConnectionState == connected)",
            "lineNumber": 233
          },
          {
            "text": "            {",
            "lineNumber": 234
          },
          {
            "text": "                return;",
            "lineNumber": 235
          },
          {
            "text": "            }",
            "lineNumber": 236
          },
          {
            "text": "            _lastConnectionState = connected;",
            "lineNumber": 237
          },
          {
            "text": "            ConnectionChanged?.Invoke(this, connected);",
            "lineNumber": 238
          },
          {
            "text": "        }",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "        private async Task CancelConnectionAsync()",
            "lineNumber": 241
          },
          {
            "text": "        {",
            "lineNumber": 242
          },
          {
            "text": "            if (_cts == null)",
            "lineNumber": 243
          },
          {
            "text": "            {",
            "lineNumber": 244
          },
          {
            "text": "                return;",
            "lineNumber": 245
          }
        ]
      },
      "score": 0.16555356979370117
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSubscriptionService.cs",
        "range": {
          "startPosition": {
            "line": 145
          },
          "endPosition": {
            "line": 209
          }
        },
        "contents": "        {\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(subscription);\n                subscription.Dispose();\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error disposing subscription\");\n            }\n        }\n\n        private Subscription CreateSubscription(Session session)\n        {\n            return new Subscription(session.DefaultSubscription)\n            {\n                PublishingInterval = _settings.PublishingIntervalMs\n            };\n        }\n\n        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)\n        {\n            var monitoredItem = new MonitoredItem(subscription.DefaultItem)\n            {\n                StartNodeId = new NodeId(nodeId),\n                AttributeId = Attributes.Value\n            };\n            monitoredItem.Notification += (item, e) =&gt;\n            {\n                try\n                {\n                    if (e.NotificationValue is not MonitoredItemNotification notification)\n                    {\n                        return;\n                    }\n                    callback(notification.Value.Value);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);\n                }\n            };\n            return monitoredItem;\n        }\n\n        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)\n        {\n            subscription.AddItem(monitoredItem);\n            session.AddSubscription(subscription);\n            try\n            {\n                await subscription.CreateAsync();\n            }\n            catch\n            {\n                await session.RemoveSubscriptionAsync(subscription);\n                subscription.Dispose();\n                throw;\n            }\n        }\n\n        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)\n        {\n            if (subscription.Session is not { Connected: true })",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 146
          },
          {
            "text": "            try",
            "lineNumber": 147
          },
          {
            "text": "            {",
            "lineNumber": 148
          },
          {
            "text": "                await RemoveSubscriptionFromSessionAsync(subscription);",
            "lineNumber": 149
          },
          {
            "text": "                subscription.Dispose();",
            "lineNumber": 150
          },
          {
            "text": "            }",
            "lineNumber": 151
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 152
          },
          {
            "text": "            {",
            "lineNumber": 153
          },
          {
            "text": "                logger.LogError(ex, \"Error disposing subscription\");",
            "lineNumber": 154
          },
          {
            "text": "            }",
            "lineNumber": 155
          },
          {
            "text": "        }",
            "lineNumber": 156
          },
          {
            "lineNumber": 157
          },
          {
            "text": "        private Subscription CreateSubscription(Session session)",
            "lineNumber": 158
          },
          {
            "text": "        {",
            "lineNumber": 159
          },
          {
            "text": "            return new Subscription(session.DefaultSubscription)",
            "lineNumber": 160
          },
          {
            "text": "            {",
            "lineNumber": 161
          },
          {
            "text": "                PublishingInterval = _settings.PublishingIntervalMs",
            "lineNumber": 162
          },
          {
            "text": "            };",
            "lineNumber": 163
          },
          {
            "text": "        }",
            "lineNumber": 164
          },
          {
            "lineNumber": 165
          },
          {
            "text": "        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)",
            "lineNumber": 166
          },
          {
            "text": "        {",
            "lineNumber": 167
          },
          {
            "text": "            var monitoredItem = new MonitoredItem(subscription.DefaultItem)",
            "lineNumber": 168
          },
          {
            "text": "            {",
            "lineNumber": 169
          },
          {
            "text": "                StartNodeId = new NodeId(nodeId),",
            "lineNumber": 170
          },
          {
            "text": "                AttributeId = Attributes.Value",
            "lineNumber": 171
          },
          {
            "text": "            };",
            "lineNumber": 172
          },
          {
            "text": "            monitoredItem.Notification += (item, e) =&gt;",
            "lineNumber": 173
          },
          {
            "text": "            {",
            "lineNumber": 174
          },
          {
            "text": "                try",
            "lineNumber": 175
          },
          {
            "text": "                {",
            "lineNumber": 176
          },
          {
            "text": "                    if (e.NotificationValue is not MonitoredItemNotification notification)",
            "lineNumber": 177
          },
          {
            "text": "                    {",
            "lineNumber": 178
          },
          {
            "text": "                        return;",
            "lineNumber": 179
          },
          {
            "text": "                    }",
            "lineNumber": 180
          },
          {
            "text": "                    callback(notification.Value.Value);",
            "lineNumber": 181
          },
          {
            "text": "                }",
            "lineNumber": 182
          },
          {
            "text": "                catch (Exception ex)",
            "lineNumber": 183
          },
          {
            "text": "                {",
            "lineNumber": 184
          },
          {
            "text": "                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);",
            "lineNumber": 185
          },
          {
            "text": "                }",
            "lineNumber": 186
          },
          {
            "text": "            };",
            "lineNumber": 187
          },
          {
            "text": "            return monitoredItem;",
            "lineNumber": 188
          },
          {
            "text": "        }",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)",
            "lineNumber": 191
          },
          {
            "text": "        {",
            "lineNumber": 192
          },
          {
            "text": "            subscription.AddItem(monitoredItem);",
            "lineNumber": 193
          },
          {
            "text": "            session.AddSubscription(subscription);",
            "lineNumber": 194
          },
          {
            "text": "            try",
            "lineNumber": 195
          },
          {
            "text": "            {",
            "lineNumber": 196
          },
          {
            "text": "                await subscription.CreateAsync();",
            "lineNumber": 197
          },
          {
            "text": "            }",
            "lineNumber": 198
          },
          {
            "text": "            catch",
            "lineNumber": 199
          },
          {
            "text": "            {",
            "lineNumber": 200
          },
          {
            "text": "                await session.RemoveSubscriptionAsync(subscription);",
            "lineNumber": 201
          },
          {
            "text": "                subscription.Dispose();",
            "lineNumber": 202
          },
          {
            "text": "                throw;",
            "lineNumber": 203
          },
          {
            "text": "            }",
            "lineNumber": 204
          },
          {
            "text": "        }",
            "lineNumber": 205
          },
          {
            "lineNumber": 206
          },
          {
            "text": "        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)",
            "lineNumber": 207
          },
          {
            "text": "        {",
            "lineNumber": 208
          },
          {
            "text": "            if (subscription.Session is not { Connected: true })",
            "lineNumber": 209
          }
        ]
      },
      "score": 0.16347859799861908
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\appsettings.json",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 29
          }
        },
        "contents": "{\n  \"Paths\": {\n    \"PathToTestSteps\": \"D:/TestSteps\",\n    \"PathToTestsSequence\": \"D:/TestSequences\"\n  },\n  \"Logging\": {\n    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",\n    \"RetainedFileCountLimit\": \"5\",\n    \"LogLevel\": {\n      \"Default\": \"Warning\"\n    }\n  },\n  \"ConnectionPrinter\": {\n    \"Host\": \"192.168.0.60\",\n    \"Port\": 6101\n  },\n  \"ConnectionWeigher\": {\n    \"Host\": \"192.168.0.31\",\n    \"Port\": 5001\n  },\n  \"OpcUa\": {\n    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",\n    \"ApplicationName\": \"FinalTestHybrid\",\n    \"ReconnectIntervalMs\": 5000,\n    \"SessionTimeoutMs\": 60000\n  }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "{",
            "lineNumber": 1
          },
          {
            "text": "  \"Paths\": {",
            "lineNumber": 2
          },
          {
            "text": "    \"PathToTestSteps\": \"D:/TestSteps\",",
            "lineNumber": 3
          },
          {
            "text": "    \"PathToTestsSequence\": \"D:/TestSequences\"",
            "lineNumber": 4
          },
          {
            "text": "  },",
            "lineNumber": 5
          },
          {
            "text": "  \"Logging\": {",
            "lineNumber": 6
          },
          {
            "text": "    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",",
            "lineNumber": 7
          },
          {
            "text": "    \"RetainedFileCountLimit\": \"5\",",
            "lineNumber": 8
          },
          {
            "text": "    \"LogLevel\": {",
            "lineNumber": 9
          },
          {
            "text": "      \"Default\": \"Warning\"",
            "lineNumber": 10
          },
          {
            "text": "    }",
            "lineNumber": 11
          },
          {
            "text": "  },",
            "lineNumber": 12
          },
          {
            "text": "  \"ConnectionPrinter\": {",
            "lineNumber": 13
          },
          {
            "text": "    \"Host\": \"192.168.0.60\",",
            "lineNumber": 14
          },
          {
            "text": "    \"Port\": 6101",
            "lineNumber": 15
          },
          {
            "text": "  },",
            "lineNumber": 16
          },
          {
            "text": "  \"ConnectionWeigher\": {",
            "lineNumber": 17
          },
          {
            "text": "    \"Host\": \"192.168.0.31\",",
            "lineNumber": 18
          },
          {
            "text": "    \"Port\": 5001",
            "lineNumber": 19
          },
          {
            "text": "  },",
            "lineNumber": 20
          },
          {
            "text": "  \"OpcUa\": {",
            "lineNumber": 21
          },
          {
            "text": "    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",",
            "lineNumber": 22
          },
          {
            "text": "    \"ApplicationName\": \"FinalTestHybrid\",",
            "lineNumber": 23
          },
          {
            "text": "    \"ReconnectIntervalMs\": 5000,",
            "lineNumber": 24
          },
          {
            "text": "    \"SessionTimeoutMs\": 60000",
            "lineNumber": 25
          },
          {
            "text": "  }",
            "lineNumber": 26
          },
          {
            "text": "}",
            "lineNumber": 27
          }
        ]
      },
      "score": 0.1623956561088562
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\Sequence\\TestSequenceService.cs",
        "range": {
          "startPosition": {
            "line": 61
          },
          "endPosition": {
            "line": 116
          }
        },
        "contents": "    {\n        await sequenceExcelService.SaveSequenceAsync(path, rows).ConfigureAwait(false);\n    }\n\n    public async Task&lt;List&lt;SequenceRow&gt;&gt; LoadFromExcelAsync(string path, int columnCount)\n    {\n        return await sequenceExcelService.LoadSequenceAsync(path, columnCount).ConfigureAwait(false);\n    }\n\n    public string GetTestsSequencePath()\n    {\n        var path = GetRequiredConfigPath(\"Paths:PathToTestsSequence\");\n        return GetOrCreateDirectory(path);\n    }\n\n    private string GetOrCreateDirectory(string path)\n    {\n        return Directory.Exists(path) ? path : CreateDirectory(path);\n    }\n\n    private string CreateDirectory(string path)\n    {\n        try\n        {\n            Directory.CreateDirectory(path);\n            return path;\n        }\n        catch (Exception ex)\n        {\n            logger.LogError(ex, \"Ошибка пути: Не удалось создать директорию: {Path}\", path);\n            throw new IOException($\"Ошибка пути: Не удалось создать директорию: {path}. {ex.Message}\", ex);\n        }\n    }\n\n    public string GetValidRootPath()\n    {\n        var path = GetRequiredConfigPath(\"Paths:PathToTestSteps\");\n        ValidatePathExists(path);\n        return path;\n    }\n\n    private string GetRequiredConfigPath(string key)\n    {\n        var path = configuration[key];\n        if (!string.IsNullOrEmpty(path))\n        {\n            return path;\n        }\n        logger.LogError(\"Ошибка конфигурации: {Key} отсутствует в appsettings.json\", key);\n        throw new InvalidOperationException($\"Ошибка конфигурации: {key} отсутствует в appsettings.json\");\n    }\n\n    private void ValidatePathExists(string path)\n    {\n        if (Directory.Exists(path))",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    {",
            "lineNumber": 62
          },
          {
            "text": "        await sequenceExcelService.SaveSequenceAsync(path, rows).ConfigureAwait(false);",
            "lineNumber": 63
          },
          {
            "text": "    }",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "    public async Task&lt;List&lt;SequenceRow&gt;&gt; LoadFromExcelAsync(string path, int columnCount)",
            "lineNumber": 66
          },
          {
            "text": "    {",
            "lineNumber": 67
          },
          {
            "text": "        return await sequenceExcelService.LoadSequenceAsync(path, columnCount).ConfigureAwait(false);",
            "lineNumber": 68
          },
          {
            "text": "    }",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "    public string GetTestsSequencePath()",
            "lineNumber": 71
          },
          {
            "text": "    {",
            "lineNumber": 72
          },
          {
            "text": "        var path = GetRequiredConfigPath(\"Paths:PathToTestsSequence\");",
            "lineNumber": 73
          },
          {
            "text": "        return GetOrCreateDirectory(path);",
            "lineNumber": 74
          },
          {
            "text": "    }",
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "    private string GetOrCreateDirectory(string path)",
            "lineNumber": 77
          },
          {
            "text": "    {",
            "lineNumber": 78
          },
          {
            "text": "        return Directory.Exists(path) ? path : CreateDirectory(path);",
            "lineNumber": 79
          },
          {
            "text": "    }",
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "    private string CreateDirectory(string path)",
            "lineNumber": 82
          },
          {
            "text": "    {",
            "lineNumber": 83
          },
          {
            "text": "        try",
            "lineNumber": 84
          },
          {
            "text": "        {",
            "lineNumber": 85
          },
          {
            "text": "            Directory.CreateDirectory(path);",
            "lineNumber": 86
          },
          {
            "text": "            return path;",
            "lineNumber": 87
          },
          {
            "text": "        }",
            "lineNumber": 88
          },
          {
            "text": "        catch (Exception ex)",
            "lineNumber": 89
          },
          {
            "text": "        {",
            "lineNumber": 90
          },
          {
            "text": "            logger.LogError(ex, \"Ошибка пути: Не удалось создать директорию: {Path}\", path);",
            "lineNumber": 91
          },
          {
            "text": "            throw new IOException($\"Ошибка пути: Не удалось создать директорию: {path}. {ex.Message}\", ex);",
            "lineNumber": 92
          },
          {
            "text": "        }",
            "lineNumber": 93
          },
          {
            "text": "    }",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "    public string GetValidRootPath()",
            "lineNumber": 96
          },
          {
            "text": "    {",
            "lineNumber": 97
          },
          {
            "text": "        var path = GetRequiredConfigPath(\"Paths:PathToTestSteps\");",
            "lineNumber": 98
          },
          {
            "text": "        ValidatePathExists(path);",
            "lineNumber": 99
          },
          {
            "text": "        return path;",
            "lineNumber": 100
          },
          {
            "text": "    }",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "    private string GetRequiredConfigPath(string key)",
            "lineNumber": 103
          },
          {
            "text": "    {",
            "lineNumber": 104
          },
          {
            "text": "        var path = configuration[key];",
            "lineNumber": 105
          },
          {
            "text": "        if (!string.IsNullOrEmpty(path))",
            "lineNumber": 106
          },
          {
            "text": "        {",
            "lineNumber": 107
          },
          {
            "text": "            return path;",
            "lineNumber": 108
          },
          {
            "text": "        }",
            "lineNumber": 109
          },
          {
            "text": "        logger.LogError(\"Ошибка конфигурации: {Key} отсутствует в appsettings.json\", key);",
            "lineNumber": 110
          },
          {
            "text": "        throw new InvalidOperationException($\"Ошибка конфигурации: {key} отсутствует в appsettings.json\");",
            "lineNumber": 111
          },
          {
            "text": "    }",
            "lineNumber": 112
          },
          {
            "lineNumber": 113
          },
          {
            "text": "    private void ValidatePathExists(string path)",
            "lineNumber": 114
          },
          {
            "text": "    {",
            "lineNumber": 115
          },
          {
            "text": "        if (Directory.Exists(path))",
            "lineNumber": 116
          }
        ]
      },
      "score": 0.1438150405883789
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 105
          },
          "endPosition": {
            "line": 137
          }
        },
        "contents": "        {\n            if (connected)\n            {\n                _currentDelayMs = _settings.ReconnectIntervalMs;\n                return;\n            }\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\n        }\n\n        private async Task&lt;bool&gt; TryReconnectIfNeededAsync(CancellationToken ct)\n        {\n            if (IsReconnectingOrConnected())\n            {\n                return IsConnected;\n            }\n            await TryConnectAsync(ct);\n            return IsConnected;\n        }\n\n        private bool IsReconnectingOrConnected()\n        {\n            lock (_reconnectLock)\n            {\n                return _reconnectHandler != null || Session is { Connected: true };\n            }\n        }\n\n        private async Task TryConnectAsync(CancellationToken ct)\n        {\n            await _sessionLock.WaitAsync(ct);\n            try",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 106
          },
          {
            "text": "            if (connected)",
            "lineNumber": 107
          },
          {
            "text": "            {",
            "lineNumber": 108
          },
          {
            "text": "                _currentDelayMs = _settings.ReconnectIntervalMs;",
            "lineNumber": 109
          },
          {
            "text": "                return;",
            "lineNumber": 110
          },
          {
            "text": "            }",
            "lineNumber": 111
          },
          {
            "text": "            var maxDelay = _settings.ReconnectIntervalMs * 8;",
            "lineNumber": 112
          },
          {
            "text": "            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);",
            "lineNumber": 113
          },
          {
            "text": "        }",
            "lineNumber": 114
          },
          {
            "lineNumber": 115
          },
          {
            "text": "        private async Task&lt;bool&gt; TryReconnectIfNeededAsync(CancellationToken ct)",
            "lineNumber": 116
          },
          {
            "text": "        {",
            "lineNumber": 117
          },
          {
            "text": "            if (IsReconnectingOrConnected())",
            "lineNumber": 118
          },
          {
            "text": "            {",
            "lineNumber": 119
          },
          {
            "text": "                return IsConnected;",
            "lineNumber": 120
          },
          {
            "text": "            }",
            "lineNumber": 121
          },
          {
            "text": "            await TryConnectAsync(ct);",
            "lineNumber": 122
          },
          {
            "text": "            return IsConnected;",
            "lineNumber": 123
          },
          {
            "text": "        }",
            "lineNumber": 124
          },
          {
            "lineNumber": 125
          },
          {
            "text": "        private bool IsReconnectingOrConnected()",
            "lineNumber": 126
          },
          {
            "text": "        {",
            "lineNumber": 127
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 128
          },
          {
            "text": "            {",
            "lineNumber": 129
          },
          {
            "text": "                return _reconnectHandler != null || Session is { Connected: true };",
            "lineNumber": 130
          },
          {
            "text": "            }",
            "lineNumber": 131
          },
          {
            "text": "        }",
            "lineNumber": 132
          },
          {
            "lineNumber": 133
          },
          {
            "text": "        private async Task TryConnectAsync(CancellationToken ct)",
            "lineNumber": 134
          },
          {
            "text": "        {",
            "lineNumber": 135
          },
          {
            "text": "            await _sessionLock.WaitAsync(ct);",
            "lineNumber": 136
          },
          {
            "text": "            try",
            "lineNumber": 137
          }
        ]
      },
      "score": 0.14112530648708344
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSettings.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 11,
            "column": 1
          }
        },
        "contents": "namespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSettings\n    {\n        public string EndpointUrl { get; set; } = \"opc.tcp://192.168.1.100:4840\";\n        public string ApplicationName { get; set; } = \"FinalTestHybrid\";\n        public int ReconnectIntervalMs { get; set; } = 5000;\n        public int SessionTimeoutMs { get; set; } = 60000;\n        public int PublishingIntervalMs { get; set; } = 1000;\n        public int OperationTimeoutMs { get; set; } = 15000;\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 1
          },
          {
            "text": "{",
            "lineNumber": 2
          },
          {
            "text": "    public class OpcUaSettings",
            "lineNumber": 3
          },
          {
            "text": "    {",
            "lineNumber": 4
          },
          {
            "text": "        public string EndpointUrl { get; set; } = \"opc.tcp://192.168.1.100:4840\";",
            "lineNumber": 5
          },
          {
            "text": "        public string ApplicationName { get; set; } = \"FinalTestHybrid\";",
            "lineNumber": 6
          },
          {
            "text": "        public int ReconnectIntervalMs { get; set; } = 5000;",
            "lineNumber": 7
          },
          {
            "text": "        public int SessionTimeoutMs { get; set; } = 60000;",
            "lineNumber": 8
          },
          {
            "text": "        public int PublishingIntervalMs { get; set; } = 1000;",
            "lineNumber": 9
          },
          {
            "text": "        public int OperationTimeoutMs { get; set; } = 15000;",
            "lineNumber": 10
          },
          {
            "text": "    }",
            "lineNumber": 11
          },
          {
            "text": "}",
            "lineNumber": 12
          }
        ]
      },
      "score": 0.13943493366241455
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Components\\Engineer\\Sequence\\TestSequenceEditor.razor.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 44
          }
        },
        "contents": "using Final_Test_Hybrid.Models;\nusing Final_Test_Hybrid.Services.IO;\nusing Microsoft.AspNetCore.Components;\nusing Microsoft.JSInterop;\nusing Radzen.Blazor;\n\nnamespace Final_Test_Hybrid.Components.Engineer.Sequence;\n\npublic partial class TestSequenceEditor : IAsyncDisposable\n{\n    [Inject]\n    public required IFilePickerService FilePickerService { get; set; }\n    [Inject]\n    public required IJSRuntime JsRuntime { get; set; }\n    private RadzenDataGrid&lt;SequenceRow&gt;? _grid;\n    private List&lt;SequenceRow&gt; _rows = [];\n    private readonly CancellationTokenSource _cts = new();\n    private readonly int _columnCount = 4;\n    private bool _disposed;\n    private bool _isLoading = true;\n    private bool _isFileActive;\n\n    protected override async Task OnInitializedAsync()\n    {\n        await Task.Yield();\n        _rows = TestSequenceService.InitializeRows(20, _columnCount);\n        _isFileActive = !string.IsNullOrEmpty(TestSequenceService.CurrentFilePath);\n        _isLoading = false;\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        _disposed = true;\n        await _cts.CancelAsync();\n        _cts.Dispose();\n        ResetServiceState();\n    }\n\n    private void ResetServiceState()\n    {\n        TestSequenceService.CurrentFilePath = null;\n        TestSequenceService.CurrentFileName = null;\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Models;",
            "lineNumber": 1
          },
          {
            "text": "using Final_Test_Hybrid.Services.IO;",
            "lineNumber": 2
          },
          {
            "text": "using Microsoft.AspNetCore.Components;",
            "lineNumber": 3
          },
          {
            "text": "using Microsoft.JSInterop;",
            "lineNumber": 4
          },
          {
            "text": "using Radzen.Blazor;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "namespace Final_Test_Hybrid.Components.Engineer.Sequence;",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "public partial class TestSequenceEditor : IAsyncDisposable",
            "lineNumber": 9
          },
          {
            "text": "{",
            "lineNumber": 10
          },
          {
            "text": "    [Inject]",
            "lineNumber": 11
          },
          {
            "text": "    public required IFilePickerService FilePickerService { get; set; }",
            "lineNumber": 12
          },
          {
            "text": "    [Inject]",
            "lineNumber": 13
          },
          {
            "text": "    public required IJSRuntime JsRuntime { get; set; }",
            "lineNumber": 14
          },
          {
            "text": "    private RadzenDataGrid&lt;SequenceRow&gt;? _grid;",
            "lineNumber": 15
          },
          {
            "text": "    private List&lt;SequenceRow&gt; _rows = [];",
            "lineNumber": 16
          },
          {
            "text": "    private readonly CancellationTokenSource _cts = new();",
            "lineNumber": 17
          },
          {
            "text": "    private readonly int _columnCount = 4;",
            "lineNumber": 18
          },
          {
            "text": "    private bool _disposed;",
            "lineNumber": 19
          },
          {
            "text": "    private bool _isLoading = true;",
            "lineNumber": 20
          },
          {
            "text": "    private bool _isFileActive;",
            "lineNumber": 21
          },
          {
            "lineNumber": 22
          },
          {
            "text": "    protected override async Task OnInitializedAsync()",
            "lineNumber": 23
          },
          {
            "text": "    {",
            "lineNumber": 24
          },
          {
            "text": "        await Task.Yield();",
            "lineNumber": 25
          },
          {
            "text": "        _rows = TestSequenceService.InitializeRows(20, _columnCount);",
            "lineNumber": 26
          },
          {
            "text": "        _isFileActive = !string.IsNullOrEmpty(TestSequenceService.CurrentFilePath);",
            "lineNumber": 27
          },
          {
            "text": "        _isLoading = false;",
            "lineNumber": 28
          },
          {
            "text": "    }",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "    public async ValueTask DisposeAsync()",
            "lineNumber": 31
          },
          {
            "text": "    {",
            "lineNumber": 32
          },
          {
            "text": "        _disposed = true;",
            "lineNumber": 33
          },
          {
            "text": "        await _cts.CancelAsync();",
            "lineNumber": 34
          },
          {
            "text": "        _cts.Dispose();",
            "lineNumber": 35
          },
          {
            "text": "        ResetServiceState();",
            "lineNumber": 36
          },
          {
            "text": "    }",
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "    private void ResetServiceState()",
            "lineNumber": 39
          },
          {
            "text": "    {",
            "lineNumber": 40
          },
          {
            "text": "        TestSequenceService.CurrentFilePath = null;",
            "lineNumber": 41
          },
          {
            "text": "        TestSequenceService.CurrentFileName = null;",
            "lineNumber": 42
          },
          {
            "text": "    }",
            "lineNumber": 43
          },
          {
            "text": "}",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.13582980632781982
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSubscriptionService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 40
          }
        },
        "contents": "using System.Collections.Concurrent;\nusing Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSubscriptionService(\n        IOpcUaConnectionService connectionService,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ILogger&lt;OpcUaSubscriptionService&gt; logger) : IOpcUaSubscriptionService\n    {\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly ConcurrentDictionary&lt;string, Subscription&gt; _subscriptions = new();\n        private readonly ConcurrentDictionary&lt;string, Action&lt;object?&gt;&gt; _callbacks = new();\n        private readonly Lock _connectionEventsLock = new();\n        private readonly SemaphoreSlim _connectionChangeGate = new(1, 1);\n        private readonly CancellationTokenSource _disposeCts = new();\n        private bool _connectionEventsAttached;\n        private bool _disposed;\n\n        public OpcUaSubscriptionService(\n            IOpcUaConnectionService connectionService,\n            IOptions&lt;OpcUaSettings&gt; settings,\n            ILogger&lt;OpcUaSubscriptionService&gt; logger,\n            bool subscribeToConnection = true)\n            : this(connectionService, settings, logger)\n        {\n            if (subscribeToConnection)\n            {\n                connectionService.ConnectionChanged += OnConnectionChanged;\n                _connectionEventsAttached = true;\n            }\n        }\n\n        public async Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback)\n        {\n            ObjectDisposedException.ThrowIf(_disposed, this);",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using System.Collections.Concurrent;",
            "lineNumber": 1
          },
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 2
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 3
          },
          {
            "text": "using Microsoft.Extensions.Options;",
            "lineNumber": 4
          },
          {
            "text": "using Opc.Ua;",
            "lineNumber": 5
          },
          {
            "text": "using Opc.Ua.Client;",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 8
          },
          {
            "text": "{",
            "lineNumber": 9
          },
          {
            "text": "    public class OpcUaSubscriptionService(",
            "lineNumber": 10
          },
          {
            "text": "        IOpcUaConnectionService connectionService,",
            "lineNumber": 11
          },
          {
            "text": "        IOptions&lt;OpcUaSettings&gt; settings,",
            "lineNumber": 12
          },
          {
            "text": "        ILogger&lt;OpcUaSubscriptionService&gt; logger) : IOpcUaSubscriptionService",
            "lineNumber": 13
          },
          {
            "text": "    {",
            "lineNumber": 14
          },
          {
            "text": "        private readonly OpcUaSettings _settings = settings.Value;",
            "lineNumber": 15
          },
          {
            "text": "        private readonly ConcurrentDictionary&lt;string, Subscription&gt; _subscriptions = new();",
            "lineNumber": 16
          },
          {
            "text": "        private readonly ConcurrentDictionary&lt;string, Action&lt;object?&gt;&gt; _callbacks = new();",
            "lineNumber": 17
          },
          {
            "text": "        private readonly Lock _connectionEventsLock = new();",
            "lineNumber": 18
          },
          {
            "text": "        private readonly SemaphoreSlim _connectionChangeGate = new(1, 1);",
            "lineNumber": 19
          },
          {
            "text": "        private readonly CancellationTokenSource _disposeCts = new();",
            "lineNumber": 20
          },
          {
            "text": "        private bool _connectionEventsAttached;",
            "lineNumber": 21
          },
          {
            "text": "        private bool _disposed;",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "        public OpcUaSubscriptionService(",
            "lineNumber": 24
          },
          {
            "text": "            IOpcUaConnectionService connectionService,",
            "lineNumber": 25
          },
          {
            "text": "            IOptions&lt;OpcUaSettings&gt; settings,",
            "lineNumber": 26
          },
          {
            "text": "            ILogger&lt;OpcUaSubscriptionService&gt; logger,",
            "lineNumber": 27
          },
          {
            "text": "            bool subscribeToConnection = true)",
            "lineNumber": 28
          },
          {
            "text": "            : this(connectionService, settings, logger)",
            "lineNumber": 29
          },
          {
            "text": "        {",
            "lineNumber": 30
          },
          {
            "text": "            if (subscribeToConnection)",
            "lineNumber": 31
          },
          {
            "text": "            {",
            "lineNumber": 32
          },
          {
            "text": "                connectionService.ConnectionChanged += OnConnectionChanged;",
            "lineNumber": 33
          },
          {
            "text": "                _connectionEventsAttached = true;",
            "lineNumber": 34
          },
          {
            "text": "            }",
            "lineNumber": 35
          },
          {
            "text": "        }",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "        public async Task SubscribeAsync(string nodeId, Action&lt;object?&gt; callback)",
            "lineNumber": 38
          },
          {
            "text": "        {",
            "lineNumber": 39
          },
          {
            "text": "            ObjectDisposedException.ThrowIf(_disposed, this);",
            "lineNumber": 40
          }
        ]
      },
      "score": 0.13292169570922852
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSubscriptionService.cs",
        "range": {
          "startPosition": {
            "line": 317
          },
          "endPosition": {
            "line": 334,
            "column": 1
          }
        },
        "contents": "        {\n            if (connectionService.Session is not { Connected: true } session)\n            {\n                return;\n            }\n            foreach (var kvp in _callbacks.ToArray())\n            {\n                await RemoveExistingSubscriptionAsync(kvp.Key);\n                await CreateAndAddSubscriptionAsync(kvp.Key, kvp.Value, session);\n            }\n        }\n\n        private async Task DropAllSubscriptionsAsync()\n        {\n            await DisposeAllSubscriptionsAsync(clearCallbacks: false);\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 318
          },
          {
            "text": "            if (connectionService.Session is not { Connected: true } session)",
            "lineNumber": 319
          },
          {
            "text": "            {",
            "lineNumber": 320
          },
          {
            "text": "                return;",
            "lineNumber": 321
          },
          {
            "text": "            }",
            "lineNumber": 322
          },
          {
            "text": "            foreach (var kvp in _callbacks.ToArray())",
            "lineNumber": 323
          },
          {
            "text": "            {",
            "lineNumber": 324
          },
          {
            "text": "                await RemoveExistingSubscriptionAsync(kvp.Key);",
            "lineNumber": 325
          },
          {
            "text": "                await CreateAndAddSubscriptionAsync(kvp.Key, kvp.Value, session);",
            "lineNumber": 326
          },
          {
            "text": "            }",
            "lineNumber": 327
          },
          {
            "text": "        }",
            "lineNumber": 328
          },
          {
            "lineNumber": 329
          },
          {
            "text": "        private async Task DropAllSubscriptionsAsync()",
            "lineNumber": 330
          },
          {
            "text": "        {",
            "lineNumber": 331
          },
          {
            "text": "            await DisposeAllSubscriptionsAsync(clearCallbacks: false);",
            "lineNumber": 332
          },
          {
            "text": "        }",
            "lineNumber": 333
          },
          {
            "text": "    }",
            "lineNumber": 334
          },
          {
            "text": "}",
            "lineNumber": 335
          }
        ]
      },
      "score": 0.1251409649848938
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Program.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 21,
            "column": 1
          }
        },
        "contents": "namespace Final_Test_Hybrid\n{\n    internal static class Program\n    {\n        /// &lt;summary&gt;\n        ///  The main entry point for the application.\n        /// &lt;/summary&gt;\n        [STAThread]\n        static void Main()\n        {\n            // To customize application configuration such as set high DPI settings or default font,\n            // see https://aka.ms/applicationconfiguration.\n            \n            // Set EPPlus license context to NonCommercial using the static License property\n            // This is required for EPPlus 8+\n            OfficeOpenXml.ExcelPackage.License.SetNonCommercialPersonal(\"FinalTestHybrid\");\n\n            ApplicationConfiguration.Initialize();\n            Application.Run(new Form1());\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "namespace Final_Test_Hybrid",
            "lineNumber": 1
          },
          {
            "text": "{",
            "lineNumber": 2
          },
          {
            "text": "    internal static class Program",
            "lineNumber": 3
          },
          {
            "text": "    {",
            "lineNumber": 4
          },
          {
            "text": "        /// &lt;summary&gt;",
            "lineNumber": 5
          },
          {
            "text": "        ///  The main entry point for the application.",
            "lineNumber": 6
          },
          {
            "text": "        /// &lt;/summary&gt;",
            "lineNumber": 7
          },
          {
            "text": "        [STAThread]",
            "lineNumber": 8
          },
          {
            "text": "        static void Main()",
            "lineNumber": 9
          },
          {
            "text": "        {",
            "lineNumber": 10
          },
          {
            "text": "            // To customize application configuration such as set high DPI settings or default font,",
            "lineNumber": 11
          },
          {
            "text": "            // see https://aka.ms/applicationconfiguration.",
            "lineNumber": 12
          },
          {
            "text": "            ",
            "lineNumber": 13
          },
          {
            "text": "            // Set EPPlus license context to NonCommercial using the static License property",
            "lineNumber": 14
          },
          {
            "text": "            // This is required for EPPlus 8+",
            "lineNumber": 15
          },
          {
            "text": "            OfficeOpenXml.ExcelPackage.License.SetNonCommercialPersonal(\"FinalTestHybrid\");",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "            ApplicationConfiguration.Initialize();",
            "lineNumber": 18
          },
          {
            "text": "            Application.Run(new Form1());",
            "lineNumber": 19
          },
          {
            "text": "        }",
            "lineNumber": 20
          },
          {
            "text": "    }",
            "lineNumber": 21
          },
          {
            "text": "}",
            "lineNumber": 22
          }
        ]
      },
      "score": 0.12351226806640625
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\Sequence\\TestSequenceService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 63
          }
        },
        "contents": "using Final_Test_Hybrid.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace Final_Test_Hybrid.Services.Sequence;\n\npublic class TestSequenceService(\n    ISequenceExcelService sequenceExcelService,\n    IConfiguration configuration,\n    ILogger&lt;TestSequenceService&gt; logger)\n{\n    public string? CurrentFileName { get; set; }\n    public string? CurrentFilePath { get; set; }\n\n    public List&lt;SequenceRow&gt; InitializeRows(int count, int columnCount)\n    {\n        return Enumerable.Range(0, count)\n            .Select(_ =&gt; new SequenceRow(columnCount))\n            .ToList();\n    }\n\n    public SequenceRow? InsertRowAfter(List&lt;SequenceRow&gt; rows, SequenceRow currentRow, int columnCount)\n    {\n        var index = rows.IndexOf(currentRow);\n        return index &lt; 0 ? null : InsertRowAtIndex(rows, index + 1, columnCount);\n    }\n\n    public SequenceRow? InsertRowBefore(List&lt;SequenceRow&gt; rows, SequenceRow currentRow, int columnCount)\n    {\n        var index = rows.IndexOf(currentRow);\n        return index &lt; 0 ? null : InsertRowAtIndex(rows, index, columnCount);\n    }\n\n    private SequenceRow InsertRowAtIndex(List&lt;SequenceRow&gt; rows, int index, int columnCount)\n    {\n        var newRow = new SequenceRow(columnCount) { CssClass = \"row-animate-new\" };\n        rows.Insert(index, newRow);\n        return newRow;\n    }\n\n    public void PrepareForDelete(SequenceRow row)\n    {\n        row.CssClass = \"row-animate-delete\";\n    }\n\n    public void RemoveRow(List&lt;SequenceRow&gt; rows, SequenceRow row)\n    {\n        rows.Remove(row);\n    }\n\n    public void SaveToExcel(string path, List&lt;SequenceRow&gt; rows)\n    {\n        sequenceExcelService.SaveSequence(path, rows);\n    }\n\n    public List&lt;SequenceRow&gt; LoadFromExcel(string path, int columnCount)\n    {\n        return sequenceExcelService.LoadSequence(path, columnCount);\n    }\n\n    public async Task SaveToExcelAsync(string path, List&lt;SequenceRow&gt; rows)\n    {\n        await sequenceExcelService.SaveSequenceAsync(path, rows).ConfigureAwait(false);",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Models;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.Extensions.Configuration;",
            "lineNumber": 2
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.Sequence;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "public class TestSequenceService(",
            "lineNumber": 7
          },
          {
            "text": "    ISequenceExcelService sequenceExcelService,",
            "lineNumber": 8
          },
          {
            "text": "    IConfiguration configuration,",
            "lineNumber": 9
          },
          {
            "text": "    ILogger&lt;TestSequenceService&gt; logger)",
            "lineNumber": 10
          },
          {
            "text": "{",
            "lineNumber": 11
          },
          {
            "text": "    public string? CurrentFileName { get; set; }",
            "lineNumber": 12
          },
          {
            "text": "    public string? CurrentFilePath { get; set; }",
            "lineNumber": 13
          },
          {
            "lineNumber": 14
          },
          {
            "text": "    public List&lt;SequenceRow&gt; InitializeRows(int count, int columnCount)",
            "lineNumber": 15
          },
          {
            "text": "    {",
            "lineNumber": 16
          },
          {
            "text": "        return Enumerable.Range(0, count)",
            "lineNumber": 17
          },
          {
            "text": "            .Select(_ =&gt; new SequenceRow(columnCount))",
            "lineNumber": 18
          },
          {
            "text": "            .ToList();",
            "lineNumber": 19
          },
          {
            "text": "    }",
            "lineNumber": 20
          },
          {
            "lineNumber": 21
          },
          {
            "text": "    public SequenceRow? InsertRowAfter(List&lt;SequenceRow&gt; rows, SequenceRow currentRow, int columnCount)",
            "lineNumber": 22
          },
          {
            "text": "    {",
            "lineNumber": 23
          },
          {
            "text": "        var index = rows.IndexOf(currentRow);",
            "lineNumber": 24
          },
          {
            "text": "        return index &lt; 0 ? null : InsertRowAtIndex(rows, index + 1, columnCount);",
            "lineNumber": 25
          },
          {
            "text": "    }",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "    public SequenceRow? InsertRowBefore(List&lt;SequenceRow&gt; rows, SequenceRow currentRow, int columnCount)",
            "lineNumber": 28
          },
          {
            "text": "    {",
            "lineNumber": 29
          },
          {
            "text": "        var index = rows.IndexOf(currentRow);",
            "lineNumber": 30
          },
          {
            "text": "        return index &lt; 0 ? null : InsertRowAtIndex(rows, index, columnCount);",
            "lineNumber": 31
          },
          {
            "text": "    }",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "    private SequenceRow InsertRowAtIndex(List&lt;SequenceRow&gt; rows, int index, int columnCount)",
            "lineNumber": 34
          },
          {
            "text": "    {",
            "lineNumber": 35
          },
          {
            "text": "        var newRow = new SequenceRow(columnCount) { CssClass = \"row-animate-new\" };",
            "lineNumber": 36
          },
          {
            "text": "        rows.Insert(index, newRow);",
            "lineNumber": 37
          },
          {
            "text": "        return newRow;",
            "lineNumber": 38
          },
          {
            "text": "    }",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "    public void PrepareForDelete(SequenceRow row)",
            "lineNumber": 41
          },
          {
            "text": "    {",
            "lineNumber": 42
          },
          {
            "text": "        row.CssClass = \"row-animate-delete\";",
            "lineNumber": 43
          },
          {
            "text": "    }",
            "lineNumber": 44
          },
          {
            "lineNumber": 45
          },
          {
            "text": "    public void RemoveRow(List&lt;SequenceRow&gt; rows, SequenceRow row)",
            "lineNumber": 46
          },
          {
            "text": "    {",
            "lineNumber": 47
          },
          {
            "text": "        rows.Remove(row);",
            "lineNumber": 48
          },
          {
            "text": "    }",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "    public void SaveToExcel(string path, List&lt;SequenceRow&gt; rows)",
            "lineNumber": 51
          },
          {
            "text": "    {",
            "lineNumber": 52
          },
          {
            "text": "        sequenceExcelService.SaveSequence(path, rows);",
            "lineNumber": 53
          },
          {
            "text": "    }",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "    public List&lt;SequenceRow&gt; LoadFromExcel(string path, int columnCount)",
            "lineNumber": 56
          },
          {
            "text": "    {",
            "lineNumber": 57
          },
          {
            "text": "        return sequenceExcelService.LoadSequence(path, columnCount);",
            "lineNumber": 58
          },
          {
            "text": "    }",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "    public async Task SaveToExcelAsync(string path, List&lt;SequenceRow&gt; rows)",
            "lineNumber": 61
          },
          {
            "text": "    {",
            "lineNumber": 62
          },
          {
            "text": "        await sequenceExcelService.SaveSequenceAsync(path, rows).ConfigureAwait(false);",
            "lineNumber": 63
          }
        ]
      },
      "score": 0.1220541000366211
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\Sequence\\SequenceExcelService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 61
          }
        },
        "contents": "using Final_Test_Hybrid.Models;\nusing Microsoft.Extensions.Logging;\nusing OfficeOpenXml;\nusing FileInfo = System.IO.FileInfo;\n\nnamespace Final_Test_Hybrid.Services.Sequence;\n\npublic class SequenceExcelService(ILogger&lt;SequenceExcelService&gt; logger) : ISequenceExcelService\n{\n    private const int MaxColumns = 4;\n\n    public void SaveSequence(string path, List&lt;SequenceRow&gt; rows)\n    {\n        try\n        {\n            EnsureDirectoryExists(path);\n            SaveWorkbook(path, rows);\n        }\n        catch (Exception ex)\n        {\n            logger.LogError(ex, \"Ошибка сохранения последовательности в файл: {Path}\", path);\n            throw;\n        }\n    }\n\n    public List&lt;SequenceRow&gt; LoadSequence(string path, int columnCount)\n    {\n        try\n        {\n            return LoadWorkbook(path, columnCount);\n        }\n        catch (Exception ex)\n        {\n            logger.LogError(ex, \"Ошибка загрузки последовательности из файла: {Path}\", path);\n            throw;\n        }\n    }\n\n    public async Task SaveSequenceAsync(string path, List&lt;SequenceRow&gt; rows)\n    {\n        await Task.Run(() =&gt; SaveSequence(path, rows)).ConfigureAwait(false);\n    }\n\n    public async Task&lt;List&lt;SequenceRow&gt;&gt; LoadSequenceAsync(string path, int columnCount)\n    {\n        return await Task.Run(() =&gt; LoadSequence(path, columnCount)).ConfigureAwait(false);\n    }\n\n    private void SaveWorkbook(string path, List&lt;SequenceRow&gt; rows)\n    {\n        using var package = new ExcelPackage();\n        var worksheet = package.Workbook.Worksheets.Add(\"Sequence\");\n        CreateHeader(worksheet);\n        PopulateData(worksheet, rows);\n        FormatWorksheet(worksheet);\n        package.SaveAs(new FileInfo(path));\n    }\n\n    private List&lt;SequenceRow&gt; LoadWorkbook(string path, int columnCount)\n    {\n        using var package = new ExcelPackage(new FileInfo(path));",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Models;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 2
          },
          {
            "text": "using OfficeOpenXml;",
            "lineNumber": 3
          },
          {
            "text": "using FileInfo = System.IO.FileInfo;",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.Sequence;",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "public class SequenceExcelService(ILogger&lt;SequenceExcelService&gt; logger) : ISequenceExcelService",
            "lineNumber": 8
          },
          {
            "text": "{",
            "lineNumber": 9
          },
          {
            "text": "    private const int MaxColumns = 4;",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "    public void SaveSequence(string path, List&lt;SequenceRow&gt; rows)",
            "lineNumber": 12
          },
          {
            "text": "    {",
            "lineNumber": 13
          },
          {
            "text": "        try",
            "lineNumber": 14
          },
          {
            "text": "        {",
            "lineNumber": 15
          },
          {
            "text": "            EnsureDirectoryExists(path);",
            "lineNumber": 16
          },
          {
            "text": "            SaveWorkbook(path, rows);",
            "lineNumber": 17
          },
          {
            "text": "        }",
            "lineNumber": 18
          },
          {
            "text": "        catch (Exception ex)",
            "lineNumber": 19
          },
          {
            "text": "        {",
            "lineNumber": 20
          },
          {
            "text": "            logger.LogError(ex, \"Ошибка сохранения последовательности в файл: {Path}\", path);",
            "lineNumber": 21
          },
          {
            "text": "            throw;",
            "lineNumber": 22
          },
          {
            "text": "        }",
            "lineNumber": 23
          },
          {
            "text": "    }",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "    public List&lt;SequenceRow&gt; LoadSequence(string path, int columnCount)",
            "lineNumber": 26
          },
          {
            "text": "    {",
            "lineNumber": 27
          },
          {
            "text": "        try",
            "lineNumber": 28
          },
          {
            "text": "        {",
            "lineNumber": 29
          },
          {
            "text": "            return LoadWorkbook(path, columnCount);",
            "lineNumber": 30
          },
          {
            "text": "        }",
            "lineNumber": 31
          },
          {
            "text": "        catch (Exception ex)",
            "lineNumber": 32
          },
          {
            "text": "        {",
            "lineNumber": 33
          },
          {
            "text": "            logger.LogError(ex, \"Ошибка загрузки последовательности из файла: {Path}\", path);",
            "lineNumber": 34
          },
          {
            "text": "            throw;",
            "lineNumber": 35
          },
          {
            "text": "        }",
            "lineNumber": 36
          },
          {
            "text": "    }",
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "    public async Task SaveSequenceAsync(string path, List&lt;SequenceRow&gt; rows)",
            "lineNumber": 39
          },
          {
            "text": "    {",
            "lineNumber": 40
          },
          {
            "text": "        await Task.Run(() =&gt; SaveSequence(path, rows)).ConfigureAwait(false);",
            "lineNumber": 41
          },
          {
            "text": "    }",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "    public async Task&lt;List&lt;SequenceRow&gt;&gt; LoadSequenceAsync(string path, int columnCount)",
            "lineNumber": 44
          },
          {
            "text": "    {",
            "lineNumber": 45
          },
          {
            "text": "        return await Task.Run(() =&gt; LoadSequence(path, columnCount)).ConfigureAwait(false);",
            "lineNumber": 46
          },
          {
            "text": "    }",
            "lineNumber": 47
          },
          {
            "lineNumber": 48
          },
          {
            "text": "    private void SaveWorkbook(string path, List&lt;SequenceRow&gt; rows)",
            "lineNumber": 49
          },
          {
            "text": "    {",
            "lineNumber": 50
          },
          {
            "text": "        using var package = new ExcelPackage();",
            "lineNumber": 51
          },
          {
            "text": "        var worksheet = package.Workbook.Worksheets.Add(\"Sequence\");",
            "lineNumber": 52
          },
          {
            "text": "        CreateHeader(worksheet);",
            "lineNumber": 53
          },
          {
            "text": "        PopulateData(worksheet, rows);",
            "lineNumber": 54
          },
          {
            "text": "        FormatWorksheet(worksheet);",
            "lineNumber": 55
          },
          {
            "text": "        package.SaveAs(new FileInfo(path));",
            "lineNumber": 56
          },
          {
            "text": "    }",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "    private List&lt;SequenceRow&gt; LoadWorkbook(string path, int columnCount)",
            "lineNumber": 59
          },
          {
            "text": "    {",
            "lineNumber": 60
          },
          {
            "text": "        using var package = new ExcelPackage(new FileInfo(path));",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.12103766202926636
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSubscriptionService.cs",
        "range": {
          "startPosition": {
            "line": 38
          },
          "endPosition": {
            "line": 98,
            "column": 16
          }
        },
        "contents": "        {\n            ObjectDisposedException.ThrowIf(_disposed, this);\n            EnsureConnectionEventsAttached();\n\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                _callbacks[nodeId] = callback;\n                var session = connectionService.Session;\n                if (session is not { Connected: true })\n                {\n                    return;\n                }\n                await RemoveExistingSubscriptionAsync(nodeId);\n                await CreateAndAddSubscriptionAsync(nodeId, callback, session);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }\n        }\n\n        private async Task CreateAndAddSubscriptionAsync(string nodeId, Action&lt;object?&gt; callback, Session session)\n        {\n            try\n            {\n                var subscription = CreateSubscription(session);\n                var monitoredItem = CreateMonitoredItem(nodeId, callback, subscription);\n                await AddSubscriptionToSessionAsync(session, subscription, monitoredItem);\n                _subscriptions[nodeId] = subscription;\n                logger.LogInformation(\"Subscribed to node {NodeId}\", nodeId);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to subscribe to node {NodeId}\", nodeId);\n            }\n        }\n\n        public async Task UnsubscribeAsync(string nodeId)\n        {\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                _callbacks.TryRemove(nodeId, out _);\n                if (!_subscriptions.TryRemove(nodeId, out var subscription))\n                {\n                    return;\n                }\n                await RemoveSubscriptionSafelyAsync(nodeId, subscription);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }\n        }\n\n        private async Task RemoveSubscriptionSafelyAsync(string nodeId, Subscription subscription)\n        {\n            try\n            {\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 39
          },
          {
            "text": "            ObjectDisposedException.ThrowIf(_disposed, this);",
            "lineNumber": 40
          },
          {
            "text": "            EnsureConnectionEventsAttached();",
            "lineNumber": 41
          },
          {
            "lineNumber": 42
          },
          {
            "text": "            await _connectionChangeGate.WaitAsync();",
            "lineNumber": 43
          },
          {
            "text": "            try",
            "lineNumber": 44
          },
          {
            "text": "            {",
            "lineNumber": 45
          },
          {
            "text": "                _callbacks[nodeId] = callback;",
            "lineNumber": 46
          },
          {
            "text": "                var session = connectionService.Session;",
            "lineNumber": 47
          },
          {
            "text": "                if (session is not { Connected: true })",
            "lineNumber": 48
          },
          {
            "text": "                {",
            "lineNumber": 49
          },
          {
            "text": "                    return;",
            "lineNumber": 50
          },
          {
            "text": "                }",
            "lineNumber": 51
          },
          {
            "text": "                await RemoveExistingSubscriptionAsync(nodeId);",
            "lineNumber": 52
          },
          {
            "text": "                await CreateAndAddSubscriptionAsync(nodeId, callback, session);",
            "lineNumber": 53
          },
          {
            "text": "            }",
            "lineNumber": 54
          },
          {
            "text": "            finally",
            "lineNumber": 55
          },
          {
            "text": "            {",
            "lineNumber": 56
          },
          {
            "text": "                _connectionChangeGate.Release();",
            "lineNumber": 57
          },
          {
            "text": "            }",
            "lineNumber": 58
          },
          {
            "text": "        }",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "        private async Task CreateAndAddSubscriptionAsync(string nodeId, Action&lt;object?&gt; callback, Session session)",
            "lineNumber": 61
          },
          {
            "text": "        {",
            "lineNumber": 62
          },
          {
            "text": "            try",
            "lineNumber": 63
          },
          {
            "text": "            {",
            "lineNumber": 64
          },
          {
            "text": "                var subscription = CreateSubscription(session);",
            "lineNumber": 65
          },
          {
            "text": "                var monitoredItem = CreateMonitoredItem(nodeId, callback, subscription);",
            "lineNumber": 66
          },
          {
            "text": "                await AddSubscriptionToSessionAsync(session, subscription, monitoredItem);",
            "lineNumber": 67
          },
          {
            "text": "                _subscriptions[nodeId] = subscription;",
            "lineNumber": 68
          },
          {
            "text": "                logger.LogInformation(\"Subscribed to node {NodeId}\", nodeId);",
            "lineNumber": 69
          },
          {
            "text": "            }",
            "lineNumber": 70
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 71
          },
          {
            "text": "            {",
            "lineNumber": 72
          },
          {
            "text": "                logger.LogError(ex, \"Failed to subscribe to node {NodeId}\", nodeId);",
            "lineNumber": 73
          },
          {
            "text": "            }",
            "lineNumber": 74
          },
          {
            "text": "        }",
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "        public async Task UnsubscribeAsync(string nodeId)",
            "lineNumber": 77
          },
          {
            "text": "        {",
            "lineNumber": 78
          },
          {
            "text": "            await _connectionChangeGate.WaitAsync();",
            "lineNumber": 79
          },
          {
            "text": "            try",
            "lineNumber": 80
          },
          {
            "text": "            {",
            "lineNumber": 81
          },
          {
            "text": "                _callbacks.TryRemove(nodeId, out _);",
            "lineNumber": 82
          },
          {
            "text": "                if (!_subscriptions.TryRemove(nodeId, out var subscription))",
            "lineNumber": 83
          },
          {
            "text": "                {",
            "lineNumber": 84
          },
          {
            "text": "                    return;",
            "lineNumber": 85
          },
          {
            "text": "                }",
            "lineNumber": 86
          },
          {
            "text": "                await RemoveSubscriptionSafelyAsync(nodeId, subscription);",
            "lineNumber": 87
          },
          {
            "text": "            }",
            "lineNumber": 88
          },
          {
            "text": "            finally",
            "lineNumber": 89
          },
          {
            "text": "            {",
            "lineNumber": 90
          },
          {
            "text": "                _connectionChangeGate.Release();",
            "lineNumber": 91
          },
          {
            "text": "            }",
            "lineNumber": 92
          },
          {
            "text": "        }",
            "lineNumber": 93
          },
          {
            "lineNumber": 94
          },
          {
            "text": "        private async Task RemoveSubscriptionSafelyAsync(string nodeId, Subscription subscription)",
            "lineNumber": 95
          },
          {
            "text": "        {",
            "lineNumber": 96
          },
          {
            "text": "            try",
            "lineNumber": 97
          },
          {
            "text": "            {",
            "lineNumber": 98
          },
          {
            "text": "                ",
            "lineNumber": 99
          }
        ]
      },
      "score": 0.11712879687547684
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\bin\\Debug\\net10.0-windows\\appsettings.json",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 29
          }
        },
        "contents": "{\n  \"Paths\": {\n    \"PathToTestSteps\": \"D:/TestSteps\",\n    \"PathToTestsSequence\": \"D:/TestSequences\"\n  },\n  \"Logging\": {\n    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",\n    \"RetainedFileCountLimit\": \"5\",\n    \"LogLevel\": {\n      \"Default\": \"Warning\"\n    }\n  },\n  \"ConnectionPrinter\": {\n    \"Host\": \"192.168.0.60\",\n    \"Port\": 6101\n  },\n  \"ConnectionWeigher\": {\n    \"Host\": \"192.168.0.31\",\n    \"Port\": 5001\n  },\n  \"OpcUa\": {\n    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",\n    \"ApplicationName\": \"FinalTestHybrid\",\n    \"ReconnectIntervalMs\": 5000,\n    \"SessionTimeoutMs\": 60000\n  }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "{",
            "lineNumber": 1
          },
          {
            "text": "  \"Paths\": {",
            "lineNumber": 2
          },
          {
            "text": "    \"PathToTestSteps\": \"D:/TestSteps\",",
            "lineNumber": 3
          },
          {
            "text": "    \"PathToTestsSequence\": \"D:/TestSequences\"",
            "lineNumber": 4
          },
          {
            "text": "  },",
            "lineNumber": 5
          },
          {
            "text": "  \"Logging\": {",
            "lineNumber": 6
          },
          {
            "text": "    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",",
            "lineNumber": 7
          },
          {
            "text": "    \"RetainedFileCountLimit\": \"5\",",
            "lineNumber": 8
          },
          {
            "text": "    \"LogLevel\": {",
            "lineNumber": 9
          },
          {
            "text": "      \"Default\": \"Warning\"",
            "lineNumber": 10
          },
          {
            "text": "    }",
            "lineNumber": 11
          },
          {
            "text": "  },",
            "lineNumber": 12
          },
          {
            "text": "  \"ConnectionPrinter\": {",
            "lineNumber": 13
          },
          {
            "text": "    \"Host\": \"192.168.0.60\",",
            "lineNumber": 14
          },
          {
            "text": "    \"Port\": 6101",
            "lineNumber": 15
          },
          {
            "text": "  },",
            "lineNumber": 16
          },
          {
            "text": "  \"ConnectionWeigher\": {",
            "lineNumber": 17
          },
          {
            "text": "    \"Host\": \"192.168.0.31\",",
            "lineNumber": 18
          },
          {
            "text": "    \"Port\": 5001",
            "lineNumber": 19
          },
          {
            "text": "  },",
            "lineNumber": 20
          },
          {
            "text": "  \"OpcUa\": {",
            "lineNumber": 21
          },
          {
            "text": "    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",",
            "lineNumber": 22
          },
          {
            "text": "    \"ApplicationName\": \"FinalTestHybrid\",",
            "lineNumber": 23
          },
          {
            "text": "    \"ReconnectIntervalMs\": 5000,",
            "lineNumber": 24
          },
          {
            "text": "    \"SessionTimeoutMs\": 60000",
            "lineNumber": 25
          },
          {
            "text": "  }",
            "lineNumber": 26
          },
          {
            "text": "}",
            "lineNumber": 27
          }
        ]
      },
      "score": 0.114895761013031
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaReadWriteService.cs",
        "range": {
          "startPosition": {
            "line": 51
          },
          "endPosition": {
            "line": 100,
            "column": 1
          }
        },
        "contents": "        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot write node {NodeId}: Session not connected\", nodeId);\n                return;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var writeValue = CreateWriteValue(node, value);\n                var request = new WriteValueCollection { writeValue };\n                var response = await session.WriteAsync(null, request, ct);\n                LogWriteResult(nodeId, response.Results);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to write node {NodeId}\", nodeId);\n            }\n        }\n\n        private void LogWriteResult(string nodeId, StatusCodeCollection? results)\n        {\n            if (results == null || results.Count == 0)\n            {\n                logger.LogWarning(\"Write node {NodeId}: empty results\", nodeId);\n                return;\n            }\n            LogBadStatusIfNeeded(nodeId, results[0]);\n        }\n\n        private void LogBadStatusIfNeeded(string nodeId, StatusCode status)\n        {\n            if (StatusCode.IsBad(status))\n            {\n                logger.LogWarning(\"Write node {NodeId} failed with status {Status}\", nodeId, status);\n            }\n        }\n\n        private WriteValue CreateWriteValue&lt;T&gt;(NodeId node, T value)\n        {\n            return new WriteValue\n            {\n                NodeId = node,\n                AttributeId = Attributes.Value,\n                Value = new DataValue(new Variant(value))\n            };\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 52
          },
          {
            "text": "            var session = connection.Session;",
            "lineNumber": 53
          },
          {
            "text": "            if (session is not { Connected: true })",
            "lineNumber": 54
          },
          {
            "text": "            {",
            "lineNumber": 55
          },
          {
            "text": "                logger.LogWarning(\"Cannot write node {NodeId}: Session not connected\", nodeId);",
            "lineNumber": 56
          },
          {
            "text": "                return;",
            "lineNumber": 57
          },
          {
            "text": "            }",
            "lineNumber": 58
          },
          {
            "text": "            try",
            "lineNumber": 59
          },
          {
            "text": "            {",
            "lineNumber": 60
          },
          {
            "text": "                var node = new NodeId(nodeId);",
            "lineNumber": 61
          },
          {
            "text": "                var writeValue = CreateWriteValue(node, value);",
            "lineNumber": 62
          },
          {
            "text": "                var request = new WriteValueCollection { writeValue };",
            "lineNumber": 63
          },
          {
            "text": "                var response = await session.WriteAsync(null, request, ct);",
            "lineNumber": 64
          },
          {
            "text": "                LogWriteResult(nodeId, response.Results);",
            "lineNumber": 65
          },
          {
            "text": "            }",
            "lineNumber": 66
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 67
          },
          {
            "text": "            {",
            "lineNumber": 68
          },
          {
            "text": "                logger.LogError(ex, \"Failed to write node {NodeId}\", nodeId);",
            "lineNumber": 69
          },
          {
            "text": "            }",
            "lineNumber": 70
          },
          {
            "text": "        }",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "        private void LogWriteResult(string nodeId, StatusCodeCollection? results)",
            "lineNumber": 73
          },
          {
            "text": "        {",
            "lineNumber": 74
          },
          {
            "text": "            if (results == null || results.Count == 0)",
            "lineNumber": 75
          },
          {
            "text": "            {",
            "lineNumber": 76
          },
          {
            "text": "                logger.LogWarning(\"Write node {NodeId}: empty results\", nodeId);",
            "lineNumber": 77
          },
          {
            "text": "                return;",
            "lineNumber": 78
          },
          {
            "text": "            }",
            "lineNumber": 79
          },
          {
            "text": "            LogBadStatusIfNeeded(nodeId, results[0]);",
            "lineNumber": 80
          },
          {
            "text": "        }",
            "lineNumber": 81
          },
          {
            "lineNumber": 82
          },
          {
            "text": "        private void LogBadStatusIfNeeded(string nodeId, StatusCode status)",
            "lineNumber": 83
          },
          {
            "text": "        {",
            "lineNumber": 84
          },
          {
            "text": "            if (StatusCode.IsBad(status))",
            "lineNumber": 85
          },
          {
            "text": "            {",
            "lineNumber": 86
          },
          {
            "text": "                logger.LogWarning(\"Write node {NodeId} failed with status {Status}\", nodeId, status);",
            "lineNumber": 87
          },
          {
            "text": "            }",
            "lineNumber": 88
          },
          {
            "text": "        }",
            "lineNumber": 89
          },
          {
            "lineNumber": 90
          },
          {
            "text": "        private WriteValue CreateWriteValue&lt;T&gt;(NodeId node, T value)",
            "lineNumber": 91
          },
          {
            "text": "        {",
            "lineNumber": 92
          },
          {
            "text": "            return new WriteValue",
            "lineNumber": 93
          },
          {
            "text": "            {",
            "lineNumber": 94
          },
          {
            "text": "                NodeId = node,",
            "lineNumber": 95
          },
          {
            "text": "                AttributeId = Attributes.Value,",
            "lineNumber": 96
          },
          {
            "text": "                Value = new DataValue(new Variant(value))",
            "lineNumber": 97
          },
          {
            "text": "            };",
            "lineNumber": 98
          },
          {
            "text": "        }",
            "lineNumber": 99
          },
          {
            "text": "    }",
            "lineNumber": 100
          },
          {
            "text": "}",
            "lineNumber": 101
          }
        ]
      },
      "score": 0.11243879795074463
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "ISessionFactory|SessionFactory",
  "path": ".",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "ISessionFactory|SessionFactory",
    "path": ".",
    "outputMode": "content",
    "workspaceResults": {
      "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid": {
        "content": {
          "matches": [
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-25Z-проверка-стабильности-opc-ua-кода.md",
              "matches": [
                {
                  "lineNumber": 489,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 875,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        private int _currentDelayMs;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\n                    UpdateBackoffDelay(connected);\\n                    await Task.Delay(_currentDelayMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private void UpdateBackoffDelay(bool connected)\\n        {\\n            if (connected)\\n            {\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\n                return;\\n            }\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\n        }\\n\\n        private async Task&amp;lt;bool&amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return IsConnected;\\n            }\\n            await TryConnectAsync(ct);\\n            return IsConnected;\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
              "matches": [
                {
                  "lineNumber": 12,
                  "content": "        ISessionFactory sessionFactory)"
                },
                {
                  "lineNumber": 313,
                  "content": "                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")"
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-19Z-стабильность-и-утечки-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 72,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 408,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n\\n            var oldSession = Session;\\n            if (oldSession != null &amp;amp;&amp;amp; !ReferenceEquals(oldSession, newSession))\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-12Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-00Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-54Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 467,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-37Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-10Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 131,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 316,
                  "content": "3. **Line 286**: Missing &#96;ISessionFactory&#96; interface definition - I should check if this exists somewhere, but it's injected so it should be defined."
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-09Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 77,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-07Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 75,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-57Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 602,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-50Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 203,
                  "content": "  \"contents\": \"using Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (Session is not { Connected: true })\\n            {\\n                await TryConnectAsync(ct);\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-32Z-проверка-стабильности-кода-opcua.md",
              "matches": [
                {
                  "lineNumber": 658,
                  "content": "  \"contents\": \"using Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (Session is not { Connected: true })\\n            {\\n                await TryConnectAsync(ct);\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-06_15-27Z-выбор-библиотеки-для-opc-ua-с-plc.md",
              "matches": [
                {
                  "lineNumber": 1527,
                  "content": "| 'Session.Create(ApplicationConfiguration, ConfiguredEndpoint, bool, string, uint, IUserIdentity, IList&lt;string&gt;, CancellationToken)' is obsolete: 'Use ISessionFactory.CreateAsync' | 151:34-159:24 | DIAGNOSTIC_SEVERITY_WARNING |"
                },
                {
                  "lineNumber": 1617,
                  "content": "| 'Session.Create(ApplicationConfiguration, ConfiguredEndpoint, bool, string, uint, IUserIdentity, IList&lt;string&gt;, CancellationToken)' is obsolete: 'Use ISessionFactory.CreateAsync' | 151:34-159:24 | DIAGNOSTIC_SEVERITY_WARNING |"
                },
                {
                  "lineNumber": 1633,
                  "content": "Это предупреждение, не ошибка. Для простоты оставлю так - код будет работать. Если нужно убрать предупреждение, можно использовать ISessionFactory, но это усложнит код. Предупреждение можно проигнорировать для MVP."
                }
              ]
            }
          ],
          "totalLines": 21,
          "totalMatchedLines": 21
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "Services/OpcUa"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "Services/OpcUa"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---



---


Ищу реализацию `ISessionFactory`:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "AddSingleton.*ISessionFactory|AddScoped.*ISessionFactory|AddTransient.*ISessionFactory|class.*SessionFactory|: ISessionFactory",
  "path": ".",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "AddSingleton.*ISessionFactory|AddScoped.*ISessionFactory|AddTransient.*ISessionFactory|class.*SessionFactory|: ISessionFactory",
    "path": ".",
    "outputMode": "content",
    "workspaceResults": {
      "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid": {
        "content": {
          "matches": [
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-25Z-проверка-стабильности-opc-ua-кода.md",
              "matches": [
                {
                  "lineNumber": 489,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 875,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        private int _currentDelayMs;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            _currentDelayMs = _settings.ReconnectIntervalMs;\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    var connected = await TryReconnectIfNeededAsync(ct);\\n                    UpdateBackoffDelay(connected);\\n                    await Task.Delay(_currentDelayMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private void UpdateBackoffDelay(bool connected)\\n        {\\n            if (connected)\\n            {\\n                _currentDelayMs = _settings.ReconnectIntervalMs;\\n                return;\\n            }\\n            var maxDelay = _settings.ReconnectIntervalMs * 8;\\n            _currentDelayMs = Math.Min(_currentDelayMs * 2, maxDelay);\\n        }\\n\\n        private async Task&amp;lt;bool&amp;gt; TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return IsConnected;\\n            }\\n            await TryConnectAsync(ct);\\n            return IsConnected;\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            var oldSession = Session;\\n            if (ReferenceEquals(oldSession, newSession))\\n            {\\n                logger.LogInformation(\\\"Reconnected to OPC UA server (same session)\\\");\\n                NotifyConnectionChanged(true);\\n                return;\\n            }\\n            if (oldSession != null)\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-19Z-стабильность-и-утечки-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 72,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 408,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n\\n            var oldSession = Session;\\n            if (oldSession != null &amp;amp;&amp;amp; !ReferenceEquals(oldSession, newSession))\\n            {\\n                oldSession.KeepAlive -= OnSessionKeepAlive;\\n                oldSession.Dispose();\\n            }\\n\\n            Session = newSession;\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-12Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_15-00Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-54Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                },
                {
                  "lineNumber": 467,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session is not Session newSession)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = newSession;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return session switch\\n            {\\n                Session s =&amp;gt; s,\\n                _ =&amp;gt; throw new InvalidOperationException($\\\"SessionFactory returned unexpected type: {session.GetType().Name}\\\")\\n            };\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-37Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 104,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-10Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 131,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (IsReconnectingOrConnected())\\n            {\\n                return;\\n            }\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private bool IsReconnectingOrConnected()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                return _reconnectHandler != null || Session is { Connected: true };\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            try\\n            {\\n                await Session.CloseAsync();\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogWarning(ex, \\\"Error closing session\\\");\\n            }\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-09Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 77,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_14-07Z-проверка-opcua-на-стабильность-и-утечки.md",
              "matches": [
                {
                  "lineNumber": 75,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-57Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 602,
                  "content": "  \"contents\": \"using Final_Test_Hybrid.Services.OpcUa.Interface;\\nusing Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            bool reconnecting;\\n            lock (_reconnectLock)\\n            {\\n                reconnecting = _reconnectHandler != null;\\n            }\\n\\n            if (reconnecting || Session is { Connected: true })\\n            {\\n                return;\\n            }\\n\\n            await TryConnectAsync(ct);\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-50Z-проверка-стабильности-кода-opc-ua.md",
              "matches": [
                {
                  "lineNumber": 203,
                  "content": "  \"contents\": \"using Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (Session is not { Connected: true })\\n            {\\n                await TryConnectAsync(ct);\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            },
            {
              "file": ".\\.specstory\\history\\2025-12-08_13-32Z-проверка-стабильности-кода-opcua.md",
              "matches": [
                {
                  "lineNumber": 658,
                  "content": "  \"contents\": \"using Microsoft.Extensions.Logging;\\nusing Microsoft.Extensions.Options;\\nusing Opc.Ua;\\nusing Opc.Ua.Client;\\n\\nnamespace Final_Test_Hybrid.Services.OpcUa\\n{\\n    public class OpcUaConnectionService(\\n        ILogger&amp;lt;OpcUaConnectionService&amp;gt; logger,\\n        IOptions&amp;lt;OpcUaSettings&amp;gt; settings,\\n        ISessionFactory sessionFactory)\\n        : IOpcUaConnectionService\\n    {\\n        public bool IsConnected =&amp;gt; Session?.Connected == true;\\n        public Session? Session { get; private set; }\\n        private readonly OpcUaSettings _settings = settings.Value;\\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\\n        private readonly Lock _reconnectLock = new();\\n        private SessionReconnectHandler? _reconnectHandler;\\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\\n        private CancellationTokenSource? _cts;\\n        private Task? _connectLoopTask;\\n        private bool _lastConnectionState;\\n        public event EventHandler&amp;lt;bool&amp;gt;? ConnectionChanged;\\n\\n        public async Task StartAsync(CancellationToken ct = default)\\n        {\\n            if (_connectLoopTask is { IsCompleted: false })\\n            {\\n                return;\\n            }\\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\\n            await InitializeApplicationConfigAsync();\\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\\n        }\\n\\n        public async Task StopAsync()\\n        {\\n            await CancelConnectionAsync();\\n            DisposeReconnectHandler();\\n            await _sessionLock.WaitAsync();\\n            try\\n            {\\n                await CloseSessionAsync();\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n            NotifyConnectionChanged(false);\\n        }\\n\\n        public async ValueTask DisposeAsync()\\n        {\\n            await StopAsync();\\n            _sessionLock.Dispose();\\n        }\\n\\n        private async Task InitializeApplicationConfigAsync()\\n        {\\n            _appConfig = new Opc.Ua.ApplicationConfiguration\\n            {\\n                ApplicationName = _settings.ApplicationName,\\n                ApplicationUri = $\\\"urn:{_settings.ApplicationName}\\\",\\n                ApplicationType = ApplicationType.Client,\\n                SecurityConfiguration = new SecurityConfiguration\\n                {\\n                    ApplicationCertificate = new CertificateIdentifier(),\\n                    AutoAcceptUntrustedCertificates = true\\n                },\\n                ClientConfiguration = new ClientConfiguration\\n                {\\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\\n                },\\n                TransportConfigurations = [],\\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\\n            };\\n            await _appConfig.ValidateAsync(ApplicationType.Client);\\n        }\\n\\n        private async Task ConnectLoopAsync(CancellationToken ct)\\n        {\\n            try\\n            {\\n                while (!ct.IsCancellationRequested)\\n                {\\n                    await TryReconnectIfNeededAsync(ct);\\n                    await Task.Delay(_settings.ReconnectIntervalMs, ct);\\n                }\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Connection loop failed\\\");\\n            }\\n        }\\n\\n        private async Task TryReconnectIfNeededAsync(CancellationToken ct)\\n        {\\n            if (Session is not { Connected: true })\\n            {\\n                await TryConnectAsync(ct);\\n            }\\n        }\\n\\n        private async Task TryConnectAsync(CancellationToken ct)\\n        {\\n            await _sessionLock.WaitAsync(ct);\\n            try\\n            {\\n                DisposeReconnectHandler();\\n                await CloseSessionAsync();\\n                logger.LogInformation(\\\"Connecting to OPC UA server: {Endpoint}\\\", _settings.EndpointUrl);\\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\\n                Session = await CreateSessionAsync(configEndpoint, ct);\\n                Session.KeepAlive += OnSessionKeepAlive;\\n                logger.LogInformation(\\\"Connected to OPC UA server\\\");\\n                NotifyConnectionChanged(true);\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                // Cancellation is expected during shutdown\\n            }\\n            catch (Exception ex)\\n            {\\n                logger.LogError(ex, \\\"Failed to connect to OPC UA server\\\");\\n                NotifyConnectionChanged(false);\\n            }\\n            finally\\n            {\\n                _sessionLock.Release();\\n            }\\n        }\\n\\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\\n        {\\n            if (ShouldSkipKeepAlive(e))\\n            {\\n                return;\\n            }\\n            logger.LogWarning(\\\"Connection lost. Status: {Status}\\\", e.Status);\\n            NotifyConnectionChanged(false);\\n            StartReconnectIfNeeded();\\n        }\\n\\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\\n        {\\n            return e.Status == null || ServiceResult.IsGood(e.Status);\\n        }\\n\\n        private void StartReconnectIfNeeded()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                if (_reconnectHandler != null || Session == null)\\n                {\\n                    return;\\n                }\\n                logger.LogInformation(\\\"Reconnecting...\\\");\\n                _reconnectHandler = new SessionReconnectHandler();\\n                _reconnectHandler.BeginReconnect(\\n                    Session,\\n                    _settings.ReconnectIntervalMs,\\n                    OnReconnectComplete);\\n            }\\n        }\\n\\n        private void OnReconnectComplete(object? sender, EventArgs e)\\n        {\\n            lock (_reconnectLock)\\n            {\\n                UpdateSessionIfReconnected();\\n                DisposeReconnectHandler();\\n            }\\n        }\\n\\n        private void UpdateSessionIfReconnected()\\n        {\\n            if (_reconnectHandler?.Session == null)\\n            {\\n                return;\\n            }\\n            Session?.KeepAlive -= OnSessionKeepAlive;\\n            Session = (Session)_reconnectHandler.Session;\\n            logger.LogInformation(\\\"Reconnected to OPC UA server\\\");\\n            Session.KeepAlive += OnSessionKeepAlive;\\n            NotifyConnectionChanged(true);\\n        }\\n\\n        private void NotifyConnectionChanged(bool connected)\\n        {\\n            if (_lastConnectionState == connected)\\n            {\\n                return;\\n            }\\n            _lastConnectionState = connected;\\n            ConnectionChanged?.Invoke(this, connected);\\n        }\\n\\n        private async Task CancelConnectionAsync()\\n        {\\n            if (_cts == null)\\n            {\\n                return;\\n            }\\n            await _cts.CancelAsync();\\n            _cts.Dispose();\\n            _cts = null;\\n            DisposeReconnectHandler();\\n            await WaitConnectLoopAsync();\\n        }\\n\\n        private void DisposeReconnectHandler()\\n        {\\n            lock (_reconnectLock)\\n            {\\n                _reconnectHandler?.Dispose();\\n                _reconnectHandler = null;\\n            }\\n        }\\n\\n        private async Task CloseSessionAsync()\\n        {\\n            if (Session == null)\\n            {\\n                return;\\n            }\\n            Session.KeepAlive -= OnSessionKeepAlive;\\n            await Session.CloseAsync();\\n            Session.Dispose();\\n            Session = null;\\n        }\\n\\n        private async Task WaitConnectLoopAsync()\\n        {\\n            if (_connectLoopTask == null)\\n            {\\n                return;\\n            }\\n            try\\n            {\\n                await _connectLoopTask;\\n            }\\n            catch (OperationCanceledException)\\n            {\\n                logger.LogInformation(\\\"Connection loop canceled\\\");\\n            }\\n            _connectLoopTask = null;\\n        }\\n\\n        private async Task&amp;lt;Session&amp;gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\\n        {\\n            var session = await sessionFactory.CreateAsync(\\n                _appConfig,\\n                configEndpoint,\\n                updateBeforeConnect: false,\\n                sessionName: _settings.ApplicationName,\\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\\n                identity: new UserIdentity(new AnonymousIdentityToken()),\\n                preferredLocales: null,\\n                ct).ConfigureAwait(false);\\n            return (Session)session;\\n        }\\n    }\\n}\\n\","
                }
              ]
            }
          ],
          "totalLines": 15,
          "totalMatchedLines": 15
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is ISessionFactory registered in dependency injection?",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Form1.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 44
          }
        },
        "contents": "using Final_Test_Hybrid.Services.IO;\nusing Final_Test_Hybrid.Services.OpcUa;\nusing Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Final_Test_Hybrid.Services.Sequence;\nusing Final_Test_Hybrid.Services.Settings.IO;\nusing Final_Test_Hybrid.Services.UI;\nusing Microsoft.AspNetCore.Components.WebView.WindowsForms;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Radzen;\n\nnamespace Final_Test_Hybrid\n{\n    public partial class Form1 : Form\n    {\n        private IConfiguration? _config;\n        \n        public Form1()\n        {\n            InitializeComponent();\n            HandleException();\n            var services = new ServiceCollection();\n            SettingConfiguration(services);\n            SettingDevTools(services);\n            services.AddScoped&lt;IFilePickerService, WinFormsFilePickerService&gt;();\n            services.AddScoped&lt;ISequenceExcelService, SequenceExcelService&gt;();\n            services.AddScoped&lt;INotificationService, NotificationServiceWrapper&gt;();\n            services.AddScoped&lt;TestSequenceService&gt;();\n            services.Configure&lt;OpcUaSettings&gt;(_config!.GetSection(\"OpcUa\"));\n            services.AddSingleton&lt;IOpcUaConnectionService, OpcUaConnectionService&gt;();\n            services.AddSingleton&lt;IOpcUaReadWriteService, OpcUaReadWriteService&gt;();\n            services.AddSingleton&lt;IOpcUaSubscriptionService, OpcUaSubscriptionService&gt;();\n            services.AddBlazorWebViewDeveloperTools();\n            services.AddWindowsFormsBlazorWebView();\n            services.AddRadzenComponents();\n            blazorWebView1.HostPage = \"wwwroot\\\\index.html\";\n            var serviceProvider = services.BuildServiceProvider();\n            blazorWebView1.Services = serviceProvider;\n            \n            // Автозапуск OPC UA подключения\n            var connectionService = serviceProvider.GetRequiredService&lt;IOpcUaConnectionService&gt;();\n            _ = connectionService.StartAsync();\n            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Services.IO;",
            "lineNumber": 1
          },
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa;",
            "lineNumber": 2
          },
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 3
          },
          {
            "text": "using Final_Test_Hybrid.Services.Sequence;",
            "lineNumber": 4
          },
          {
            "text": "using Final_Test_Hybrid.Services.Settings.IO;",
            "lineNumber": 5
          },
          {
            "text": "using Final_Test_Hybrid.Services.UI;",
            "lineNumber": 6
          },
          {
            "text": "using Microsoft.AspNetCore.Components.WebView.WindowsForms;",
            "lineNumber": 7
          },
          {
            "text": "using Microsoft.Extensions.Configuration;",
            "lineNumber": 8
          },
          {
            "text": "using Microsoft.Extensions.DependencyInjection;",
            "lineNumber": 9
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 10
          },
          {
            "text": "using Radzen;",
            "lineNumber": 11
          },
          {
            "lineNumber": 12
          },
          {
            "text": "namespace Final_Test_Hybrid",
            "lineNumber": 13
          },
          {
            "text": "{",
            "lineNumber": 14
          },
          {
            "text": "    public partial class Form1 : Form",
            "lineNumber": 15
          },
          {
            "text": "    {",
            "lineNumber": 16
          },
          {
            "text": "        private IConfiguration? _config;",
            "lineNumber": 17
          },
          {
            "text": "        ",
            "lineNumber": 18
          },
          {
            "text": "        public Form1()",
            "lineNumber": 19
          },
          {
            "text": "        {",
            "lineNumber": 20
          },
          {
            "text": "            InitializeComponent();",
            "lineNumber": 21
          },
          {
            "text": "            HandleException();",
            "lineNumber": 22
          },
          {
            "text": "            var services = new ServiceCollection();",
            "lineNumber": 23
          },
          {
            "text": "            SettingConfiguration(services);",
            "lineNumber": 24
          },
          {
            "text": "            SettingDevTools(services);",
            "lineNumber": 25
          },
          {
            "text": "            services.AddScoped&lt;IFilePickerService, WinFormsFilePickerService&gt;();",
            "lineNumber": 26
          },
          {
            "text": "            services.AddScoped&lt;ISequenceExcelService, SequenceExcelService&gt;();",
            "lineNumber": 27
          },
          {
            "text": "            services.AddScoped&lt;INotificationService, NotificationServiceWrapper&gt;();",
            "lineNumber": 28
          },
          {
            "text": "            services.AddScoped&lt;TestSequenceService&gt;();",
            "lineNumber": 29
          },
          {
            "text": "            services.Configure&lt;OpcUaSettings&gt;(_config!.GetSection(\"OpcUa\"));",
            "lineNumber": 30
          },
          {
            "text": "            services.AddSingleton&lt;IOpcUaConnectionService, OpcUaConnectionService&gt;();",
            "lineNumber": 31
          },
          {
            "text": "            services.AddSingleton&lt;IOpcUaReadWriteService, OpcUaReadWriteService&gt;();",
            "lineNumber": 32
          },
          {
            "text": "            services.AddSingleton&lt;IOpcUaSubscriptionService, OpcUaSubscriptionService&gt;();",
            "lineNumber": 33
          },
          {
            "text": "            services.AddBlazorWebViewDeveloperTools();",
            "lineNumber": 34
          },
          {
            "text": "            services.AddWindowsFormsBlazorWebView();",
            "lineNumber": 35
          },
          {
            "text": "            services.AddRadzenComponents();",
            "lineNumber": 36
          },
          {
            "text": "            blazorWebView1.HostPage = \"wwwroot\\\\index.html\";",
            "lineNumber": 37
          },
          {
            "text": "            var serviceProvider = services.BuildServiceProvider();",
            "lineNumber": 38
          },
          {
            "text": "            blazorWebView1.Services = serviceProvider;",
            "lineNumber": 39
          },
          {
            "text": "            ",
            "lineNumber": 40
          },
          {
            "text": "            // Автозапуск OPC UA подключения",
            "lineNumber": 41
          },
          {
            "text": "            var connectionService = serviceProvider.GetRequiredService&lt;IOpcUaConnectionService&gt;();",
            "lineNumber": 42
          },
          {
            "text": "            _ = connectionService.StartAsync();",
            "lineNumber": 43
          },
          {
            "text": "            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.3347713351249695
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Form1.cs",
        "range": {
          "startPosition": {
            "line": 42
          },
          "endPosition": {
            "line": 88
          }
        },
        "contents": "            _ = connectionService.StartAsync();\n            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");\n            blazorWebView1.RootComponents.Add&lt;MyComponent&gt;(\"#app\");\n        }\n\n        private static void HandleException()\n        {\n            AppDomain.CurrentDomain.UnhandledException += (_, error) =&gt;\n            {\n                #if DEBUG\n                    MessageBox.Show(text: error.ExceptionObject.ToString(), caption: @\"������\");\n                #else\n                    MessageBox.Show(text: \"An error has occurred.\", caption: \"Error\");\n                #endif\n            };\n        }\n        \n        private void SettingConfiguration(ServiceCollection services)\n        {\n            _config = new ConfigurationBuilder()\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .Build();\n            services.AddSingleton&lt;IConfiguration&gt;(_config);\n        }\n        \n        private void SettingDevTools(ServiceCollection services)\n        {\n#if DEBUG\n            services.AddBlazorWebViewDeveloperTools();\n            services.AddLogging(logging =&gt;\n            {\n                logging.SetMinimumLevel(LogLevel.Information);\n                logging.AddDebug();\n                logging.AddConsole();\n                logging.AddFile(_config?.GetSection(\"Logging\")!);\n            });\n#else\n                services.AddLogging(logging =&gt;\n                {\n                    logging.SetMinimumLevel(LogLevel.Error);\n                    logging.AddFile(_config?.GetSection(\"Logging\"));\n                });\n#endif\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "            _ = connectionService.StartAsync();",
            "lineNumber": 43
          },
          {
            "text": "            //blazorWebView1.RootComponents.Add&lt;Counter&gt;(\"#app\");",
            "lineNumber": 44
          },
          {
            "text": "            blazorWebView1.RootComponents.Add&lt;MyComponent&gt;(\"#app\");",
            "lineNumber": 45
          },
          {
            "text": "        }",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "        private static void HandleException()",
            "lineNumber": 48
          },
          {
            "text": "        {",
            "lineNumber": 49
          },
          {
            "text": "            AppDomain.CurrentDomain.UnhandledException += (_, error) =&gt;",
            "lineNumber": 50
          },
          {
            "text": "            {",
            "lineNumber": 51
          },
          {
            "text": "                #if DEBUG",
            "lineNumber": 52
          },
          {
            "text": "                    MessageBox.Show(text: error.ExceptionObject.ToString(), caption: @\"������\");",
            "lineNumber": 53
          },
          {
            "text": "                #else",
            "lineNumber": 54
          },
          {
            "text": "                    MessageBox.Show(text: \"An error has occurred.\", caption: \"Error\");",
            "lineNumber": 55
          },
          {
            "text": "                #endif",
            "lineNumber": 56
          },
          {
            "text": "            };",
            "lineNumber": 57
          },
          {
            "text": "        }",
            "lineNumber": 58
          },
          {
            "text": "        ",
            "lineNumber": 59
          },
          {
            "text": "        private void SettingConfiguration(ServiceCollection services)",
            "lineNumber": 60
          },
          {
            "text": "        {",
            "lineNumber": 61
          },
          {
            "text": "            _config = new ConfigurationBuilder()",
            "lineNumber": 62
          },
          {
            "text": "                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)",
            "lineNumber": 63
          },
          {
            "text": "                .Build();",
            "lineNumber": 64
          },
          {
            "text": "            services.AddSingleton&lt;IConfiguration&gt;(_config);",
            "lineNumber": 65
          },
          {
            "text": "        }",
            "lineNumber": 66
          },
          {
            "text": "        ",
            "lineNumber": 67
          },
          {
            "text": "        private void SettingDevTools(ServiceCollection services)",
            "lineNumber": 68
          },
          {
            "text": "        {",
            "lineNumber": 69
          },
          {
            "text": "#if DEBUG",
            "lineNumber": 70
          },
          {
            "text": "            services.AddBlazorWebViewDeveloperTools();",
            "lineNumber": 71
          },
          {
            "text": "            services.AddLogging(logging =&gt;",
            "lineNumber": 72
          },
          {
            "text": "            {",
            "lineNumber": 73
          },
          {
            "text": "                logging.SetMinimumLevel(LogLevel.Information);",
            "lineNumber": 74
          },
          {
            "text": "                logging.AddDebug();",
            "lineNumber": 75
          },
          {
            "text": "                logging.AddConsole();",
            "lineNumber": 76
          },
          {
            "text": "                logging.AddFile(_config?.GetSection(\"Logging\")!);",
            "lineNumber": 77
          },
          {
            "text": "            });",
            "lineNumber": 78
          },
          {
            "text": "#else",
            "lineNumber": 79
          },
          {
            "text": "                services.AddLogging(logging =&gt;",
            "lineNumber": 80
          },
          {
            "text": "                {",
            "lineNumber": 81
          },
          {
            "text": "                    logging.SetMinimumLevel(LogLevel.Error);",
            "lineNumber": 82
          },
          {
            "text": "                    logging.AddFile(_config?.GetSection(\"Logging\"));",
            "lineNumber": 83
          },
          {
            "text": "                });",
            "lineNumber": 84
          },
          {
            "text": "#endif",
            "lineNumber": 85
          },
          {
            "text": "        }",
            "lineNumber": 86
          },
          {
            "text": "    }",
            "lineNumber": 87
          },
          {
            "text": "}",
            "lineNumber": 88
          }
        ]
      },
      "score": 0.3188565969467163
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 63
          }
        },
        "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Opc.Ua;\nusing Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaConnectionService(\n        ILogger&lt;OpcUaConnectionService&gt; logger,\n        IOptions&lt;OpcUaSettings&gt; settings,\n        ISessionFactory sessionFactory)\n        : IOpcUaConnectionService\n    {\n        public bool IsConnected =&gt; Session?.Connected == true;\n        public Session? Session { get; private set; }\n        public event EventHandler&lt;bool&gt;? ConnectionChanged;\n        private readonly OpcUaSettings _settings = settings.Value;\n        private readonly SemaphoreSlim _sessionLock = new(1, 1);\n        private readonly Lock _reconnectLock = new();\n        private SessionReconnectHandler? _reconnectHandler;\n        private Opc.Ua.ApplicationConfiguration? _appConfig;\n        private CancellationTokenSource? _cts;\n        private Task? _connectLoopTask;\n        private bool _lastConnectionState;\n        private int _currentDelayMs;\n\n        public async Task StartAsync(CancellationToken ct = default)\n        {\n            if (_connectLoopTask is { IsCompleted: false })\n            {\n                return;\n            }\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            await InitializeApplicationConfigAsync();\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\n        }\n\n        public async Task StopAsync()\n        {\n            await CancelConnectionAsync();\n            DisposeReconnectHandler();\n            await _sessionLock.WaitAsync();\n            try\n            {\n                await CloseSessionAsync();\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n            NotifyConnectionChanged(false);\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            await StopAsync();\n            _sessionLock.Dispose();\n        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {\n            _appConfig = new Opc.Ua.ApplicationConfiguration",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 2
          },
          {
            "text": "using Microsoft.Extensions.Options;",
            "lineNumber": 3
          },
          {
            "text": "using Opc.Ua;",
            "lineNumber": 4
          },
          {
            "text": "using Opc.Ua.Client;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 7
          },
          {
            "text": "{",
            "lineNumber": 8
          },
          {
            "text": "    public class OpcUaConnectionService(",
            "lineNumber": 9
          },
          {
            "text": "        ILogger&lt;OpcUaConnectionService&gt; logger,",
            "lineNumber": 10
          },
          {
            "text": "        IOptions&lt;OpcUaSettings&gt; settings,",
            "lineNumber": 11
          },
          {
            "text": "        ISessionFactory sessionFactory)",
            "lineNumber": 12
          },
          {
            "text": "        : IOpcUaConnectionService",
            "lineNumber": 13
          },
          {
            "text": "    {",
            "lineNumber": 14
          },
          {
            "text": "        public bool IsConnected =&gt; Session?.Connected == true;",
            "lineNumber": 15
          },
          {
            "text": "        public Session? Session { get; private set; }",
            "lineNumber": 16
          },
          {
            "text": "        public event EventHandler&lt;bool&gt;? ConnectionChanged;",
            "lineNumber": 17
          },
          {
            "text": "        private readonly OpcUaSettings _settings = settings.Value;",
            "lineNumber": 18
          },
          {
            "text": "        private readonly SemaphoreSlim _sessionLock = new(1, 1);",
            "lineNumber": 19
          },
          {
            "text": "        private readonly Lock _reconnectLock = new();",
            "lineNumber": 20
          },
          {
            "text": "        private SessionReconnectHandler? _reconnectHandler;",
            "lineNumber": 21
          },
          {
            "text": "        private Opc.Ua.ApplicationConfiguration? _appConfig;",
            "lineNumber": 22
          },
          {
            "text": "        private CancellationTokenSource? _cts;",
            "lineNumber": 23
          },
          {
            "text": "        private Task? _connectLoopTask;",
            "lineNumber": 24
          },
          {
            "text": "        private bool _lastConnectionState;",
            "lineNumber": 25
          },
          {
            "text": "        private int _currentDelayMs;",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "        public async Task StartAsync(CancellationToken ct = default)",
            "lineNumber": 28
          },
          {
            "text": "        {",
            "lineNumber": 29
          },
          {
            "text": "            if (_connectLoopTask is { IsCompleted: false })",
            "lineNumber": 30
          },
          {
            "text": "            {",
            "lineNumber": 31
          },
          {
            "text": "                return;",
            "lineNumber": 32
          },
          {
            "text": "            }",
            "lineNumber": 33
          },
          {
            "text": "            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);",
            "lineNumber": 34
          },
          {
            "text": "            await InitializeApplicationConfigAsync();",
            "lineNumber": 35
          },
          {
            "text": "            _connectLoopTask = ConnectLoopAsync(_cts.Token);",
            "lineNumber": 36
          },
          {
            "text": "        }",
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "        public async Task StopAsync()",
            "lineNumber": 39
          },
          {
            "text": "        {",
            "lineNumber": 40
          },
          {
            "text": "            await CancelConnectionAsync();",
            "lineNumber": 41
          },
          {
            "text": "            DisposeReconnectHandler();",
            "lineNumber": 42
          },
          {
            "text": "            await _sessionLock.WaitAsync();",
            "lineNumber": 43
          },
          {
            "text": "            try",
            "lineNumber": 44
          },
          {
            "text": "            {",
            "lineNumber": 45
          },
          {
            "text": "                await CloseSessionAsync();",
            "lineNumber": 46
          },
          {
            "text": "            }",
            "lineNumber": 47
          },
          {
            "text": "            finally",
            "lineNumber": 48
          },
          {
            "text": "            {",
            "lineNumber": 49
          },
          {
            "text": "                _sessionLock.Release();",
            "lineNumber": 50
          },
          {
            "text": "            }",
            "lineNumber": 51
          },
          {
            "text": "            NotifyConnectionChanged(false);",
            "lineNumber": 52
          },
          {
            "text": "        }",
            "lineNumber": 53
          },
          {
            "lineNumber": 54
          },
          {
            "text": "        public async ValueTask DisposeAsync()",
            "lineNumber": 55
          },
          {
            "text": "        {",
            "lineNumber": 56
          },
          {
            "text": "            await StopAsync();",
            "lineNumber": 57
          },
          {
            "text": "            _sessionLock.Dispose();",
            "lineNumber": 58
          },
          {
            "text": "        }",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "        private async Task InitializeApplicationConfigAsync()",
            "lineNumber": 61
          },
          {
            "text": "        {",
            "lineNumber": 62
          },
          {
            "text": "            _appConfig = new Opc.Ua.ApplicationConfiguration",
            "lineNumber": 63
          }
        ]
      },
      "score": 0.29809001088142395
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 299
          },
          "endPosition": {
            "line": 317
          }
        },
        "contents": "        {\n            var session = await sessionFactory.CreateAsync(\n                _appConfig,\n                configEndpoint,\n                updateBeforeConnect: false,\n                sessionName: _settings.ApplicationName,\n                sessionTimeout: (uint)_settings.SessionTimeoutMs,\n                identity: new UserIdentity(new AnonymousIdentityToken()),\n                preferredLocales: null,\n                ct).ConfigureAwait(false);\n            return session switch\n            {\n                Session s =&gt; s,\n                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")\n            };\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 300
          },
          {
            "text": "            var session = await sessionFactory.CreateAsync(",
            "lineNumber": 301
          },
          {
            "text": "                _appConfig,",
            "lineNumber": 302
          },
          {
            "text": "                configEndpoint,",
            "lineNumber": 303
          },
          {
            "text": "                updateBeforeConnect: false,",
            "lineNumber": 304
          },
          {
            "text": "                sessionName: _settings.ApplicationName,",
            "lineNumber": 305
          },
          {
            "text": "                sessionTimeout: (uint)_settings.SessionTimeoutMs,",
            "lineNumber": 306
          },
          {
            "text": "                identity: new UserIdentity(new AnonymousIdentityToken()),",
            "lineNumber": 307
          },
          {
            "text": "                preferredLocales: null,",
            "lineNumber": 308
          },
          {
            "text": "                ct).ConfigureAwait(false);",
            "lineNumber": 309
          },
          {
            "text": "            return session switch",
            "lineNumber": 310
          },
          {
            "text": "            {",
            "lineNumber": 311
          },
          {
            "text": "                Session s =&gt; s,",
            "lineNumber": 312
          },
          {
            "text": "                _ =&gt; throw new InvalidOperationException($\"SessionFactory returned unexpected type: {session.GetType().Name}\")",
            "lineNumber": 313
          },
          {
            "text": "            };",
            "lineNumber": 314
          },
          {
            "text": "        }",
            "lineNumber": 315
          },
          {
            "text": "    }",
            "lineNumber": 316
          },
          {
            "text": "}",
            "lineNumber": 317
          }
        ]
      },
      "score": 0.2980637550354004
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\appsettings.json",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 29
          }
        },
        "contents": "{\n  \"Paths\": {\n    \"PathToTestSteps\": \"D:/TestSteps\",\n    \"PathToTestsSequence\": \"D:/TestSequences\"\n  },\n  \"Logging\": {\n    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",\n    \"RetainedFileCountLimit\": \"5\",\n    \"LogLevel\": {\n      \"Default\": \"Warning\"\n    }\n  },\n  \"ConnectionPrinter\": {\n    \"Host\": \"192.168.0.60\",\n    \"Port\": 6101\n  },\n  \"ConnectionWeigher\": {\n    \"Host\": \"192.168.0.31\",\n    \"Port\": 5001\n  },\n  \"OpcUa\": {\n    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",\n    \"ApplicationName\": \"FinalTestHybrid\",\n    \"ReconnectIntervalMs\": 5000,\n    \"SessionTimeoutMs\": 60000\n  }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "{",
            "lineNumber": 1
          },
          {
            "text": "  \"Paths\": {",
            "lineNumber": 2
          },
          {
            "text": "    \"PathToTestSteps\": \"D:/TestSteps\",",
            "lineNumber": 3
          },
          {
            "text": "    \"PathToTestsSequence\": \"D:/TestSequences\"",
            "lineNumber": 4
          },
          {
            "text": "  },",
            "lineNumber": 5
          },
          {
            "text": "  \"Logging\": {",
            "lineNumber": 6
          },
          {
            "text": "    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",",
            "lineNumber": 7
          },
          {
            "text": "    \"RetainedFileCountLimit\": \"5\",",
            "lineNumber": 8
          },
          {
            "text": "    \"LogLevel\": {",
            "lineNumber": 9
          },
          {
            "text": "      \"Default\": \"Warning\"",
            "lineNumber": 10
          },
          {
            "text": "    }",
            "lineNumber": 11
          },
          {
            "text": "  },",
            "lineNumber": 12
          },
          {
            "text": "  \"ConnectionPrinter\": {",
            "lineNumber": 13
          },
          {
            "text": "    \"Host\": \"192.168.0.60\",",
            "lineNumber": 14
          },
          {
            "text": "    \"Port\": 6101",
            "lineNumber": 15
          },
          {
            "text": "  },",
            "lineNumber": 16
          },
          {
            "text": "  \"ConnectionWeigher\": {",
            "lineNumber": 17
          },
          {
            "text": "    \"Host\": \"192.168.0.31\",",
            "lineNumber": 18
          },
          {
            "text": "    \"Port\": 5001",
            "lineNumber": 19
          },
          {
            "text": "  },",
            "lineNumber": 20
          },
          {
            "text": "  \"OpcUa\": {",
            "lineNumber": 21
          },
          {
            "text": "    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",",
            "lineNumber": 22
          },
          {
            "text": "    \"ApplicationName\": \"FinalTestHybrid\",",
            "lineNumber": 23
          },
          {
            "text": "    \"ReconnectIntervalMs\": 5000,",
            "lineNumber": 24
          },
          {
            "text": "    \"SessionTimeoutMs\": 60000",
            "lineNumber": 25
          },
          {
            "text": "  }",
            "lineNumber": 26
          },
          {
            "text": "}",
            "lineNumber": 27
          }
        ]
      },
      "score": 0.2206180989742279
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Program.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 21,
            "column": 1
          }
        },
        "contents": "namespace Final_Test_Hybrid\n{\n    internal static class Program\n    {\n        /// &lt;summary&gt;\n        ///  The main entry point for the application.\n        /// &lt;/summary&gt;\n        [STAThread]\n        static void Main()\n        {\n            // To customize application configuration such as set high DPI settings or default font,\n            // see https://aka.ms/applicationconfiguration.\n            \n            // Set EPPlus license context to NonCommercial using the static License property\n            // This is required for EPPlus 8+\n            OfficeOpenXml.ExcelPackage.License.SetNonCommercialPersonal(\"FinalTestHybrid\");\n\n            ApplicationConfiguration.Initialize();\n            Application.Run(new Form1());\n        }\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "namespace Final_Test_Hybrid",
            "lineNumber": 1
          },
          {
            "text": "{",
            "lineNumber": 2
          },
          {
            "text": "    internal static class Program",
            "lineNumber": 3
          },
          {
            "text": "    {",
            "lineNumber": 4
          },
          {
            "text": "        /// &lt;summary&gt;",
            "lineNumber": 5
          },
          {
            "text": "        ///  The main entry point for the application.",
            "lineNumber": 6
          },
          {
            "text": "        /// &lt;/summary&gt;",
            "lineNumber": 7
          },
          {
            "text": "        [STAThread]",
            "lineNumber": 8
          },
          {
            "text": "        static void Main()",
            "lineNumber": 9
          },
          {
            "text": "        {",
            "lineNumber": 10
          },
          {
            "text": "            // To customize application configuration such as set high DPI settings or default font,",
            "lineNumber": 11
          },
          {
            "text": "            // see https://aka.ms/applicationconfiguration.",
            "lineNumber": 12
          },
          {
            "text": "            ",
            "lineNumber": 13
          },
          {
            "text": "            // Set EPPlus license context to NonCommercial using the static License property",
            "lineNumber": 14
          },
          {
            "text": "            // This is required for EPPlus 8+",
            "lineNumber": 15
          },
          {
            "text": "            OfficeOpenXml.ExcelPackage.License.SetNonCommercialPersonal(\"FinalTestHybrid\");",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "            ApplicationConfiguration.Initialize();",
            "lineNumber": 18
          },
          {
            "text": "            Application.Run(new Form1());",
            "lineNumber": 19
          },
          {
            "text": "        }",
            "lineNumber": 20
          },
          {
            "text": "    }",
            "lineNumber": 21
          },
          {
            "text": "}",
            "lineNumber": 22
          }
        ]
      },
      "score": 0.1906125545501709
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 134
          },
          "endPosition": {
            "line": 182
          }
        },
        "contents": "        {\n            await _sessionLock.WaitAsync(ct);\n            try\n            {\n                DisposeReconnectHandler();\n                await CloseSessionAsync();\n                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);\n                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);\n                var configEndpoint = new ConfiguredEndpoint(null, endpoint);\n                Session = await CreateSessionAsync(configEndpoint, ct);\n                Session.KeepAlive += OnSessionKeepAlive;\n                logger.LogInformation(\"Connected to OPC UA server\");\n                NotifyConnectionChanged(true);\n            }\n            catch (OperationCanceledException)\n            {\n                // Cancellation is expected during shutdown\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to connect to OPC UA server\");\n                NotifyConnectionChanged(false);\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n        }\n\n        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)\n        {\n            if (ShouldSkipKeepAlive(e))\n            {\n                return;\n            }\n            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);\n            NotifyConnectionChanged(false);\n            StartReconnectIfNeeded();\n        }\n\n        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)\n        {\n            return e.Status == null || ServiceResult.IsGood(e.Status);\n        }\n\n        private void StartReconnectIfNeeded()\n        {\n            lock (_reconnectLock)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 135
          },
          {
            "text": "            await _sessionLock.WaitAsync(ct);",
            "lineNumber": 136
          },
          {
            "text": "            try",
            "lineNumber": 137
          },
          {
            "text": "            {",
            "lineNumber": 138
          },
          {
            "text": "                DisposeReconnectHandler();",
            "lineNumber": 139
          },
          {
            "text": "                await CloseSessionAsync();",
            "lineNumber": 140
          },
          {
            "text": "                logger.LogInformation(\"Connecting to OPC UA server: {Endpoint}\", _settings.EndpointUrl);",
            "lineNumber": 141
          },
          {
            "text": "                var endpoint = await CoreClientUtils.SelectEndpointAsync(_appConfig, _settings.EndpointUrl, useSecurity: false, ct: ct);",
            "lineNumber": 142
          },
          {
            "text": "                var configEndpoint = new ConfiguredEndpoint(null, endpoint);",
            "lineNumber": 143
          },
          {
            "text": "                Session = await CreateSessionAsync(configEndpoint, ct);",
            "lineNumber": 144
          },
          {
            "text": "                Session.KeepAlive += OnSessionKeepAlive;",
            "lineNumber": 145
          },
          {
            "text": "                logger.LogInformation(\"Connected to OPC UA server\");",
            "lineNumber": 146
          },
          {
            "text": "                NotifyConnectionChanged(true);",
            "lineNumber": 147
          },
          {
            "text": "            }",
            "lineNumber": 148
          },
          {
            "text": "            catch (OperationCanceledException)",
            "lineNumber": 149
          },
          {
            "text": "            {",
            "lineNumber": 150
          },
          {
            "text": "                // Cancellation is expected during shutdown",
            "lineNumber": 151
          },
          {
            "text": "            }",
            "lineNumber": 152
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 153
          },
          {
            "text": "            {",
            "lineNumber": 154
          },
          {
            "text": "                logger.LogError(ex, \"Failed to connect to OPC UA server\");",
            "lineNumber": 155
          },
          {
            "text": "                NotifyConnectionChanged(false);",
            "lineNumber": 156
          },
          {
            "text": "            }",
            "lineNumber": 157
          },
          {
            "text": "            finally",
            "lineNumber": 158
          },
          {
            "text": "            {",
            "lineNumber": 159
          },
          {
            "text": "                _sessionLock.Release();",
            "lineNumber": 160
          },
          {
            "text": "            }",
            "lineNumber": 161
          },
          {
            "text": "        }",
            "lineNumber": 162
          },
          {
            "lineNumber": 163
          },
          {
            "text": "        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)",
            "lineNumber": 164
          },
          {
            "text": "        {",
            "lineNumber": 165
          },
          {
            "text": "            if (ShouldSkipKeepAlive(e))",
            "lineNumber": 166
          },
          {
            "text": "            {",
            "lineNumber": 167
          },
          {
            "text": "                return;",
            "lineNumber": 168
          },
          {
            "text": "            }",
            "lineNumber": 169
          },
          {
            "text": "            logger.LogWarning(\"Connection lost. Status: {Status}\", e.Status);",
            "lineNumber": 170
          },
          {
            "text": "            NotifyConnectionChanged(false);",
            "lineNumber": 171
          },
          {
            "text": "            StartReconnectIfNeeded();",
            "lineNumber": 172
          },
          {
            "text": "        }",
            "lineNumber": 173
          },
          {
            "lineNumber": 174
          },
          {
            "text": "        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)",
            "lineNumber": 175
          },
          {
            "text": "        {",
            "lineNumber": 176
          },
          {
            "text": "            return e.Status == null || ServiceResult.IsGood(e.Status);",
            "lineNumber": 177
          },
          {
            "text": "        }",
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "        private void StartReconnectIfNeeded()",
            "lineNumber": 180
          },
          {
            "text": "        {",
            "lineNumber": 181
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 182
          }
        ]
      },
      "score": 0.18065476417541504
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Final_Test_Hybrid.csproj",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 36,
            "column": 10
          }
        },
        "contents": "&lt;Project Sdk=\"Microsoft.NET.Sdk.Razor\"&gt;\n\n  &lt;PropertyGroup&gt;\n    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;\n    &lt;TargetFramework&gt;net10.0-windows&lt;/TargetFramework&gt;\n    &lt;Nullable&gt;enable&lt;/Nullable&gt;\n    &lt;UseWindowsForms&gt;true&lt;/UseWindowsForms&gt;\n    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;\n\t &lt;UseWPF&gt;false&lt;/UseWPF&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"EPPlus\" Version=\"8.3.1\" /&gt;\n    &lt;PackageReference Include=\"Microsoft.AspNetCore.Components.WebView.WindowsForms\" Version=\"10.0.10\" /&gt;\n    &lt;PackageReference Include=\"Microsoft.Extensions.Logging\" Version=\"10.0.0\" /&gt;\n    &lt;PackageReference Include=\"Microsoft.Extensions.Logging.Console\" Version=\"10.0.0\" /&gt;\n    &lt;PackageReference Include=\"Microsoft.Extensions.Logging.Debug\" Version=\"10.0.0\" /&gt;\n    &lt;PackageReference Include=\"OPCFoundation.NetStandard.Opc.Ua.Client\" Version=\"1.5.377.22\" /&gt;\n    &lt;PackageReference Include=\"Radzen.Blazor\" Version=\"8.3.2\" /&gt;\n    &lt;PackageReference Include=\"Serilog.Extensions.Logging\" Version=\"10.0.0\" /&gt;\n    &lt;PackageReference Include=\"Serilog.Extensions.Logging.File\" Version=\"9.0.0-dev-02303\" /&gt;\n  &lt;/ItemGroup&gt;\n\n  &lt;ItemGroup&gt;\n    &lt;Content Update=\"wwwroot\\images\\GreenLamp.png\"&gt;\n      &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;\n    &lt;/Content&gt;\n    &lt;Content Update=\"wwwroot\\images\\RedLamp.png\"&gt;\n      &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;\n    &lt;/Content&gt;\n  &lt;/ItemGroup&gt;\n\n  &lt;ItemGroup&gt;\n    &lt;Folder Include=\"Services\\Settings\\\" /&gt;\n  &lt;/ItemGroup&gt;\n\n&lt;/Project&gt;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "&lt;Project Sdk=\"Microsoft.NET.Sdk.Razor\"&gt;",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "  &lt;PropertyGroup&gt;",
            "lineNumber": 3
          },
          {
            "text": "    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;",
            "lineNumber": 4
          },
          {
            "text": "    &lt;TargetFramework&gt;net10.0-windows&lt;/TargetFramework&gt;",
            "lineNumber": 5
          },
          {
            "text": "    &lt;Nullable&gt;enable&lt;/Nullable&gt;",
            "lineNumber": 6
          },
          {
            "text": "    &lt;UseWindowsForms&gt;true&lt;/UseWindowsForms&gt;",
            "lineNumber": 7
          },
          {
            "text": "    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;",
            "lineNumber": 8
          },
          {
            "text": "\t &lt;UseWPF&gt;false&lt;/UseWPF&gt;",
            "lineNumber": 9
          },
          {
            "text": "  &lt;/PropertyGroup&gt;",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "  &lt;ItemGroup&gt;",
            "lineNumber": 12
          },
          {
            "text": "    &lt;PackageReference Include=\"EPPlus\" Version=\"8.3.1\" /&gt;",
            "lineNumber": 13
          },
          {
            "text": "    &lt;PackageReference Include=\"Microsoft.AspNetCore.Components.WebView.WindowsForms\" Version=\"10.0.10\" /&gt;",
            "lineNumber": 14
          },
          {
            "text": "    &lt;PackageReference Include=\"Microsoft.Extensions.Logging\" Version=\"10.0.0\" /&gt;",
            "lineNumber": 15
          },
          {
            "text": "    &lt;PackageReference Include=\"Microsoft.Extensions.Logging.Console\" Version=\"10.0.0\" /&gt;",
            "lineNumber": 16
          },
          {
            "text": "    &lt;PackageReference Include=\"Microsoft.Extensions.Logging.Debug\" Version=\"10.0.0\" /&gt;",
            "lineNumber": 17
          },
          {
            "text": "    &lt;PackageReference Include=\"OPCFoundation.NetStandard.Opc.Ua.Client\" Version=\"1.5.377.22\" /&gt;",
            "lineNumber": 18
          },
          {
            "text": "    &lt;PackageReference Include=\"Radzen.Blazor\" Version=\"8.3.2\" /&gt;",
            "lineNumber": 19
          },
          {
            "text": "    &lt;PackageReference Include=\"Serilog.Extensions.Logging\" Version=\"10.0.0\" /&gt;",
            "lineNumber": 20
          },
          {
            "text": "    &lt;PackageReference Include=\"Serilog.Extensions.Logging.File\" Version=\"9.0.0-dev-02303\" /&gt;",
            "lineNumber": 21
          },
          {
            "text": "  &lt;/ItemGroup&gt;",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "  &lt;ItemGroup&gt;",
            "lineNumber": 24
          },
          {
            "text": "    &lt;Content Update=\"wwwroot\\images\\GreenLamp.png\"&gt;",
            "lineNumber": 25
          },
          {
            "text": "      &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;",
            "lineNumber": 26
          },
          {
            "text": "    &lt;/Content&gt;",
            "lineNumber": 27
          },
          {
            "text": "    &lt;Content Update=\"wwwroot\\images\\RedLamp.png\"&gt;",
            "lineNumber": 28
          },
          {
            "text": "      &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;",
            "lineNumber": 29
          },
          {
            "text": "    &lt;/Content&gt;",
            "lineNumber": 30
          },
          {
            "text": "  &lt;/ItemGroup&gt;",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "  &lt;ItemGroup&gt;",
            "lineNumber": 33
          },
          {
            "text": "    &lt;Folder Include=\"Services\\Settings\\\" /&gt;",
            "lineNumber": 34
          },
          {
            "text": "  &lt;/ItemGroup&gt;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "&lt;/Project&gt;",
            "lineNumber": 37
          }
        ]
      },
      "score": 0.17687714099884033
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Components\\Engineer\\Sequence\\TestSequenceEditor.razor.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 44
          }
        },
        "contents": "using Final_Test_Hybrid.Models;\nusing Final_Test_Hybrid.Services.IO;\nusing Microsoft.AspNetCore.Components;\nusing Microsoft.JSInterop;\nusing Radzen.Blazor;\n\nnamespace Final_Test_Hybrid.Components.Engineer.Sequence;\n\npublic partial class TestSequenceEditor : IAsyncDisposable\n{\n    [Inject]\n    public required IFilePickerService FilePickerService { get; set; }\n    [Inject]\n    public required IJSRuntime JsRuntime { get; set; }\n    private RadzenDataGrid&lt;SequenceRow&gt;? _grid;\n    private List&lt;SequenceRow&gt; _rows = [];\n    private readonly CancellationTokenSource _cts = new();\n    private readonly int _columnCount = 4;\n    private bool _disposed;\n    private bool _isLoading = true;\n    private bool _isFileActive;\n\n    protected override async Task OnInitializedAsync()\n    {\n        await Task.Yield();\n        _rows = TestSequenceService.InitializeRows(20, _columnCount);\n        _isFileActive = !string.IsNullOrEmpty(TestSequenceService.CurrentFilePath);\n        _isLoading = false;\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        _disposed = true;\n        await _cts.CancelAsync();\n        _cts.Dispose();\n        ResetServiceState();\n    }\n\n    private void ResetServiceState()\n    {\n        TestSequenceService.CurrentFilePath = null;\n        TestSequenceService.CurrentFileName = null;\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Models;",
            "lineNumber": 1
          },
          {
            "text": "using Final_Test_Hybrid.Services.IO;",
            "lineNumber": 2
          },
          {
            "text": "using Microsoft.AspNetCore.Components;",
            "lineNumber": 3
          },
          {
            "text": "using Microsoft.JSInterop;",
            "lineNumber": 4
          },
          {
            "text": "using Radzen.Blazor;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "namespace Final_Test_Hybrid.Components.Engineer.Sequence;",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "public partial class TestSequenceEditor : IAsyncDisposable",
            "lineNumber": 9
          },
          {
            "text": "{",
            "lineNumber": 10
          },
          {
            "text": "    [Inject]",
            "lineNumber": 11
          },
          {
            "text": "    public required IFilePickerService FilePickerService { get; set; }",
            "lineNumber": 12
          },
          {
            "text": "    [Inject]",
            "lineNumber": 13
          },
          {
            "text": "    public required IJSRuntime JsRuntime { get; set; }",
            "lineNumber": 14
          },
          {
            "text": "    private RadzenDataGrid&lt;SequenceRow&gt;? _grid;",
            "lineNumber": 15
          },
          {
            "text": "    private List&lt;SequenceRow&gt; _rows = [];",
            "lineNumber": 16
          },
          {
            "text": "    private readonly CancellationTokenSource _cts = new();",
            "lineNumber": 17
          },
          {
            "text": "    private readonly int _columnCount = 4;",
            "lineNumber": 18
          },
          {
            "text": "    private bool _disposed;",
            "lineNumber": 19
          },
          {
            "text": "    private bool _isLoading = true;",
            "lineNumber": 20
          },
          {
            "text": "    private bool _isFileActive;",
            "lineNumber": 21
          },
          {
            "lineNumber": 22
          },
          {
            "text": "    protected override async Task OnInitializedAsync()",
            "lineNumber": 23
          },
          {
            "text": "    {",
            "lineNumber": 24
          },
          {
            "text": "        await Task.Yield();",
            "lineNumber": 25
          },
          {
            "text": "        _rows = TestSequenceService.InitializeRows(20, _columnCount);",
            "lineNumber": 26
          },
          {
            "text": "        _isFileActive = !string.IsNullOrEmpty(TestSequenceService.CurrentFilePath);",
            "lineNumber": 27
          },
          {
            "text": "        _isLoading = false;",
            "lineNumber": 28
          },
          {
            "text": "    }",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "    public async ValueTask DisposeAsync()",
            "lineNumber": 31
          },
          {
            "text": "    {",
            "lineNumber": 32
          },
          {
            "text": "        _disposed = true;",
            "lineNumber": 33
          },
          {
            "text": "        await _cts.CancelAsync();",
            "lineNumber": 34
          },
          {
            "text": "        _cts.Dispose();",
            "lineNumber": 35
          },
          {
            "text": "        ResetServiceState();",
            "lineNumber": 36
          },
          {
            "text": "    }",
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "    private void ResetServiceState()",
            "lineNumber": 39
          },
          {
            "text": "    {",
            "lineNumber": 40
          },
          {
            "text": "        TestSequenceService.CurrentFilePath = null;",
            "lineNumber": 41
          },
          {
            "text": "        TestSequenceService.CurrentFileName = null;",
            "lineNumber": 42
          },
          {
            "text": "    }",
            "lineNumber": 43
          },
          {
            "text": "}",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.1768176555633545
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\bin\\Debug\\net10.0-windows\\appsettings.json",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 29
          }
        },
        "contents": "{\n  \"Paths\": {\n    \"PathToTestSteps\": \"D:/TestSteps\",\n    \"PathToTestsSequence\": \"D:/TestSequences\"\n  },\n  \"Logging\": {\n    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",\n    \"RetainedFileCountLimit\": \"5\",\n    \"LogLevel\": {\n      \"Default\": \"Warning\"\n    }\n  },\n  \"ConnectionPrinter\": {\n    \"Host\": \"192.168.0.60\",\n    \"Port\": 6101\n  },\n  \"ConnectionWeigher\": {\n    \"Host\": \"192.168.0.31\",\n    \"Port\": 5001\n  },\n  \"OpcUa\": {\n    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",\n    \"ApplicationName\": \"FinalTestHybrid\",\n    \"ReconnectIntervalMs\": 5000,\n    \"SessionTimeoutMs\": 60000\n  }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "{",
            "lineNumber": 1
          },
          {
            "text": "  \"Paths\": {",
            "lineNumber": 2
          },
          {
            "text": "    \"PathToTestSteps\": \"D:/TestSteps\",",
            "lineNumber": 3
          },
          {
            "text": "    \"PathToTestsSequence\": \"D:/TestSequences\"",
            "lineNumber": 4
          },
          {
            "text": "  },",
            "lineNumber": 5
          },
          {
            "text": "  \"Logging\": {",
            "lineNumber": 6
          },
          {
            "text": "    \"PathFormat\": \"D:/Logs/log-{Date}.txt\",",
            "lineNumber": 7
          },
          {
            "text": "    \"RetainedFileCountLimit\": \"5\",",
            "lineNumber": 8
          },
          {
            "text": "    \"LogLevel\": {",
            "lineNumber": 9
          },
          {
            "text": "      \"Default\": \"Warning\"",
            "lineNumber": 10
          },
          {
            "text": "    }",
            "lineNumber": 11
          },
          {
            "text": "  },",
            "lineNumber": 12
          },
          {
            "text": "  \"ConnectionPrinter\": {",
            "lineNumber": 13
          },
          {
            "text": "    \"Host\": \"192.168.0.60\",",
            "lineNumber": 14
          },
          {
            "text": "    \"Port\": 6101",
            "lineNumber": 15
          },
          {
            "text": "  },",
            "lineNumber": 16
          },
          {
            "text": "  \"ConnectionWeigher\": {",
            "lineNumber": 17
          },
          {
            "text": "    \"Host\": \"192.168.0.31\",",
            "lineNumber": 18
          },
          {
            "text": "    \"Port\": 5001",
            "lineNumber": 19
          },
          {
            "text": "  },",
            "lineNumber": 20
          },
          {
            "text": "  \"OpcUa\": {",
            "lineNumber": 21
          },
          {
            "text": "    \"EndpointUrl\": \"opc.tcp://192.168.1.100:4840\",",
            "lineNumber": 22
          },
          {
            "text": "    \"ApplicationName\": \"FinalTestHybrid\",",
            "lineNumber": 23
          },
          {
            "text": "    \"ReconnectIntervalMs\": 5000,",
            "lineNumber": 24
          },
          {
            "text": "    \"SessionTimeoutMs\": 60000",
            "lineNumber": 25
          },
          {
            "text": "  }",
            "lineNumber": 26
          },
          {
            "text": "}",
            "lineNumber": 27
          }
        ]
      },
      "score": 0.172678604722023
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\MyComponent.razor",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 21,
            "column": 44
          }
        },
        "contents": "@using Final_Test_Hybrid.Components.Indicators\n@using Final_Test_Hybrid.Components.Engineer\n@using Final_Test_Hybrid.Components.Overview\n\n&lt;RadzenDialog /&gt;\n&lt;RadzenNotification /&gt;\n&lt;RadzenTooltip /&gt;\n&lt;RadzenContextMenu /&gt;\n\n&lt;RadzenStack Orientation=\"Orientation.Vertical\" Gap=\"0\" class=\"app-stack-vertical\"&gt;\n    &lt;div class=\"app-tabs-shell\"&gt;\n        &lt;RadzenTabs RenderMode=\"TabRenderMode.Client\" @bind-SelectedIndex=\"@selectedIndex\" class=\"app-tabs-90\"&gt;\n            &lt;Tabs&gt;\n                &lt;RadzenTabsItem Text=\"Главный экран\"&gt;\n                    &lt;div style=\"height: 100%; padding: 0 20px;\"&gt;\n                        &lt;RadzenStack Orientation=\"Orientation.Vertical\" Style=\"height: 100%; gap: 12px;\"&gt;\n                            &lt;RadzenCard Class=\"header-card\"&gt;\n                                &lt;ChildContent&gt;\n                                    &lt;div class=\"header-grid\"&gt;\n                                        @* Блок 1: четыре поля *@\n                                        &lt;div class=\"header-block header-block-left\"&gt;\n                                            ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "@using Final_Test_Hybrid.Components.Indicators",
            "lineNumber": 1
          },
          {
            "text": "@using Final_Test_Hybrid.Components.Engineer",
            "lineNumber": 2
          },
          {
            "text": "@using Final_Test_Hybrid.Components.Overview",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "&lt;RadzenDialog /&gt;",
            "lineNumber": 5
          },
          {
            "text": "&lt;RadzenNotification /&gt;",
            "lineNumber": 6
          },
          {
            "text": "&lt;RadzenTooltip /&gt;",
            "lineNumber": 7
          },
          {
            "text": "&lt;RadzenContextMenu /&gt;",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "&lt;RadzenStack Orientation=\"Orientation.Vertical\" Gap=\"0\" class=\"app-stack-vertical\"&gt;",
            "lineNumber": 10
          },
          {
            "text": "    &lt;div class=\"app-tabs-shell\"&gt;",
            "lineNumber": 11
          },
          {
            "text": "        &lt;RadzenTabs RenderMode=\"TabRenderMode.Client\" @bind-SelectedIndex=\"@selectedIndex\" class=\"app-tabs-90\"&gt;",
            "lineNumber": 12
          },
          {
            "text": "            &lt;Tabs&gt;",
            "lineNumber": 13
          },
          {
            "text": "                &lt;RadzenTabsItem Text=\"Главный экран\"&gt;",
            "lineNumber": 14
          },
          {
            "text": "                    &lt;div style=\"height: 100%; padding: 0 20px;\"&gt;",
            "lineNumber": 15
          },
          {
            "text": "                        &lt;RadzenStack Orientation=\"Orientation.Vertical\" Style=\"height: 100%; gap: 12px;\"&gt;",
            "lineNumber": 16
          },
          {
            "text": "                            &lt;RadzenCard Class=\"header-card\"&gt;",
            "lineNumber": 17
          },
          {
            "text": "                                &lt;ChildContent&gt;",
            "lineNumber": 18
          },
          {
            "text": "                                    &lt;div class=\"header-grid\"&gt;",
            "lineNumber": 19
          },
          {
            "text": "                                        @* Блок 1: четыре поля *@",
            "lineNumber": 20
          },
          {
            "text": "                                        &lt;div class=\"header-block header-block-left\"&gt;",
            "lineNumber": 21
          },
          {
            "text": "                                            ",
            "lineNumber": 22
          }
        ]
      },
      "score": 0.1712276041507721
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\Sequence\\TestSequenceService.cs",
        "range": {
          "startPosition": {
            "line": 61
          },
          "endPosition": {
            "line": 116
          }
        },
        "contents": "    {\n        await sequenceExcelService.SaveSequenceAsync(path, rows).ConfigureAwait(false);\n    }\n\n    public async Task&lt;List&lt;SequenceRow&gt;&gt; LoadFromExcelAsync(string path, int columnCount)\n    {\n        return await sequenceExcelService.LoadSequenceAsync(path, columnCount).ConfigureAwait(false);\n    }\n\n    public string GetTestsSequencePath()\n    {\n        var path = GetRequiredConfigPath(\"Paths:PathToTestsSequence\");\n        return GetOrCreateDirectory(path);\n    }\n\n    private string GetOrCreateDirectory(string path)\n    {\n        return Directory.Exists(path) ? path : CreateDirectory(path);\n    }\n\n    private string CreateDirectory(string path)\n    {\n        try\n        {\n            Directory.CreateDirectory(path);\n            return path;\n        }\n        catch (Exception ex)\n        {\n            logger.LogError(ex, \"Ошибка пути: Не удалось создать директорию: {Path}\", path);\n            throw new IOException($\"Ошибка пути: Не удалось создать директорию: {path}. {ex.Message}\", ex);\n        }\n    }\n\n    public string GetValidRootPath()\n    {\n        var path = GetRequiredConfigPath(\"Paths:PathToTestSteps\");\n        ValidatePathExists(path);\n        return path;\n    }\n\n    private string GetRequiredConfigPath(string key)\n    {\n        var path = configuration[key];\n        if (!string.IsNullOrEmpty(path))\n        {\n            return path;\n        }\n        logger.LogError(\"Ошибка конфигурации: {Key} отсутствует в appsettings.json\", key);\n        throw new InvalidOperationException($\"Ошибка конфигурации: {key} отсутствует в appsettings.json\");\n    }\n\n    private void ValidatePathExists(string path)\n    {\n        if (Directory.Exists(path))",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    {",
            "lineNumber": 62
          },
          {
            "text": "        await sequenceExcelService.SaveSequenceAsync(path, rows).ConfigureAwait(false);",
            "lineNumber": 63
          },
          {
            "text": "    }",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "    public async Task&lt;List&lt;SequenceRow&gt;&gt; LoadFromExcelAsync(string path, int columnCount)",
            "lineNumber": 66
          },
          {
            "text": "    {",
            "lineNumber": 67
          },
          {
            "text": "        return await sequenceExcelService.LoadSequenceAsync(path, columnCount).ConfigureAwait(false);",
            "lineNumber": 68
          },
          {
            "text": "    }",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "    public string GetTestsSequencePath()",
            "lineNumber": 71
          },
          {
            "text": "    {",
            "lineNumber": 72
          },
          {
            "text": "        var path = GetRequiredConfigPath(\"Paths:PathToTestsSequence\");",
            "lineNumber": 73
          },
          {
            "text": "        return GetOrCreateDirectory(path);",
            "lineNumber": 74
          },
          {
            "text": "    }",
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "    private string GetOrCreateDirectory(string path)",
            "lineNumber": 77
          },
          {
            "text": "    {",
            "lineNumber": 78
          },
          {
            "text": "        return Directory.Exists(path) ? path : CreateDirectory(path);",
            "lineNumber": 79
          },
          {
            "text": "    }",
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "    private string CreateDirectory(string path)",
            "lineNumber": 82
          },
          {
            "text": "    {",
            "lineNumber": 83
          },
          {
            "text": "        try",
            "lineNumber": 84
          },
          {
            "text": "        {",
            "lineNumber": 85
          },
          {
            "text": "            Directory.CreateDirectory(path);",
            "lineNumber": 86
          },
          {
            "text": "            return path;",
            "lineNumber": 87
          },
          {
            "text": "        }",
            "lineNumber": 88
          },
          {
            "text": "        catch (Exception ex)",
            "lineNumber": 89
          },
          {
            "text": "        {",
            "lineNumber": 90
          },
          {
            "text": "            logger.LogError(ex, \"Ошибка пути: Не удалось создать директорию: {Path}\", path);",
            "lineNumber": 91
          },
          {
            "text": "            throw new IOException($\"Ошибка пути: Не удалось создать директорию: {path}. {ex.Message}\", ex);",
            "lineNumber": 92
          },
          {
            "text": "        }",
            "lineNumber": 93
          },
          {
            "text": "    }",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "    public string GetValidRootPath()",
            "lineNumber": 96
          },
          {
            "text": "    {",
            "lineNumber": 97
          },
          {
            "text": "        var path = GetRequiredConfigPath(\"Paths:PathToTestSteps\");",
            "lineNumber": 98
          },
          {
            "text": "        ValidatePathExists(path);",
            "lineNumber": 99
          },
          {
            "text": "        return path;",
            "lineNumber": 100
          },
          {
            "text": "    }",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "    private string GetRequiredConfigPath(string key)",
            "lineNumber": 103
          },
          {
            "text": "    {",
            "lineNumber": 104
          },
          {
            "text": "        var path = configuration[key];",
            "lineNumber": 105
          },
          {
            "text": "        if (!string.IsNullOrEmpty(path))",
            "lineNumber": 106
          },
          {
            "text": "        {",
            "lineNumber": 107
          },
          {
            "text": "            return path;",
            "lineNumber": 108
          },
          {
            "text": "        }",
            "lineNumber": 109
          },
          {
            "text": "        logger.LogError(\"Ошибка конфигурации: {Key} отсутствует в appsettings.json\", key);",
            "lineNumber": 110
          },
          {
            "text": "        throw new InvalidOperationException($\"Ошибка конфигурации: {key} отсутствует в appsettings.json\");",
            "lineNumber": 111
          },
          {
            "text": "    }",
            "lineNumber": 112
          },
          {
            "lineNumber": 113
          },
          {
            "text": "    private void ValidatePathExists(string path)",
            "lineNumber": 114
          },
          {
            "text": "    {",
            "lineNumber": 115
          },
          {
            "text": "        if (Directory.Exists(path))",
            "lineNumber": 116
          }
        ]
      },
      "score": 0.16219556331634521
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSettings.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 11,
            "column": 1
          }
        },
        "contents": "namespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaSettings\n    {\n        public string EndpointUrl { get; set; } = \"opc.tcp://192.168.1.100:4840\";\n        public string ApplicationName { get; set; } = \"FinalTestHybrid\";\n        public int ReconnectIntervalMs { get; set; } = 5000;\n        public int SessionTimeoutMs { get; set; } = 60000;\n        public int PublishingIntervalMs { get; set; } = 1000;\n        public int OperationTimeoutMs { get; set; } = 15000;\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 1
          },
          {
            "text": "{",
            "lineNumber": 2
          },
          {
            "text": "    public class OpcUaSettings",
            "lineNumber": 3
          },
          {
            "text": "    {",
            "lineNumber": 4
          },
          {
            "text": "        public string EndpointUrl { get; set; } = \"opc.tcp://192.168.1.100:4840\";",
            "lineNumber": 5
          },
          {
            "text": "        public string ApplicationName { get; set; } = \"FinalTestHybrid\";",
            "lineNumber": 6
          },
          {
            "text": "        public int ReconnectIntervalMs { get; set; } = 5000;",
            "lineNumber": 7
          },
          {
            "text": "        public int SessionTimeoutMs { get; set; } = 60000;",
            "lineNumber": 8
          },
          {
            "text": "        public int PublishingIntervalMs { get; set; } = 1000;",
            "lineNumber": 9
          },
          {
            "text": "        public int OperationTimeoutMs { get; set; } = 15000;",
            "lineNumber": 10
          },
          {
            "text": "    }",
            "lineNumber": 11
          },
          {
            "text": "}",
            "lineNumber": 12
          }
        ]
      },
      "score": 0.1602867990732193
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\Interface\\IOpcUaConnectionService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 14
          }
        },
        "contents": "using Opc.Ua.Client;\n\nnamespace Final_Test_Hybrid.Services.OpcUa.Interface\n{\n    public interface IOpcUaConnectionService : IAsyncDisposable\n    {\n        bool IsConnected { get; }\n        Session? Session { get; }\n        event EventHandler&lt;bool&gt;? ConnectionChanged;\n\n        Task StartAsync(CancellationToken ct = default);\n        Task StopAsync();\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Opc.Ua.Client;",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa.Interface",
            "lineNumber": 3
          },
          {
            "text": "{",
            "lineNumber": 4
          },
          {
            "text": "    public interface IOpcUaConnectionService : IAsyncDisposable",
            "lineNumber": 5
          },
          {
            "text": "    {",
            "lineNumber": 6
          },
          {
            "text": "        bool IsConnected { get; }",
            "lineNumber": 7
          },
          {
            "text": "        Session? Session { get; }",
            "lineNumber": 8
          },
          {
            "text": "        event EventHandler&lt;bool&gt;? ConnectionChanged;",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "        Task StartAsync(CancellationToken ct = default);",
            "lineNumber": 11
          },
          {
            "text": "        Task StopAsync();",
            "lineNumber": 12
          },
          {
            "text": "    }",
            "lineNumber": 13
          },
          {
            "text": "}",
            "lineNumber": 14
          }
        ]
      },
      "score": 0.15961669385433197
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 58
          },
          "endPosition": {
            "line": 108,
            "column": 16
          }
        },
        "contents": "        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {\n            _appConfig = new Opc.Ua.ApplicationConfiguration\n            {\n                ApplicationName = _settings.ApplicationName,\n                ApplicationUri = $\"urn:{_settings.ApplicationName}\",\n                ApplicationType = ApplicationType.Client,\n                SecurityConfiguration = new SecurityConfiguration\n                {\n                    ApplicationCertificate = new CertificateIdentifier(),\n                    AutoAcceptUntrustedCertificates = true\n                },\n                ClientConfiguration = new ClientConfiguration\n                {\n                    DefaultSessionTimeout = _settings.SessionTimeoutMs\n                },\n                TransportConfigurations = [],\n                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }\n            };\n            await _appConfig.ValidateAsync(ApplicationType.Client);\n        }\n\n        private async Task ConnectLoopAsync(CancellationToken ct)\n        {\n            _currentDelayMs = _settings.ReconnectIntervalMs;\n            try\n            {\n                while (!ct.IsCancellationRequested)\n                {\n                    var connected = await TryReconnectIfNeededAsync(ct);\n                    UpdateBackoffDelay(connected);\n                    await Task.Delay(_currentDelayMs, ct);\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Connection loop failed\");\n            }\n        }\n\n        private void UpdateBackoffDelay(bool connected)\n        {\n            if (connected)\n            {\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        }",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "        private async Task InitializeApplicationConfigAsync()",
            "lineNumber": 61
          },
          {
            "text": "        {",
            "lineNumber": 62
          },
          {
            "text": "            _appConfig = new Opc.Ua.ApplicationConfiguration",
            "lineNumber": 63
          },
          {
            "text": "            {",
            "lineNumber": 64
          },
          {
            "text": "                ApplicationName = _settings.ApplicationName,",
            "lineNumber": 65
          },
          {
            "text": "                ApplicationUri = $\"urn:{_settings.ApplicationName}\",",
            "lineNumber": 66
          },
          {
            "text": "                ApplicationType = ApplicationType.Client,",
            "lineNumber": 67
          },
          {
            "text": "                SecurityConfiguration = new SecurityConfiguration",
            "lineNumber": 68
          },
          {
            "text": "                {",
            "lineNumber": 69
          },
          {
            "text": "                    ApplicationCertificate = new CertificateIdentifier(),",
            "lineNumber": 70
          },
          {
            "text": "                    AutoAcceptUntrustedCertificates = true",
            "lineNumber": 71
          },
          {
            "text": "                },",
            "lineNumber": 72
          },
          {
            "text": "                ClientConfiguration = new ClientConfiguration",
            "lineNumber": 73
          },
          {
            "text": "                {",
            "lineNumber": 74
          },
          {
            "text": "                    DefaultSessionTimeout = _settings.SessionTimeoutMs",
            "lineNumber": 75
          },
          {
            "text": "                },",
            "lineNumber": 76
          },
          {
            "text": "                TransportConfigurations = [],",
            "lineNumber": 77
          },
          {
            "text": "                TransportQuotas = new TransportQuotas { OperationTimeout = _settings.OperationTimeoutMs }",
            "lineNumber": 78
          },
          {
            "text": "            };",
            "lineNumber": 79
          },
          {
            "text": "            await _appConfig.ValidateAsync(ApplicationType.Client);",
            "lineNumber": 80
          },
          {
            "text": "        }",
            "lineNumber": 81
          },
          {
            "lineNumber": 82
          },
          {
            "text": "        private async Task ConnectLoopAsync(CancellationToken ct)",
            "lineNumber": 83
          },
          {
            "text": "        {",
            "lineNumber": 84
          },
          {
            "text": "            _currentDelayMs = _settings.ReconnectIntervalMs;",
            "lineNumber": 85
          },
          {
            "text": "            try",
            "lineNumber": 86
          },
          {
            "text": "            {",
            "lineNumber": 87
          },
          {
            "text": "                while (!ct.IsCancellationRequested)",
            "lineNumber": 88
          },
          {
            "text": "                {",
            "lineNumber": 89
          },
          {
            "text": "                    var connected = await TryReconnectIfNeededAsync(ct);",
            "lineNumber": 90
          },
          {
            "text": "                    UpdateBackoffDelay(connected);",
            "lineNumber": 91
          },
          {
            "text": "                    await Task.Delay(_currentDelayMs, ct);",
            "lineNumber": 92
          },
          {
            "text": "                }",
            "lineNumber": 93
          },
          {
            "text": "            }",
            "lineNumber": 94
          },
          {
            "text": "            catch (OperationCanceledException)",
            "lineNumber": 95
          },
          {
            "text": "            {",
            "lineNumber": 96
          },
          {
            "text": "                logger.LogInformation(\"Connection loop canceled\");",
            "lineNumber": 97
          },
          {
            "text": "            }",
            "lineNumber": 98
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 99
          },
          {
            "text": "            {",
            "lineNumber": 100
          },
          {
            "text": "                logger.LogError(ex, \"Connection loop failed\");",
            "lineNumber": 101
          },
          {
            "text": "            }",
            "lineNumber": 102
          },
          {
            "text": "        }",
            "lineNumber": 103
          },
          {
            "lineNumber": 104
          },
          {
            "text": "        private void UpdateBackoffDelay(bool connected)",
            "lineNumber": 105
          },
          {
            "text": "        {",
            "lineNumber": 106
          },
          {
            "text": "            if (connected)",
            "lineNumber": 107
          },
          {
            "text": "            {",
            "lineNumber": 108
          },
          {
            "text": "                ",
            "lineNumber": 109
          }
        ]
      },
      "score": 0.15921080112457275
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Components\\Engineer\\MainEngineering.razor.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 34,
            "column": 1
          }
        },
        "contents": "using Microsoft.AspNetCore.Components;\nusing Radzen;\n\nnamespace Final_Test_Hybrid.Components.Engineer;\n\npublic partial class MainEngineering\n{\n    [Inject]\n    public required DialogService DialogService { get; set; }\n    private string selectedLanguage = \"French (fr)\";\n    private readonly List&lt;string&gt; languages =\n    [\n        \"English (en)\",\n        \"French (fr)\",\n        \"German (de)\",\n        \"Spanish (es)\",\n        \"Italian (it)\",\n        \"Russian (ru)\"\n    ];\n\n    private async Task OpenTestSequenceEditor()\n    {\n        await DialogService.OpenAsync&lt;Sequence.TestSequenceEditor&gt;(\"Редактор шагов теста\",\n               new Dictionary&lt;string, object&gt;(),\n               new DialogOptions\n               { \n                   Width = \"95vw\", \n                   Height = \"95vh\", \n                   Resizable = true, \n                   Draggable = true,\n                   CssClass = \"test-sequence-editor-dialog\",\n                   CloseDialogOnOverlayClick = false\n               });\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Microsoft.AspNetCore.Components;",
            "lineNumber": 1
          },
          {
            "text": "using Radzen;",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "namespace Final_Test_Hybrid.Components.Engineer;",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "public partial class MainEngineering",
            "lineNumber": 6
          },
          {
            "text": "{",
            "lineNumber": 7
          },
          {
            "text": "    [Inject]",
            "lineNumber": 8
          },
          {
            "text": "    public required DialogService DialogService { get; set; }",
            "lineNumber": 9
          },
          {
            "text": "    private string selectedLanguage = \"French (fr)\";",
            "lineNumber": 10
          },
          {
            "text": "    private readonly List&lt;string&gt; languages =",
            "lineNumber": 11
          },
          {
            "text": "    [",
            "lineNumber": 12
          },
          {
            "text": "        \"English (en)\",",
            "lineNumber": 13
          },
          {
            "text": "        \"French (fr)\",",
            "lineNumber": 14
          },
          {
            "text": "        \"German (de)\",",
            "lineNumber": 15
          },
          {
            "text": "        \"Spanish (es)\",",
            "lineNumber": 16
          },
          {
            "text": "        \"Italian (it)\",",
            "lineNumber": 17
          },
          {
            "text": "        \"Russian (ru)\"",
            "lineNumber": 18
          },
          {
            "text": "    ];",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "    private async Task OpenTestSequenceEditor()",
            "lineNumber": 21
          },
          {
            "text": "    {",
            "lineNumber": 22
          },
          {
            "text": "        await DialogService.OpenAsync&lt;Sequence.TestSequenceEditor&gt;(\"Редактор шагов теста\",",
            "lineNumber": 23
          },
          {
            "text": "               new Dictionary&lt;string, object&gt;(),",
            "lineNumber": 24
          },
          {
            "text": "               new DialogOptions",
            "lineNumber": 25
          },
          {
            "text": "               { ",
            "lineNumber": 26
          },
          {
            "text": "                   Width = \"95vw\", ",
            "lineNumber": 27
          },
          {
            "text": "                   Height = \"95vh\", ",
            "lineNumber": 28
          },
          {
            "text": "                   Resizable = true, ",
            "lineNumber": 29
          },
          {
            "text": "                   Draggable = true,",
            "lineNumber": 30
          },
          {
            "text": "                   CssClass = \"test-sequence-editor-dialog\",",
            "lineNumber": 31
          },
          {
            "text": "                   CloseDialogOnOverlayClick = false",
            "lineNumber": 32
          },
          {
            "text": "               });",
            "lineNumber": 33
          },
          {
            "text": "    }",
            "lineNumber": 34
          },
          {
            "text": "}",
            "lineNumber": 35
          }
        ]
      },
      "score": 0.15500499308109283
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaReadWriteService.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 53
          }
        },
        "contents": "using Final_Test_Hybrid.Services.OpcUa.Interface;\nusing Microsoft.Extensions.Logging;\nusing Opc.Ua;\n\nnamespace Final_Test_Hybrid.Services.OpcUa\n{\n    public class OpcUaReadWriteService(\n        IOpcUaConnectionService connection,\n        ILogger&lt;OpcUaReadWriteService&gt; logger)\n        : IOpcUaReadWriteService\n    {\n        public async Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default)\n        {\n            var session = connection.Session;\n            if (session is not { Connected: true })\n            {\n                logger.LogWarning(\"Cannot read node {NodeId}: Session not connected\", nodeId);\n                return default;\n            }\n            try\n            {\n                var node = new NodeId(nodeId);\n                var value = await session.ReadValueAsync(node, ct);\n                return GetValueOrDefault&lt;T&gt;(nodeId, value);\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Failed to read node {NodeId}\", nodeId);\n                return default;\n            }\n        }\n\n        private T? GetValueOrDefault&lt;T&gt;(string nodeId, DataValue value)\n        {\n            if (!StatusCode.IsBad(value.StatusCode))\n            {\n                return value.Value is T typedValue\n                    ? typedValue\n                    : LogAndReturnDefault&lt;T&gt;(nodeId);\n            }\n            logger.LogWarning(\"Read node {NodeId} returned bad status {Status}\", nodeId, value.StatusCode);\n            return default;\n        }\n\n        private T? LogAndReturnDefault&lt;T&gt;(string nodeId)\n        {\n            logger.LogWarning(\"Cannot cast value from node {NodeId} to type {Type}\", nodeId, typeof(T).Name);\n            return default;\n        }\n\n        public async Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default)\n        {\n            var session = connection.Session;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Final_Test_Hybrid.Services.OpcUa.Interface;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.Extensions.Logging;",
            "lineNumber": 2
          },
          {
            "text": "using Opc.Ua;",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "namespace Final_Test_Hybrid.Services.OpcUa",
            "lineNumber": 5
          },
          {
            "text": "{",
            "lineNumber": 6
          },
          {
            "text": "    public class OpcUaReadWriteService(",
            "lineNumber": 7
          },
          {
            "text": "        IOpcUaConnectionService connection,",
            "lineNumber": 8
          },
          {
            "text": "        ILogger&lt;OpcUaReadWriteService&gt; logger)",
            "lineNumber": 9
          },
          {
            "text": "        : IOpcUaReadWriteService",
            "lineNumber": 10
          },
          {
            "text": "    {",
            "lineNumber": 11
          },
          {
            "text": "        public async Task&lt;T?&gt; ReadNodeAsync&lt;T&gt;(string nodeId, CancellationToken ct = default)",
            "lineNumber": 12
          },
          {
            "text": "        {",
            "lineNumber": 13
          },
          {
            "text": "            var session = connection.Session;",
            "lineNumber": 14
          },
          {
            "text": "            if (session is not { Connected: true })",
            "lineNumber": 15
          },
          {
            "text": "            {",
            "lineNumber": 16
          },
          {
            "text": "                logger.LogWarning(\"Cannot read node {NodeId}: Session not connected\", nodeId);",
            "lineNumber": 17
          },
          {
            "text": "                return default;",
            "lineNumber": 18
          },
          {
            "text": "            }",
            "lineNumber": 19
          },
          {
            "text": "            try",
            "lineNumber": 20
          },
          {
            "text": "            {",
            "lineNumber": 21
          },
          {
            "text": "                var node = new NodeId(nodeId);",
            "lineNumber": 22
          },
          {
            "text": "                var value = await session.ReadValueAsync(node, ct);",
            "lineNumber": 23
          },
          {
            "text": "                return GetValueOrDefault&lt;T&gt;(nodeId, value);",
            "lineNumber": 24
          },
          {
            "text": "            }",
            "lineNumber": 25
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 26
          },
          {
            "text": "            {",
            "lineNumber": 27
          },
          {
            "text": "                logger.LogError(ex, \"Failed to read node {NodeId}\", nodeId);",
            "lineNumber": 28
          },
          {
            "text": "                return default;",
            "lineNumber": 29
          },
          {
            "text": "            }",
            "lineNumber": 30
          },
          {
            "text": "        }",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "        private T? GetValueOrDefault&lt;T&gt;(string nodeId, DataValue value)",
            "lineNumber": 33
          },
          {
            "text": "        {",
            "lineNumber": 34
          },
          {
            "text": "            if (!StatusCode.IsBad(value.StatusCode))",
            "lineNumber": 35
          },
          {
            "text": "            {",
            "lineNumber": 36
          },
          {
            "text": "                return value.Value is T typedValue",
            "lineNumber": 37
          },
          {
            "text": "                    ? typedValue",
            "lineNumber": 38
          },
          {
            "text": "                    : LogAndReturnDefault&lt;T&gt;(nodeId);",
            "lineNumber": 39
          },
          {
            "text": "            }",
            "lineNumber": 40
          },
          {
            "text": "            logger.LogWarning(\"Read node {NodeId} returned bad status {Status}\", nodeId, value.StatusCode);",
            "lineNumber": 41
          },
          {
            "text": "            return default;",
            "lineNumber": 42
          },
          {
            "text": "        }",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "        private T? LogAndReturnDefault&lt;T&gt;(string nodeId)",
            "lineNumber": 45
          },
          {
            "text": "        {",
            "lineNumber": 46
          },
          {
            "text": "            logger.LogWarning(\"Cannot cast value from node {NodeId} to type {Type}\", nodeId, typeof(T).Name);",
            "lineNumber": 47
          },
          {
            "text": "            return default;",
            "lineNumber": 48
          },
          {
            "text": "        }",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "        public async Task WriteNodeAsync&lt;T&gt;(string nodeId, T value, CancellationToken ct = default)",
            "lineNumber": 51
          },
          {
            "text": "        {",
            "lineNumber": 52
          },
          {
            "text": "            var session = connection.Session;",
            "lineNumber": 53
          }
        ]
      },
      "score": 0.15205900371074677
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaSubscriptionService.cs",
        "range": {
          "startPosition": {
            "line": 145
          },
          "endPosition": {
            "line": 209
          }
        },
        "contents": "        {\n            try\n            {\n                await RemoveSubscriptionFromSessionAsync(subscription);\n                subscription.Dispose();\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error disposing subscription\");\n            }\n        }\n\n        private Subscription CreateSubscription(Session session)\n        {\n            return new Subscription(session.DefaultSubscription)\n            {\n                PublishingInterval = _settings.PublishingIntervalMs\n            };\n        }\n\n        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)\n        {\n            var monitoredItem = new MonitoredItem(subscription.DefaultItem)\n            {\n                StartNodeId = new NodeId(nodeId),\n                AttributeId = Attributes.Value\n            };\n            monitoredItem.Notification += (item, e) =&gt;\n            {\n                try\n                {\n                    if (e.NotificationValue is not MonitoredItemNotification notification)\n                    {\n                        return;\n                    }\n                    callback(notification.Value.Value);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);\n                }\n            };\n            return monitoredItem;\n        }\n\n        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)\n        {\n            subscription.AddItem(monitoredItem);\n            session.AddSubscription(subscription);\n            try\n            {\n                await subscription.CreateAsync();\n            }\n            catch\n            {\n                await session.RemoveSubscriptionAsync(subscription);\n                subscription.Dispose();\n                throw;\n            }\n        }\n\n        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)\n        {\n            if (subscription.Session is not { Connected: true })",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 146
          },
          {
            "text": "            try",
            "lineNumber": 147
          },
          {
            "text": "            {",
            "lineNumber": 148
          },
          {
            "text": "                await RemoveSubscriptionFromSessionAsync(subscription);",
            "lineNumber": 149
          },
          {
            "text": "                subscription.Dispose();",
            "lineNumber": 150
          },
          {
            "text": "            }",
            "lineNumber": 151
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 152
          },
          {
            "text": "            {",
            "lineNumber": 153
          },
          {
            "text": "                logger.LogError(ex, \"Error disposing subscription\");",
            "lineNumber": 154
          },
          {
            "text": "            }",
            "lineNumber": 155
          },
          {
            "text": "        }",
            "lineNumber": 156
          },
          {
            "lineNumber": 157
          },
          {
            "text": "        private Subscription CreateSubscription(Session session)",
            "lineNumber": 158
          },
          {
            "text": "        {",
            "lineNumber": 159
          },
          {
            "text": "            return new Subscription(session.DefaultSubscription)",
            "lineNumber": 160
          },
          {
            "text": "            {",
            "lineNumber": 161
          },
          {
            "text": "                PublishingInterval = _settings.PublishingIntervalMs",
            "lineNumber": 162
          },
          {
            "text": "            };",
            "lineNumber": 163
          },
          {
            "text": "        }",
            "lineNumber": 164
          },
          {
            "lineNumber": 165
          },
          {
            "text": "        private MonitoredItem CreateMonitoredItem(string nodeId, Action&lt;object?&gt; callback, Subscription subscription)",
            "lineNumber": 166
          },
          {
            "text": "        {",
            "lineNumber": 167
          },
          {
            "text": "            var monitoredItem = new MonitoredItem(subscription.DefaultItem)",
            "lineNumber": 168
          },
          {
            "text": "            {",
            "lineNumber": 169
          },
          {
            "text": "                StartNodeId = new NodeId(nodeId),",
            "lineNumber": 170
          },
          {
            "text": "                AttributeId = Attributes.Value",
            "lineNumber": 171
          },
          {
            "text": "            };",
            "lineNumber": 172
          },
          {
            "text": "            monitoredItem.Notification += (item, e) =&gt;",
            "lineNumber": 173
          },
          {
            "text": "            {",
            "lineNumber": 174
          },
          {
            "text": "                try",
            "lineNumber": 175
          },
          {
            "text": "                {",
            "lineNumber": 176
          },
          {
            "text": "                    if (e.NotificationValue is not MonitoredItemNotification notification)",
            "lineNumber": 177
          },
          {
            "text": "                    {",
            "lineNumber": 178
          },
          {
            "text": "                        return;",
            "lineNumber": 179
          },
          {
            "text": "                    }",
            "lineNumber": 180
          },
          {
            "text": "                    callback(notification.Value.Value);",
            "lineNumber": 181
          },
          {
            "text": "                }",
            "lineNumber": 182
          },
          {
            "text": "                catch (Exception ex)",
            "lineNumber": 183
          },
          {
            "text": "                {",
            "lineNumber": 184
          },
          {
            "text": "                    logger.LogError(ex, \"Callback error for node {NodeId}\", nodeId);",
            "lineNumber": 185
          },
          {
            "text": "                }",
            "lineNumber": 186
          },
          {
            "text": "            };",
            "lineNumber": 187
          },
          {
            "text": "            return monitoredItem;",
            "lineNumber": 188
          },
          {
            "text": "        }",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "        private async Task AddSubscriptionToSessionAsync(Session session, Subscription subscription, MonitoredItem monitoredItem)",
            "lineNumber": 191
          },
          {
            "text": "        {",
            "lineNumber": 192
          },
          {
            "text": "            subscription.AddItem(monitoredItem);",
            "lineNumber": 193
          },
          {
            "text": "            session.AddSubscription(subscription);",
            "lineNumber": 194
          },
          {
            "text": "            try",
            "lineNumber": 195
          },
          {
            "text": "            {",
            "lineNumber": 196
          },
          {
            "text": "                await subscription.CreateAsync();",
            "lineNumber": 197
          },
          {
            "text": "            }",
            "lineNumber": 198
          },
          {
            "text": "            catch",
            "lineNumber": 199
          },
          {
            "text": "            {",
            "lineNumber": 200
          },
          {
            "text": "                await session.RemoveSubscriptionAsync(subscription);",
            "lineNumber": 201
          },
          {
            "text": "                subscription.Dispose();",
            "lineNumber": 202
          },
          {
            "text": "                throw;",
            "lineNumber": 203
          },
          {
            "text": "            }",
            "lineNumber": 204
          },
          {
            "text": "        }",
            "lineNumber": 205
          },
          {
            "lineNumber": 206
          },
          {
            "text": "        private async Task RemoveSubscriptionFromSessionAsync(Subscription subscription)",
            "lineNumber": 207
          },
          {
            "text": "        {",
            "lineNumber": 208
          },
          {
            "text": "            if (subscription.Session is not { Connected: true })",
            "lineNumber": 209
          }
        ]
      },
      "score": 0.14573679864406586
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\obj\\Debug\\net10.0-windows\\Final_Test_Hybrid.csproj.AssemblyReference.cache",
        "range": {
          "startPosition": {
            "line": 54,
            "column": 159
          },
          "endPosition": {
            "line": 63,
            "column": 157
          }
        },
        "contents": "\u0000\u0000\u0000?L\u0015\u0012Þ\b\u0001\u0001\u0001)Microsoft.Extensions.Configuration.Binder\u0001\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.configuration.binder/10.0.0/lib/net10.0/Microsoft.Extensions.Configuration.Binder.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001mMicrosoft.Extensions.Configuration.Binder, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.configuration.fileextensions\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Configuration.FileExtensions.dll\u0001\u0001\u0000\u0000\u0000\u0000ðT.\u0012Þ\b\u0001\u0001\u00011Microsoft.Extensions.Configuration.FileExtensions\u0001\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001¥\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.configuration.fileextensions/10.0.0/lib/net10.0/Microsoft.Extensions.Configuration.FileExtensions.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001uMicrosoft.Extensions.Configuration.FileExtensions, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.configuration.json\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Configuration.Json.dll\u0001\u0001\u0000\u0000\u0000\u0000ÀgA\u0012Þ\b\u0001\u0001\u0001'Microsoft.Extensions.Configuration.Json\u0001\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.configuration.json/10.0.0/lib/net10.0/Microsoft.Extensions.Configuration.Json.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001kMicrosoft.Extensions.Configuration.Json, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.dependencyinjection\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.DependencyInjection.dll\u0001\u0001\u0000",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\u0000\u0000\u0000?L\u0015\u0012Þ\b\u0001\u0001\u0001)Microsoft.Extensions.Configuration.Binder\u0001",
            "lineNumber": 55
          },
          {
            "text": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.configuration.binder/10.0.0/lib/net10.0/Microsoft.Extensions.Configuration.Binder.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 56
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001mMicrosoft.Extensions.Configuration.Binder, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 57
          },
          {
            "text": "v4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.configuration.fileextensions\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Configuration.FileExtensions.dll\u0001\u0001\u0000\u0000\u0000\u0000ðT.\u0012Þ\b\u0001\u0001\u00011Microsoft.Extensions.Configuration.FileExtensions\u0001",
            "lineNumber": 58
          },
          {
            "text": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001¥\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.configuration.fileextensions/10.0.0/lib/net10.0/Microsoft.Extensions.Configuration.FileExtensions.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 59
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001uMicrosoft.Extensions.Configuration.FileExtensions, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 60
          },
          {
            "text": "v4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.configuration.json\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Configuration.Json.dll\u0001\u0001\u0000\u0000\u0000\u0000ÀgA\u0012Þ\b\u0001\u0001\u0001'Microsoft.Extensions.Configuration.Json\u0001",
            "lineNumber": 61
          },
          {
            "text": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.configuration.json/10.0.0/lib/net10.0/Microsoft.Extensions.Configuration.Json.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 62
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001kMicrosoft.Extensions.Configuration.Json, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 63
          },
          {
            "text": "v4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.dependencyinjection\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.DependencyInjection.dll\u0001\u0001\u0000",
            "lineNumber": 64
          }
        ]
      },
      "score": 0.1325446367263794
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\_Imports.razor",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 4
          }
        },
        "contents": "@using Microsoft.AspNetCore.Components.Web\n@using Radzen\n@using Radzen.Blazor\n@using Final_Test_Hybrid.Models",
        "signatures": {},
        "detailedLines": [
          {
            "text": "@using Microsoft.AspNetCore.Components.Web",
            "lineNumber": 1
          },
          {
            "text": "@using Radzen",
            "lineNumber": 2
          },
          {
            "text": "@using Radzen.Blazor",
            "lineNumber": 3
          },
          {
            "text": "@using Final_Test_Hybrid.Models",
            "lineNumber": 4
          }
        ]
      },
      "score": 0.13008999824523926
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Services\\OpcUa\\OpcUaConnectionService.cs",
        "range": {
          "startPosition": {
            "line": 241
          },
          "endPosition": {
            "line": 301,
            "column": 16
          }
        },
        "contents": "        {\n            if (_cts == null)\n            {\n                return;\n            }\n            await _cts.CancelAsync();\n            _cts.Dispose();\n            _cts = null;\n            DisposeReconnectHandler();\n            await WaitConnectLoopAsync();\n        }\n\n        private void DisposeReconnectHandler()\n        {\n            lock (_reconnectLock)\n            {\n                _reconnectHandler?.Dispose();\n                _reconnectHandler = null;\n            }\n        }\n\n        private async Task CloseSessionAsync()\n        {\n            if (Session == null)\n            {\n                return;\n            }\n            Session.KeepAlive -= OnSessionKeepAlive;\n            try\n            {\n                await Session.CloseAsync();\n            }\n            catch (Exception ex)\n            {\n                logger.LogWarning(ex, \"Error closing session\");\n            }\n            Session.Dispose();\n            Session = null;\n        }\n\n        private async Task WaitConnectLoopAsync()\n        {\n            if (_connectLoopTask == null)\n            {\n                return;\n            }\n            try\n            {\n                await _connectLoopTask;\n            }\n            catch (OperationCanceledException)\n            {\n                logger.LogInformation(\"Connection loop canceled\");\n            }\n            _connectLoopTask = null;\n        }\n\n        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)\n        {\n            var session = await sessionFactory.CreateAsync(\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        {",
            "lineNumber": 242
          },
          {
            "text": "            if (_cts == null)",
            "lineNumber": 243
          },
          {
            "text": "            {",
            "lineNumber": 244
          },
          {
            "text": "                return;",
            "lineNumber": 245
          },
          {
            "text": "            }",
            "lineNumber": 246
          },
          {
            "text": "            await _cts.CancelAsync();",
            "lineNumber": 247
          },
          {
            "text": "            _cts.Dispose();",
            "lineNumber": 248
          },
          {
            "text": "            _cts = null;",
            "lineNumber": 249
          },
          {
            "text": "            DisposeReconnectHandler();",
            "lineNumber": 250
          },
          {
            "text": "            await WaitConnectLoopAsync();",
            "lineNumber": 251
          },
          {
            "text": "        }",
            "lineNumber": 252
          },
          {
            "lineNumber": 253
          },
          {
            "text": "        private void DisposeReconnectHandler()",
            "lineNumber": 254
          },
          {
            "text": "        {",
            "lineNumber": 255
          },
          {
            "text": "            lock (_reconnectLock)",
            "lineNumber": 256
          },
          {
            "text": "            {",
            "lineNumber": 257
          },
          {
            "text": "                _reconnectHandler?.Dispose();",
            "lineNumber": 258
          },
          {
            "text": "                _reconnectHandler = null;",
            "lineNumber": 259
          },
          {
            "text": "            }",
            "lineNumber": 260
          },
          {
            "text": "        }",
            "lineNumber": 261
          },
          {
            "lineNumber": 262
          },
          {
            "text": "        private async Task CloseSessionAsync()",
            "lineNumber": 263
          },
          {
            "text": "        {",
            "lineNumber": 264
          },
          {
            "text": "            if (Session == null)",
            "lineNumber": 265
          },
          {
            "text": "            {",
            "lineNumber": 266
          },
          {
            "text": "                return;",
            "lineNumber": 267
          },
          {
            "text": "            }",
            "lineNumber": 268
          },
          {
            "text": "            Session.KeepAlive -= OnSessionKeepAlive;",
            "lineNumber": 269
          },
          {
            "text": "            try",
            "lineNumber": 270
          },
          {
            "text": "            {",
            "lineNumber": 271
          },
          {
            "text": "                await Session.CloseAsync();",
            "lineNumber": 272
          },
          {
            "text": "            }",
            "lineNumber": 273
          },
          {
            "text": "            catch (Exception ex)",
            "lineNumber": 274
          },
          {
            "text": "            {",
            "lineNumber": 275
          },
          {
            "text": "                logger.LogWarning(ex, \"Error closing session\");",
            "lineNumber": 276
          },
          {
            "text": "            }",
            "lineNumber": 277
          },
          {
            "text": "            Session.Dispose();",
            "lineNumber": 278
          },
          {
            "text": "            Session = null;",
            "lineNumber": 279
          },
          {
            "text": "        }",
            "lineNumber": 280
          },
          {
            "lineNumber": 281
          },
          {
            "text": "        private async Task WaitConnectLoopAsync()",
            "lineNumber": 282
          },
          {
            "text": "        {",
            "lineNumber": 283
          },
          {
            "text": "            if (_connectLoopTask == null)",
            "lineNumber": 284
          },
          {
            "text": "            {",
            "lineNumber": 285
          },
          {
            "text": "                return;",
            "lineNumber": 286
          },
          {
            "text": "            }",
            "lineNumber": 287
          },
          {
            "text": "            try",
            "lineNumber": 288
          },
          {
            "text": "            {",
            "lineNumber": 289
          },
          {
            "text": "                await _connectLoopTask;",
            "lineNumber": 290
          },
          {
            "text": "            }",
            "lineNumber": 291
          },
          {
            "text": "            catch (OperationCanceledException)",
            "lineNumber": 292
          },
          {
            "text": "            {",
            "lineNumber": 293
          },
          {
            "text": "                logger.LogInformation(\"Connection loop canceled\");",
            "lineNumber": 294
          },
          {
            "text": "            }",
            "lineNumber": 295
          },
          {
            "text": "            _connectLoopTask = null;",
            "lineNumber": 296
          },
          {
            "text": "        }",
            "lineNumber": 297
          },
          {
            "lineNumber": 298
          },
          {
            "text": "        private async Task&lt;Session&gt; CreateSessionAsync(ConfiguredEndpoint configEndpoint, CancellationToken ct)",
            "lineNumber": 299
          },
          {
            "text": "        {",
            "lineNumber": 300
          },
          {
            "text": "            var session = await sessionFactory.CreateAsync(",
            "lineNumber": 301
          },
          {
            "text": "                ",
            "lineNumber": 302
          }
        ]
      },
      "score": 0.12807494401931763
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\obj\\Debug\\net10.0-windows\\Final_Test_Hybrid.csproj.AssemblyReference.cache",
        "range": {
          "startPosition": {
            "line": 61,
            "column": 190
          },
          "endPosition": {
            "line": 72,
            "column": 167
          }
        },
        "contents": "\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001kMicrosoft.Extensions.Configuration.Json, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.dependencyinjection\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.DependencyInjection.dll\u0001\u0001\u0000\u0000\u0000\u0000\u0019\u0018\u0012Þ\b\u0001\u0001\u0001(Microsoft.Extensions.DependencyInjection\u0001\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.dependencyinjection/10.0.0/lib/net10.0/Microsoft.Extensions.DependencyInjection.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001lMicrosoft.Extensions.DependencyInjection, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001¥\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.dependencyinjection.abstractions\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\u0001\u0001\u0000\u0000\u0000\u0000¸à\u0012Þ\b\u0001\u0001\u00015Microsoft.Extensions.DependencyInjection.Abstractions\u0001\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001­\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.dependencyinjection.abstractions/10.0.0/lib/net10.0/Microsoft.Extensions.DependencyInjection.Abstractions.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001yMicrosoft.Extensions.DependencyInjection.Abstractions, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001{C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.diagnostics\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Diagnostics.dll\u0001\u0001\u0000\u0000\u0000\u0000ÀgA\u0012Þ\b\u0001\u0001\u0001 Microsoft.Extensions.Diagnostics\u0001\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.diagnostics/10.0.0/lib/net10.0/Microsoft.Extensions.Diagnostics.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ\n¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001dMicrosoft.Extensions.Diagnostics, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001\nv4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.diagnostics.abstractions\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Diagnostics.Abstractions.dll\u0001\u0001\u0000",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 62
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001kMicrosoft.Extensions.Configuration.Json, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 63
          },
          {
            "text": "v4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.dependencyinjection\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.DependencyInjection.dll\u0001\u0001\u0000\u0000\u0000\u0000\u0019\u0018\u0012Þ\b\u0001\u0001\u0001(Microsoft.Extensions.DependencyInjection\u0001",
            "lineNumber": 64
          },
          {
            "text": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.dependencyinjection/10.0.0/lib/net10.0/Microsoft.Extensions.DependencyInjection.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 65
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001lMicrosoft.Extensions.DependencyInjection, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 66
          },
          {
            "text": "v4.0.30319\u0000\u0001¥\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.dependencyinjection.abstractions\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\u0001\u0001\u0000\u0000\u0000\u0000¸à\u0012Þ\b\u0001\u0001\u00015Microsoft.Extensions.DependencyInjection.Abstractions\u0001",
            "lineNumber": 67
          },
          {
            "text": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001­\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.dependencyinjection.abstractions/10.0.0/lib/net10.0/Microsoft.Extensions.DependencyInjection.Abstractions.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 68
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001yMicrosoft.Extensions.DependencyInjection.Abstractions, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 69
          },
          {
            "text": "v4.0.30319\u0000\u0001{C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.diagnostics\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Diagnostics.dll\u0001\u0001\u0000\u0000\u0000\u0000ÀgA\u0012Þ\b\u0001\u0001\u0001 Microsoft.Extensions.Diagnostics\u0001",
            "lineNumber": 70
          },
          {
            "text": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001file:///C:/Users/Alexander/.nuget/packages/microsoft.extensions.diagnostics/10.0.0/lib/net10.0/Microsoft.Extensions.Diagnostics.dll\u0001 \u0000\u0000\u0000\u0000$\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0006\u0002\u0000\u0000\u0000$\u0000\u0000RSA1\u0000\u0004\u0000\u0000\u0001\u0000\u0001\u0000ó:)\u0004O©×@É³!:å|´rÈN\u000b\u000e\u001aäg©øöÞ_=R¬#äÅ\u0018\u0001ñÜ",
            "lineNumber": 71
          },
          {
            "text": "¾\u001d£M*;ªÛ\u0014\u001a\u0017Ç~óÅeÝ^å\u0005KÏc»&lt;j¸?r«:¯é=\u000fÃÂ4vO¯°±Às=å\u0014Y®«FX\u0003¿tÄâd·ÍâGøº\u0007\u001c*Ò»\u0001\b\u0000\u0000\u0000­¹y8)Ý®&#96;\u0001dMicrosoft.Extensions.Diagnostics, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0000\u0000\u0000\u0000\u0000\u0000\u0001",
            "lineNumber": 72
          },
          {
            "text": "v4.0.30319\u0000\u0001\u0001C:\\Users\\Alexander\\.nuget\\packages\\microsoft.extensions.diagnostics.abstractions\\10.0.0\\lib\\net10.0\\Microsoft.Extensions.Diagnostics.Abstractions.dll\u0001\u0001\u0000",
            "lineNumber": 73
          }
        ]
      },
      "score": 0.12717026472091675
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Components\\Base\\GridInplaceEditorBase.cs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 70
          }
        },
        "contents": "using Microsoft.AspNetCore.Components;\nusing Microsoft.JSInterop;\nusing Radzen;\nusing Radzen.Blazor;\n\nnamespace Final_Test_Hybrid.Components.Base;\n\npublic abstract class GridInplaceEditorBase&lt;TItem&gt; : ComponentBase, IAsyncDisposable where TItem : class\n{\n    [Inject]\n    protected IJSRuntime JsRuntime { get; set; } = null!;\n    protected RadzenDataGrid&lt;TItem&gt; Grid { get; set; } = null!;\n    protected List&lt;TItem&gt; Items { get; set; } = [];\n    private TItem? _itemToUpdate;\n    private string? _editingColumn;\n    protected string ContainerId { get; set; } = $\"grid-editor-{Guid.NewGuid()}\";\n    private DotNetObjectReference&lt;GridInplaceEditorBase&lt;TItem&gt;&gt;? _dotNetHelper;\n    private bool _outsideClickHandlerRegistered;\n\n    protected override async Task OnAfterRenderAsync(bool firstRender)\n    {\n        if (firstRender)\n        {\n            await RegisterOutsideClickHandler();\n        }\n    }\n\n    protected bool IsEditing(string propertyName)\n    {\n        return _editingColumn == propertyName;\n    }\n\n    protected async Task OnCellClick(DataGridCellMouseEventArgs&lt;TItem&gt; args)\n    {\n        await SwitchEditMode(args.Data, args.Column.Property);\n    }\n\n    private async Task SwitchEditMode(TItem item, string property)\n    {\n        if (_itemToUpdate == item &amp;&amp; _editingColumn == property)\n        {\n            return;\n        }\n\n        await ChangeEditMode(item, property);\n    }\n\n    private async Task ChangeEditMode(TItem item, string property)\n    {\n        await CommitPreviousChanges();\n\n        _itemToUpdate = item;\n        _editingColumn = property;\n\n        await Grid.EditRow(item);\n    }\n\n    private async Task CommitPreviousChanges()\n    {\n        if (_itemToUpdate == null)\n        {\n            return;\n        }\n        await Grid.UpdateRow(_itemToUpdate);\n    }\n\n    [JSInvokable]\n    public async Task CloseEdit()\n    {\n        if (_itemToUpdate == null)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "using Microsoft.AspNetCore.Components;",
            "lineNumber": 1
          },
          {
            "text": "using Microsoft.JSInterop;",
            "lineNumber": 2
          },
          {
            "text": "using Radzen;",
            "lineNumber": 3
          },
          {
            "text": "using Radzen.Blazor;",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "namespace Final_Test_Hybrid.Components.Base;",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "public abstract class GridInplaceEditorBase&lt;TItem&gt; : ComponentBase, IAsyncDisposable where TItem : class",
            "lineNumber": 8
          },
          {
            "text": "{",
            "lineNumber": 9
          },
          {
            "text": "    [Inject]",
            "lineNumber": 10
          },
          {
            "text": "    protected IJSRuntime JsRuntime { get; set; } = null!;",
            "lineNumber": 11
          },
          {
            "text": "    protected RadzenDataGrid&lt;TItem&gt; Grid { get; set; } = null!;",
            "lineNumber": 12
          },
          {
            "text": "    protected List&lt;TItem&gt; Items { get; set; } = [];",
            "lineNumber": 13
          },
          {
            "text": "    private TItem? _itemToUpdate;",
            "lineNumber": 14
          },
          {
            "text": "    private string? _editingColumn;",
            "lineNumber": 15
          },
          {
            "text": "    protected string ContainerId { get; set; } = $\"grid-editor-{Guid.NewGuid()}\";",
            "lineNumber": 16
          },
          {
            "text": "    private DotNetObjectReference&lt;GridInplaceEditorBase&lt;TItem&gt;&gt;? _dotNetHelper;",
            "lineNumber": 17
          },
          {
            "text": "    private bool _outsideClickHandlerRegistered;",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "    protected override async Task OnAfterRenderAsync(bool firstRender)",
            "lineNumber": 20
          },
          {
            "text": "    {",
            "lineNumber": 21
          },
          {
            "text": "        if (firstRender)",
            "lineNumber": 22
          },
          {
            "text": "        {",
            "lineNumber": 23
          },
          {
            "text": "            await RegisterOutsideClickHandler();",
            "lineNumber": 24
          },
          {
            "text": "        }",
            "lineNumber": 25
          },
          {
            "text": "    }",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "    protected bool IsEditing(string propertyName)",
            "lineNumber": 28
          },
          {
            "text": "    {",
            "lineNumber": 29
          },
          {
            "text": "        return _editingColumn == propertyName;",
            "lineNumber": 30
          },
          {
            "text": "    }",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "    protected async Task OnCellClick(DataGridCellMouseEventArgs&lt;TItem&gt; args)",
            "lineNumber": 33
          },
          {
            "text": "    {",
            "lineNumber": 34
          },
          {
            "text": "        await SwitchEditMode(args.Data, args.Column.Property);",
            "lineNumber": 35
          },
          {
            "text": "    }",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "    private async Task SwitchEditMode(TItem item, string property)",
            "lineNumber": 38
          },
          {
            "text": "    {",
            "lineNumber": 39
          },
          {
            "text": "        if (_itemToUpdate == item &amp;&amp; _editingColumn == property)",
            "lineNumber": 40
          },
          {
            "text": "        {",
            "lineNumber": 41
          },
          {
            "text": "            return;",
            "lineNumber": 42
          },
          {
            "text": "        }",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "        await ChangeEditMode(item, property);",
            "lineNumber": 45
          },
          {
            "text": "    }",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "    private async Task ChangeEditMode(TItem item, string property)",
            "lineNumber": 48
          },
          {
            "text": "    {",
            "lineNumber": 49
          },
          {
            "text": "        await CommitPreviousChanges();",
            "lineNumber": 50
          },
          {
            "lineNumber": 51
          },
          {
            "text": "        _itemToUpdate = item;",
            "lineNumber": 52
          },
          {
            "text": "        _editingColumn = property;",
            "lineNumber": 53
          },
          {
            "lineNumber": 54
          },
          {
            "text": "        await Grid.EditRow(item);",
            "lineNumber": 55
          },
          {
            "text": "    }",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "    private async Task CommitPreviousChanges()",
            "lineNumber": 58
          },
          {
            "text": "    {",
            "lineNumber": 59
          },
          {
            "text": "        if (_itemToUpdate == null)",
            "lineNumber": 60
          },
          {
            "text": "        {",
            "lineNumber": 61
          },
          {
            "text": "            return;",
            "lineNumber": 62
          },
          {
            "text": "        }",
            "lineNumber": 63
          },
          {
            "text": "        await Grid.UpdateRow(_itemToUpdate);",
            "lineNumber": 64
          },
          {
            "text": "    }",
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "    [JSInvokable]",
            "lineNumber": 67
          },
          {
            "text": "    public async Task CloseEdit()",
            "lineNumber": 68
          },
          {
            "text": "    {",
            "lineNumber": 69
          },
          {
            "text": "        if (_itemToUpdate == null)",
            "lineNumber": 70
          }
        ]
      },
      "score": 0.12542176246643066
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\Components\\Engineer\\MainEngineering.razor",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 29
          }
        },
        "contents": "&lt;div class=\"engineering-container\"&gt;\n    &lt;div class=\"button-stack\"&gt;\n        &lt;!-- Hand Program: Hammer icon (Reddish) --&gt;\n        &lt;RadzenButton Text=\"Hand Program\" Icon=\"build\" Class=\"eng-btn btn-icon-red\" /&gt;\n        \n        &lt;!-- IO Editor: Chip/Board icon (Greenish) --&gt;\n        &lt;RadzenButton Text=\"IO Editor\" Icon=\"memory\" Class=\"eng-btn btn-icon-green\" /&gt;\n        \n        &lt;!-- AI &amp; RTD Correction: Gauge icon --&gt;\n        &lt;RadzenButton Text=\"AI &amp; RTD Correction\" Icon=\"speed\" Class=\"eng-btn\" /&gt;\n        \n        &lt;!-- Disable Test Log: Checkmark icon (Green), Orange styling --&gt;\n        &lt;RadzenButton Text=\"Disable Test Log\" Icon=\"check_circle\" Class=\"eng-btn active-orange btn-icon-green-bright\" /&gt;\n        \n        &lt;!-- Test Log Viewer: Pen/Paper icon --&gt;\n        &lt;RadzenButton Text=\"Test Log Viewer\" Icon=\"edit_note\" Class=\"eng-btn\" /&gt;\n        \n        &lt;!-- Test Sequence Editor: List/Code icon --&gt;\n        &lt;RadzenButton Text=\"Редактор шагов теста\" Icon=\"playlist_add_check\" Class=\"eng-btn\" Click=\"@OpenTestSequenceEditor\" /&gt;\n        \n        &lt;!-- View Gas &amp; DHW Charts: Chart icon --&gt;\n        &lt;RadzenButton Text=\"View Gas &amp; DHW Charts\" Icon=\"show_chart\" Class=\"eng-btn\" /&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"language-selector\"&gt;\n        &lt;span class=\"language-label\"&gt;Language&lt;/span&gt;\n        &lt;RadzenDropDown Data=\"@languages\" @bind-Value=\"selectedLanguage\" Style=\"width: 250px;\" /&gt;\n    &lt;/div&gt;\n&lt;/div&gt;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "&lt;div class=\"engineering-container\"&gt;",
            "lineNumber": 1
          },
          {
            "text": "    &lt;div class=\"button-stack\"&gt;",
            "lineNumber": 2
          },
          {
            "text": "        &lt;!-- Hand Program: Hammer icon (Reddish) --&gt;",
            "lineNumber": 3
          },
          {
            "text": "        &lt;RadzenButton Text=\"Hand Program\" Icon=\"build\" Class=\"eng-btn btn-icon-red\" /&gt;",
            "lineNumber": 4
          },
          {
            "text": "        ",
            "lineNumber": 5
          },
          {
            "text": "        &lt;!-- IO Editor: Chip/Board icon (Greenish) --&gt;",
            "lineNumber": 6
          },
          {
            "text": "        &lt;RadzenButton Text=\"IO Editor\" Icon=\"memory\" Class=\"eng-btn btn-icon-green\" /&gt;",
            "lineNumber": 7
          },
          {
            "text": "        ",
            "lineNumber": 8
          },
          {
            "text": "        &lt;!-- AI &amp; RTD Correction: Gauge icon --&gt;",
            "lineNumber": 9
          },
          {
            "text": "        &lt;RadzenButton Text=\"AI &amp; RTD Correction\" Icon=\"speed\" Class=\"eng-btn\" /&gt;",
            "lineNumber": 10
          },
          {
            "text": "        ",
            "lineNumber": 11
          },
          {
            "text": "        &lt;!-- Disable Test Log: Checkmark icon (Green), Orange styling --&gt;",
            "lineNumber": 12
          },
          {
            "text": "        &lt;RadzenButton Text=\"Disable Test Log\" Icon=\"check_circle\" Class=\"eng-btn active-orange btn-icon-green-bright\" /&gt;",
            "lineNumber": 13
          },
          {
            "text": "        ",
            "lineNumber": 14
          },
          {
            "text": "        &lt;!-- Test Log Viewer: Pen/Paper icon --&gt;",
            "lineNumber": 15
          },
          {
            "text": "        &lt;RadzenButton Text=\"Test Log Viewer\" Icon=\"edit_note\" Class=\"eng-btn\" /&gt;",
            "lineNumber": 16
          },
          {
            "text": "        ",
            "lineNumber": 17
          },
          {
            "text": "        &lt;!-- Test Sequence Editor: List/Code icon --&gt;",
            "lineNumber": 18
          },
          {
            "text": "        &lt;RadzenButton Text=\"Редактор шагов теста\" Icon=\"playlist_add_check\" Class=\"eng-btn\" Click=\"@OpenTestSequenceEditor\" /&gt;",
            "lineNumber": 19
          },
          {
            "text": "        ",
            "lineNumber": 20
          },
          {
            "text": "        &lt;!-- View Gas &amp; DHW Charts: Chart icon --&gt;",
            "lineNumber": 21
          },
          {
            "text": "        &lt;RadzenButton Text=\"View Gas &amp; DHW Charts\" Icon=\"show_chart\" Class=\"eng-btn\" /&gt;",
            "lineNumber": 22
          },
          {
            "text": "    &lt;/div&gt;",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "    &lt;div class=\"language-selector\"&gt;",
            "lineNumber": 25
          },
          {
            "text": "        &lt;span class=\"language-label\"&gt;Language&lt;/span&gt;",
            "lineNumber": 26
          },
          {
            "text": "        &lt;RadzenDropDown Data=\"@languages\" @bind-Value=\"selectedLanguage\" Style=\"width: 250px;\" /&gt;",
            "lineNumber": 27
          },
          {
            "text": "    &lt;/div&gt;",
            "lineNumber": 28
          },
          {
            "text": "&lt;/div&gt;",
            "lineNumber": 29
          }
        ]
      },
      "score": 0.12500303983688354
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\obj\\project.assets.json",
        "range": {
          "startPosition": {
            "line": 228,
            "column": 8
          },
          "endPosition": {
            "line": 288
          }
        },
        "contents": "\"type\": \"package\",\n        \"dependencies\": {\n          \"Microsoft.Extensions.Configuration\": \"10.0.0\",\n          \"Microsoft.Extensions.Configuration.Abstractions\": \"10.0.0\"\n        },\n        \"compile\": {\n          \"lib/net10.0/Microsoft.Extensions.Configuration.Binder.dll\": {\n            \"related\": \".xml\"\n          }\n        },\n        \"runtime\": {\n          \"lib/net10.0/Microsoft.Extensions.Configuration.Binder.dll\": {\n            \"related\": \".xml\"\n          }\n        },\n        \"build\": {\n          \"buildTransitive/netstandard2.0/Microsoft.Extensions.Configuration.Binder.targets\": {}\n        }\n      },\n      \"Microsoft.Extensions.Configuration.FileExtensions/10.0.0\": {\n        \"type\": \"package\",\n        \"dependencies\": {\n          \"Microsoft.Extensions.Configuration\": \"10.0.0\",\n          \"Microsoft.Extensions.Configuration.Abstractions\": \"10.0.0\",\n          \"Microsoft.Extensions.FileProviders.Abstractions\": \"10.0.0\",\n          \"Microsoft.Extensions.FileProviders.Physical\": \"10.0.0\",\n          \"Microsoft.Extensions.Primitives\": \"10.0.0\"\n        },\n        \"compile\": {\n          \"lib/net10.0/Microsoft.Extensions.Configuration.FileExtensions.dll\": {\n            \"related\": \".xml\"\n          }\n        },\n        \"runtime\": {\n          \"lib/net10.0/Microsoft.Extensions.Configuration.FileExtensions.dll\": {\n            \"related\": \".xml\"\n          }\n        },\n        \"build\": {\n          \"buildTransitive/net8.0/_._\": {}\n        }\n      },\n      \"Microsoft.Extensions.Configuration.Json/10.0.0\": {\n        \"type\": \"package\",\n        \"dependencies\": {\n          \"Microsoft.Extensions.Configuration\": \"10.0.0\",\n          \"Microsoft.Extensions.Configuration.Abstractions\": \"10.0.0\",\n          \"Microsoft.Extensions.Configuration.FileExtensions\": \"10.0.0\",\n          \"Microsoft.Extensions.FileProviders.Abstractions\": \"10.0.0\"\n        },\n        \"compile\": {\n          \"lib/net10.0/Microsoft.Extensions.Configuration.Json.dll\": {\n            \"related\": \".xml\"\n          }\n        },\n        \"runtime\": {\n          \"lib/net10.0/Microsoft.Extensions.Configuration.Json.dll\": {\n            \"related\": \".xml\"\n          }\n        },",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"type\": \"package\",",
            "lineNumber": 229
          },
          {
            "text": "        \"dependencies\": {",
            "lineNumber": 230
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration\": \"10.0.0\",",
            "lineNumber": 231
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration.Abstractions\": \"10.0.0\"",
            "lineNumber": 232
          },
          {
            "text": "        },",
            "lineNumber": 233
          },
          {
            "text": "        \"compile\": {",
            "lineNumber": 234
          },
          {
            "text": "          \"lib/net10.0/Microsoft.Extensions.Configuration.Binder.dll\": {",
            "lineNumber": 235
          },
          {
            "text": "            \"related\": \".xml\"",
            "lineNumber": 236
          },
          {
            "text": "          }",
            "lineNumber": 237
          },
          {
            "text": "        },",
            "lineNumber": 238
          },
          {
            "text": "        \"runtime\": {",
            "lineNumber": 239
          },
          {
            "text": "          \"lib/net10.0/Microsoft.Extensions.Configuration.Binder.dll\": {",
            "lineNumber": 240
          },
          {
            "text": "            \"related\": \".xml\"",
            "lineNumber": 241
          },
          {
            "text": "          }",
            "lineNumber": 242
          },
          {
            "text": "        },",
            "lineNumber": 243
          },
          {
            "text": "        \"build\": {",
            "lineNumber": 244
          },
          {
            "text": "          \"buildTransitive/netstandard2.0/Microsoft.Extensions.Configuration.Binder.targets\": {}",
            "lineNumber": 245
          },
          {
            "text": "        }",
            "lineNumber": 246
          },
          {
            "text": "      },",
            "lineNumber": 247
          },
          {
            "text": "      \"Microsoft.Extensions.Configuration.FileExtensions/10.0.0\": {",
            "lineNumber": 248
          },
          {
            "text": "        \"type\": \"package\",",
            "lineNumber": 249
          },
          {
            "text": "        \"dependencies\": {",
            "lineNumber": 250
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration\": \"10.0.0\",",
            "lineNumber": 251
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration.Abstractions\": \"10.0.0\",",
            "lineNumber": 252
          },
          {
            "text": "          \"Microsoft.Extensions.FileProviders.Abstractions\": \"10.0.0\",",
            "lineNumber": 253
          },
          {
            "text": "          \"Microsoft.Extensions.FileProviders.Physical\": \"10.0.0\",",
            "lineNumber": 254
          },
          {
            "text": "          \"Microsoft.Extensions.Primitives\": \"10.0.0\"",
            "lineNumber": 255
          },
          {
            "text": "        },",
            "lineNumber": 256
          },
          {
            "text": "        \"compile\": {",
            "lineNumber": 257
          },
          {
            "text": "          \"lib/net10.0/Microsoft.Extensions.Configuration.FileExtensions.dll\": {",
            "lineNumber": 258
          },
          {
            "text": "            \"related\": \".xml\"",
            "lineNumber": 259
          },
          {
            "text": "          }",
            "lineNumber": 260
          },
          {
            "text": "        },",
            "lineNumber": 261
          },
          {
            "text": "        \"runtime\": {",
            "lineNumber": 262
          },
          {
            "text": "          \"lib/net10.0/Microsoft.Extensions.Configuration.FileExtensions.dll\": {",
            "lineNumber": 263
          },
          {
            "text": "            \"related\": \".xml\"",
            "lineNumber": 264
          },
          {
            "text": "          }",
            "lineNumber": 265
          },
          {
            "text": "        },",
            "lineNumber": 266
          },
          {
            "text": "        \"build\": {",
            "lineNumber": 267
          },
          {
            "text": "          \"buildTransitive/net8.0/_._\": {}",
            "lineNumber": 268
          },
          {
            "text": "        }",
            "lineNumber": 269
          },
          {
            "text": "      },",
            "lineNumber": 270
          },
          {
            "text": "      \"Microsoft.Extensions.Configuration.Json/10.0.0\": {",
            "lineNumber": 271
          },
          {
            "text": "        \"type\": \"package\",",
            "lineNumber": 272
          },
          {
            "text": "        \"dependencies\": {",
            "lineNumber": 273
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration\": \"10.0.0\",",
            "lineNumber": 274
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration.Abstractions\": \"10.0.0\",",
            "lineNumber": 275
          },
          {
            "text": "          \"Microsoft.Extensions.Configuration.FileExtensions\": \"10.0.0\",",
            "lineNumber": 276
          },
          {
            "text": "          \"Microsoft.Extensions.FileProviders.Abstractions\": \"10.0.0\"",
            "lineNumber": 277
          },
          {
            "text": "        },",
            "lineNumber": 278
          },
          {
            "text": "        \"compile\": {",
            "lineNumber": 279
          },
          {
            "text": "          \"lib/net10.0/Microsoft.Extensions.Configuration.Json.dll\": {",
            "lineNumber": 280
          },
          {
            "text": "            \"related\": \".xml\"",
            "lineNumber": 281
          },
          {
            "text": "          }",
            "lineNumber": 282
          },
          {
            "text": "        },",
            "lineNumber": 283
          },
          {
            "text": "        \"runtime\": {",
            "lineNumber": 284
          },
          {
            "text": "          \"lib/net10.0/Microsoft.Extensions.Configuration.Json.dll\": {",
            "lineNumber": 285
          },
          {
            "text": "            \"related\": \".xml\"",
            "lineNumber": 286
          },
          {
            "text": "          }",
            "lineNumber": 287
          },
          {
            "text": "        },",
            "lineNumber": 288
          }
        ]
      },
      "score": 0.12443970143795013
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---



---


Выявлены критические проблемы. Исправляю их:


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Исправить race condition в OpcUaConnectionService.StartAsync
- [ ] Исправить race condition в OpcUaConnectionService.StopAsync с DisposeReconnectHandler
- [ ] Исправить race condition в OpcUaSubscriptionService с _disposeCts
- [ ] Исправить fire-and-forget в OpcUaSubscriptionService.OnConnectionChanged
- [ ] Исправить race condition в OpcUaReadWriteService с сессией

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaConnectionService.cs",
  "offset": 28,
  "limit": 35,
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaConnectionService.cs"
}
```
Result:

```json
{
  "contents": "        public async Task StartAsync(CancellationToken ct = default)\n        {\n            if (_connectLoopTask is { IsCompleted: false })\n            {\n                return;\n            }\n            _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            await InitializeApplicationConfigAsync();\n            _connectLoopTask = ConnectLoopAsync(_cts.Token);\n        }\n\n        public async Task StopAsync()\n        {\n            await CancelConnectionAsync();\n            DisposeReconnectHandler();\n            await _sessionLock.WaitAsync();\n            try\n            {\n                await CloseSessionAsync();\n            }\n            finally\n            {\n                _sessionLock.Release();\n            }\n            NotifyConnectionChanged(false);\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            await StopAsync();\n            _sessionLock.Dispose();\n        }\n\n        private async Task InitializeApplicationConfigAsync()\n        {",
  "totalLinesInFile": 318
}
```
Status: **completed**


</details>
</tool-use>

---



---


Исправляю критические проблемы:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaConnectionService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "9cd0cbf0-f978-4d8c-bc54-56dcc2b77a7e",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaConnectionService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "83809361-f974-4c4f-82b7-941435dbbde3",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaConnectionService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "5c405bc8-1fbb-492a-912a-cc73bb660834",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Исправить race condition в OpcUaConnectionService.StartAsync
- [x] Исправить race condition в OpcUaConnectionService.StopAsync с DisposeReconnectHandler
- [ ] Исправить race condition в OpcUaSubscriptionService с _disposeCts
- [ ] Исправить fire-and-forget в OpcUaSubscriptionService.OnConnectionChanged
- [ ] Исправить race condition в OpcUaReadWriteService с сессией

</details>
</tool-use>

---



---


Исправляю проблемы в `OpcUaSubscriptionService`:


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Исправить race condition в OpcUaConnectionService.StartAsync
- [x] Исправить race condition в OpcUaConnectionService.StopAsync с DisposeReconnectHandler
- [-] Исправить race condition в OpcUaSubscriptionService с _disposeCts
- [ ] Исправить fire-and-forget в OpcUaSubscriptionService.OnConnectionChanged
- [ ] Исправить race condition в OpcUaReadWriteService с сессией

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaSubscriptionService.cs",
  "offset": 109,
  "limit": 30,
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "        public async ValueTask DisposeAsync()\n        {\n            if (_disposed)\n            {\n                return;\n            }\n            _disposed = true;\n            logger.LogInformation(\"Disposing OpcUaSubscriptionService with {Count} active subscriptions\", _subscriptions.Count);\n            await _disposeCts.CancelAsync();\n            DetachConnectionEvents();\n            await _connectionChangeGate.WaitAsync();\n            try\n            {\n                await DisposeAllSubscriptionsAsync();\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n                _connectionChangeGate.Dispose();\n                _disposeCts.Dispose();\n            }\n        }\n\n        private async Task DisposeAllSubscriptionsAsync(bool clearCallbacks = true)\n        {\n            foreach (var subscription in _subscriptions.Values.ToArray())\n            {\n                await SafeRemoveSubscriptionAsync(subscription);\n            }\n            _subscriptions.Clear();",
  "totalLinesInFile": 335
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_file_v2">
<details>
<summary>Tool use: **read_file_v2**</summary>


Parameters:

```json
{
  "targetFile": "Services/OpcUa/OpcUaSubscriptionService.cs",
  "offset": 260,
  "limit": 55,
  "charsLimit": 1000000,
  "effectiveUri": "Services/OpcUa/OpcUaSubscriptionService.cs"
}
```
Result:

```json
{
  "contents": "        private void OnConnectionChanged(object? sender, bool connected)\n            =&gt; _ = OnConnectionChangedAsync(connected);\n\n        private async Task OnConnectionChangedAsync(bool connected)\n        {\n            if (_disposed)\n            {\n                return;\n            }\n\n            try\n            {\n                logger.LogDebug(\"Connection state changed: Connected={Connected}, ActiveSubscriptions={Count}\", connected, _callbacks.Count);\n                await HandleConnectionChangeSafelyAsync(connected);\n            }\n            catch (OperationCanceledException)\n            {\n                // Normal cancellation during dispose\n            }\n            catch (ObjectDisposedException)\n            {\n                // Service was disposed during event handling\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Unhandled error in connection change handler\");\n            }\n        }\n\n        private async Task HandleConnectionChangeSafelyAsync(bool connected)\n        {\n            await _connectionChangeGate.WaitAsync(_disposeCts.Token);\n            try\n            {\n                if (connected)\n                {\n                    await ResubscribeAllAsync();\n                }\n                else\n                {\n                    await DropAllSubscriptionsAsync();\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n                logger.LogDebug(\"Connection change handling aborted: service was disposed during operation\");\n            }\n            catch (Exception ex)\n            {\n                logger.LogError(ex, \"Error handling connection change. Connected={Connected}, SubscriptionCount={Count}\", connected, _subscriptions.Count);\n            }\n            finally\n            {\n                _connectionChangeGate.Release();\n            }",
  "totalLinesInFile": 335
}
```
Status: **completed**


</details>
</tool-use>

---



---


Исправляю проблемы в `OpcUaSubscriptionService`:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaSubscriptionService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "7b5a18d6-c4ad-41e0-92dd-20a1b875bb12",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaSubscriptionService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "e8ef7938-ae4a-403e-8d4a-f848ebd06413",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Исправить race condition в OpcUaConnectionService.StartAsync
- [x] Исправить race condition в OpcUaConnectionService.StopAsync с DisposeReconnectHandler
- [x] Исправить race condition в OpcUaSubscriptionService с _disposeCts
- [x] Исправить fire-and-forget в OpcUaSubscriptionService.OnConnectionChanged
- [-] Исправить race condition в OpcUaReadWriteService с сессией

</details>
</tool-use>

---



---


Исправляю проблему в `OpcUaReadWriteService`:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaReadWriteService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "0d2e70de-5d8e-43fd-a3ec-4dbbe349ffb4",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "Services/OpcUa/OpcUaReadWriteService.cs"
}
```
Additional data:

```json
{
  "codeblockId": "26e685a8-4040-40da-be9f-117cbcfb5db7",
  "reviewData": {
    "status": "None",
    "selectedOption": "accept",
    "isShowingInput": false,
    "firstTimeReviewMode": false
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Исправить race condition в OpcUaConnectionService.StartAsync
- [x] Исправить race condition в OpcUaConnectionService.StopAsync с DisposeReconnectHandler
- [x] Исправить race condition в OpcUaSubscriptionService с _disposeCts
- [x] Исправить fire-and-forget в OpcUaSubscriptionService.OnConnectionChanged
- [x] Исправить race condition в OpcUaReadWriteService с сессией

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "Services/OpcUa"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "Services/OpcUa"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---



---


Проверяю, нет ли других проблем с утечками ресурсов:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "IDisposable|IAsyncDisposable",
  "path": "Services/OpcUa",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "IDisposable|IAsyncDisposable",
    "path": "Services/OpcUa",
    "outputMode": "content",
    "workspaceResults": {
      "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid": {
        "content": {
          "matches": [
            {
              "file": "Services\\OpcUa\\Interface\\IOpcUaSubscriptionService.cs",
              "matches": [
                {
                  "lineNumber": 3,
                  "content": "    public interface IOpcUaSubscriptionService : IAsyncDisposable"
                }
              ]
            },
            {
              "file": "Services\\OpcUa\\Interface\\IOpcUaConnectionService.cs",
              "matches": [
                {
                  "lineNumber": 5,
                  "content": "    public interface IOpcUaConnectionService : IAsyncDisposable"
                }
              ]
            }
          ],
          "totalLines": 2,
          "totalMatchedLines": 2
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Are there any memory leaks or resource leaks in OPC UA services?",
  "includePattern": "Services/OpcUa",
  "topK": 10,
  "explanation": ""
}
```
Status: **completed**


</details>
</tool-use>

---



---


Проверяю использование событий на утечки:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "ConnectionChanged|KeepAlive|Notification",
  "path": "Services/OpcUa",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "ConnectionChanged|KeepAlive|Notification",
    "path": "Services/OpcUa",
    "outputMode": "content",
    "workspaceResults": {
      "d:\\projects\\Final_Test_Hybrid\\Final_Test_Hybrid": {
        "content": {
          "matches": [
            {
              "file": "Services\\OpcUa\\OpcUaSubscriptionService.cs",
              "matches": [
                {
                  "lineNumber": 33,
                  "content": "                connectionService.ConnectionChanged += OnConnectionChanged;"
                },
                {
                  "lineNumber": 189,
                  "content": "            monitoredItem.Notification += (item, e) =&gt;"
                },
                {
                  "lineNumber": 193,
                  "content": "                    if (e.NotificationValue is not MonitoredItemNotification notification)"
                },
                {
                  "lineNumber": 258,
                  "content": "                connectionService.ConnectionChanged += OnConnectionChanged;"
                },
                {
                  "lineNumber": 271,
                  "content": "                connectionService.ConnectionChanged -= OnConnectionChanged;"
                },
                {
                  "lineNumber": 276,
                  "content": "        private void OnConnectionChanged(object? sender, bool connected)"
                },
                {
                  "lineNumber": 279,
                  "content": "            _ = OnConnectionChangedAsync(connected);"
                },
                {
                  "lineNumber": 282,
                  "content": "        private async Task OnConnectionChangedAsync(bool connected)"
                }
              ]
            },
            {
              "file": "Services\\OpcUa\\OpcUaConnectionService.cs",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "        public event EventHandler&lt;bool&gt;? ConnectionChanged;"
                },
                {
                  "lineNumber": 60,
                  "content": "            NotifyConnectionChanged(false);"
                },
                {
                  "lineNumber": 153,
                  "content": "                Session.KeepAlive += OnSessionKeepAlive;"
                },
                {
                  "lineNumber": 155,
                  "content": "                NotifyConnectionChanged(true);"
                },
                {
                  "lineNumber": 164,
                  "content": "                NotifyConnectionChanged(false);"
                },
                {
                  "lineNumber": 172,
                  "content": "        private void OnSessionKeepAlive(ISession session, KeepAliveEventArgs e)"
                },
                {
                  "lineNumber": 174,
                  "content": "            if (ShouldSkipKeepAlive(e))"
                },
                {
                  "lineNumber": 179,
                  "content": "            NotifyConnectionChanged(false);"
                },
                {
                  "lineNumber": 183,
                  "content": "        private bool ShouldSkipKeepAlive(KeepAliveEventArgs e)"
                },
                {
                  "lineNumber": 225,
                  "content": "                NotifyConnectionChanged(true);"
                },
                {
                  "lineNumber": 232,
                  "content": "                    oldSession.KeepAlive -= OnSessionKeepAlive;"
                },
                {
                  "lineNumber": 242,
                  "content": "            Session.KeepAlive += OnSessionKeepAlive;"
                },
                {
                  "lineNumber": 244,
                  "content": "            NotifyConnectionChanged(true);"
                },
                {
                  "lineNumber": 247,
                  "content": "        private void NotifyConnectionChanged(bool connected)"
                },
                {
                  "lineNumber": 254,
                  "content": "            ConnectionChanged?.Invoke(this, connected);"
                },
                {
                  "lineNumber": 285,
                  "content": "            Session.KeepAlive -= OnSessionKeepAlive;"
                }
              ]
            },
            {
              "file": "Services\\OpcUa\\Interface\\IOpcUaConnectionService.cs",
              "matches": [
                {
                  "lineNumber": 9,
                  "content": "        event EventHandler&lt;bool&gt;? ConnectionChanged;"
                }
              ]
            }
          ],
          "totalLines": 25,
          "totalMatchedLines": 25
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---



---


## Результаты проверки и исправления

### Исправленные критические проблемы

1. OpcUaConnectionService.cs:
   - Исправлен race condition в `StartAsync` — добавлена блокировка для защиты от параллельного запуска
   - Исправлен race condition в `StopAsync` — `DisposeReconnectHandler()` теперь вызывается внутри блокировки
   - Добавлена обработка исключений при освобождении старой сессии в `UpdateSessionIfReconnected`

2. OpcUaSubscriptionService.cs:
   - Исправлен race condition с `_disposeCts` — добавлена проверка `_disposed` перед использованием токена
   - Улучшена обработка исключений в `DisposeAsync` для безопасного освобождения ресурсов
   - Улучшена обработка исключений в `HandleConnectionChangeSafelyAsync`

3. OpcUaReadWriteService.cs:
   - Исправлен race condition — добавлена повторная проверка подключения перед использованием сессии

### Проверка на утечки ресурсов

- SemaphoreSlim — освобождается в `DisposeAsync`
- CancellationTokenSource — освобождается корректно
- Session — освобождается в `CloseSessionAsync`
- SessionReconnectHandler — освобождается в `DisposeReconnectHandler`
- Подписки (Subscriptions) — освобождаются в `DisposeAllSubscriptionsAsync`
- События — правильно отписываются (`KeepAlive`, `ConnectionChanged`)

### Итог

Код стабилен. Критические race conditions исправлены, утечек ресурсов не обнаружено. Все ресурсы освобождаются корректно. Код готов к использованию в HMI-приложении.

Все изменения минимальны и не усложняют код — только необходимые исправления для безопасности.

---

