В целом — да, план стал корректнее: гонка закрыта, DisposeAsync теперь ждёт оба типа операций. Два нюанса, которые я бы учёл:

Лучше привязать PauseIfStillNeeded именно к AutoModeDisabled, чтобы в будущем PauseAndWait по другой причине не начал зависеть от _autoReady. Самый надёжный вариант — сделать раннюю проверку в ProcessInterruptAsync по reason (до NotifyInterrupt) и return, либо передать reason в ExecuteInterruptActionAsync.
Сейчас предупреждение/сообщение всё равно покажутся, даже если _autoReady уже восстановлен. Это не ломает логику, но может давать ложное предупреждение. Если хочешь избежать — перенеси проверку _autoReady.IsReady раньше NotifyInterrupt.