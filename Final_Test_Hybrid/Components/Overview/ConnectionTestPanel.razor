@using System.Globalization
@using Final_Test_Hybrid.Services.Diagnostic.Access
@using Final_Test_Hybrid.Services.Diagnostic.Protocol.CommandQueue
@using Final_Test_Hybrid.Services.Diagnostic.Protocol
@using Final_Test_Hybrid.Services.Diagnostic.Models
@using Final_Test_Hybrid.Services.Diagnostic.Models.Enums
@using Final_Test_Hybrid.Services.Diagnostic.Connection
@using Final_Test_Hybrid.Services.Diagnostic.Services
@using Microsoft.Extensions.Options
@inject IModbusDispatcher Dispatcher
@inject RegisterReader Reader
@inject RegisterWriter Writer
@inject IOptions<DiagnosticSettings> Settings
@inject IOptions<ModbusDispatcherOptions> DispatcherOptions
@inject AccessLevelManager AccessLevelManager
@inject DiagnosticManualSessionState ManualSessionState
@implements IAsyncDisposable

<div class="connection-test-container">
    <!-- Status Panel -->
    <div class="status-panel">
        <div class="status-title">СТАТУС СОЕДИНЕНИЯ</div>
        <div class="status-indicators">
            <div class="status-item">
                <div class="led @(_isStarted ? "led-green" : "led-gray")"></div>
                <span>Запущен</span>
            </div>
            <div class="status-item">
                <div class="led @(_isConnected ? "led-green" : "led-gray")"></div>
                <span>Подключен</span>
            </div>
            <div class="status-item">
                <div class="led @(_isReconnecting ? "led-yellow" : "led-gray")"></div>
                <span>Переподключение</span>
            </div>
        </div>
        <div class="status-values">
            <span>ModeKey: @FormatModeKey(_pingData?.ModeKey)</span>
            <span>BoilerStatus: @(_pingData?.BoilerStatus.ToString() ?? "—")</span>
        </div>
    </div>

    <div class="operation-panel mode-panel">
        <div class="panel-title">РЕЖИМ КОТЛА</div>

        <div class="row-item">
            <span class="field-label">Режим:</span>
            <RadzenDropDown TValue="BoilerModePreset"
                            Data="@BoilerModePresets"
                            TextProperty="Name"
                            @bind-Value="_selectedModePreset"
                            Change="@OnModePresetChanged"
                            class="scada-dropdown" />
        </div>

        <div class="row-item">
            <RadzenButton Text="УСТАНОВИТЬ РЕЖИМ"
                          Click="@SetBoilerModeAsync"
                          Disabled="@(_isSettingMode || !_isConnected)"
                          class="scada-button" />
        </div>

        <div class="result-area">
            @if (!string.IsNullOrEmpty(_modeWriteError))
            {
                <span class="error-text">Ошибка: @_modeWriteError</span>
            }
            else if (!string.IsNullOrEmpty(_modeWriteResult))
            {
                <span class="result-text">@_modeWriteResult</span>
            }
        </div>

        @if (_selectedModePreset != null && !string.IsNullOrEmpty(_selectedModePreset.Description))
        {
            <div class="description-text">@_selectedModePreset.Description</div>
        }
    </div>

    <div class="panels-row">
        <!-- Read Panel -->
        <div class="operation-panel">
            <div class="panel-title">ЧТЕНИЕ РЕГИСТРА</div>

            <div class="row-item">
                <span class="field-label">Регистр:</span>
                <RadzenDropDown TValue="RegisterPreset"
                                Data="@ReadPresets"
                                TextProperty="Name"
                                @bind-Value="_selectedReadPreset"
                                Change="@OnReadPresetChanged"
                                class="scada-dropdown" />
            </div>

            @if (_selectedReadPreset?.Address == 0)
            {
                <div class="row-item">
                    <span class="field-label">Адрес:</span>
                    <RadzenNumeric TValue="ushort"
                                   @bind-Value="_readAddress"
                                   class="scada-input" />
                </div>
            }

            <div class="row-item">
                <span class="field-label">Тип:</span>
                <RadzenDropDown TValue="string"
                                Data="@DataTypes"
                                @bind-Value="_selectedReadType"
                                class="scada-dropdown" />
            </div>

            <div class="row-item">
                <RadzenButton Text="ЧИТАТЬ"
                              Click="@ReadRegisterAsync"
                              Disabled="@(_isReading || !_isConnected)"
                              class="scada-button" />
            </div>

            <div class="result-area">
                @if (!string.IsNullOrEmpty(_readError))
                {
                    <span class="error-text">Ошибка: @_readError</span>
                }
                else if (!string.IsNullOrEmpty(_readResult))
                {
                    <span class="result-text">Результат: @_readResult</span>
                }
            </div>

            @if (_selectedReadPreset != null && !string.IsNullOrEmpty(_selectedReadPreset.Description))
            {
                <div class="description-text">@_selectedReadPreset.Description</div>
            }
        </div>

        <!-- Write Panel -->
        <div class="operation-panel">
            <div class="panel-title">ЗАПИСЬ РЕГИСТРА</div>

            <div class="row-item">
                <span class="field-label">Регистр:</span>
                <RadzenDropDown TValue="RegisterPreset"
                                Data="@WritePresets"
                                TextProperty="Name"
                                @bind-Value="_selectedWritePreset"
                                Change="@OnWritePresetChanged"
                                class="scada-dropdown" />
            </div>

            @if (_selectedWritePreset?.Address == 0)
            {
                <div class="row-item">
                    <span class="field-label">Адрес:</span>
                    <RadzenNumeric TValue="ushort"
                                   @bind-Value="_writeAddress"
                                   class="scada-input" />
                </div>
            }

            <div class="row-item">
                <span class="field-label">Тип:</span>
                <RadzenDropDown TValue="string"
                                Data="@DataTypes"
                                @bind-Value="_selectedWriteType"
                                class="scada-dropdown" />
            </div>

            <div class="row-item">
                <span class="field-label">Значение:</span>
                <RadzenTextBox @bind-Value="_writeValue" class="scada-input" />
            </div>

            <div class="row-item">
                <RadzenButton Text="ЗАПИСАТЬ"
                              Click="@WriteRegisterAsync"
                              Disabled="@(_isWriting || !_isConnected)"
                              class="scada-button" />
            </div>

            <div class="result-area">
                @if (!string.IsNullOrEmpty(_writeError))
                {
                    <span class="error-text">Ошибка: @_writeError</span>
                }
                else if (_writeSuccess)
                {
                    <span class="result-text">Результат: OK</span>
                }
            </div>

            @if (_selectedWritePreset != null && !string.IsNullOrEmpty(_selectedWritePreset.Description))
            {
                <div class="description-text">@_selectedWritePreset.Description</div>
            }
        </div>
    </div>
</div>

@code {
    private const ushort DisplayBrightnessAddress = 1048;
    private const ushort DisplayBrightnessMin = 10;
    private const ushort DisplayBrightnessMax = 100;
    private const ushort FirmwareVersionMajorAddress = 1055;
    private const ushort FirmwareVersionMinorAddress = 1056;
    private const uint StandModeKey = 0xD7F8_DB56;
    private const uint EngineeringModeKey = 0xFA87_CD5E;
    private const int ModeVerificationCycles = 2;
    private const int ModeVerificationPollDelayMs = 200;

    private static readonly RegisterPreset[] ReadPresets =
    [
        new("Ключ режима", 1000, "UInt32", "Ключ режима (стенд/инженер)"),
        new("Статус котла", 1005, "Int16", "Статус котла (-1=тест, 0=вкл, 1-10=режимы)"),
        new("Версия прошивки", FirmwareVersionMajorAddress, "UInt16", "Версия прошивки ЭБУ (1055/1056)", RegisterPresetKind.FirmwareVersion),
        new("Тип мощности", 1002, "UInt16", "Тип мощности котла"),
        new("Тип насоса", 1003, "UInt16", "Тип насоса"),
        new("Тип датчика давл.", 1004, "UInt16", "Тип датчика давления"),
        new("Тип подключения", 1054, "UInt16", "Тип подключения системы"),
        new("Термостат STB", 1066, "UInt16", "Термостат STB (0=closed, 1=open)"),
        new("Пневмовыключатель", 1067, "UInt16", "Пневматический выключатель"),
        new("Датчик давления", 1068, "UInt16", "Датчик давления воды"),
        new("Трёхход. клапан", 1069, "UInt16", "Трёхходовой клапан"),
        new("Состояние насоса", 1070, "UInt16", "Состояние насоса"),
        new("Комн. термостат", 1071, "UInt16", "Комнатный термостат"),
        new("Тип газ. регулятора", 1157, "UInt16", "Тип регулятора газа"),
        new("Вручную...", 0, "UInt16", "Ввести адрес вручную"),
    ];

    private static readonly RegisterPreset[] WritePresets =
    [
        new("Подсветка дисплея", 1048, "UInt16", "Подсветка дисплея (%), диапазон 10..100"),
        new("Вручную...", 0, "UInt16", "Ввести адрес вручную"),
    ];

    private static readonly BoilerModePreset[] BoilerModePresets =
    [
        new("Стенд", BoilerMode.Stand, "ModeKey 0xD7F8DB56 (1000/1001)"),
        new("Инженерный", BoilerMode.Engineering, "ModeKey 0xFA87CD5E (1000/1001)"),
        new("Обычный", BoilerMode.Normal, "Сброс в обычный режим (ключ != стенд/инженер)"),
    ];

    private static readonly string[] DataTypes = ["UInt16", "Int16", "UInt32", "Float"];

    // Status (reactive from events)
    private bool _isStarted;
    private bool _isConnected;
    private bool _isReconnecting;
    private DiagnosticPingData? _pingData;
    private bool _disposed;
    private bool _manualSessionEntered;

    // Read state
    private RegisterPreset? _selectedReadPreset = ReadPresets[0];
    private ushort _readAddress = 1005;
    private string _selectedReadType = "UInt32";
    private string _readResult = "";
    private string? _readError;
    private bool _isReading;

    // Write state
    private RegisterPreset? _selectedWritePreset = WritePresets[0];
    private ushort _writeAddress = DisplayBrightnessAddress;
    private string _selectedWriteType = "UInt16";
    private string _writeValue = "";
    private string? _writeError;
    private bool _writeSuccess;
    private bool _isWriting;

    // Mode state
    private BoilerModePreset? _selectedModePreset = BoilerModePresets[0];
    private string? _modeWriteError;
    private string _modeWriteResult = "";
    private bool _isSettingMode;

    /// <inheritdoc />
    protected override async Task OnInitializedAsync()
    {
        ManualSessionState.EnterConnectionTest();
        _manualSessionEntered = true;

        // Subscribe to dispatcher events
        Dispatcher.Connected += OnConnected;
        Dispatcher.Disconnecting += OnDisconnecting;
        Dispatcher.Stopped += OnStopped;
        Dispatcher.PingDataUpdated += OnPingDataUpdated;

        // Start dispatcher
        await Dispatcher.StartAsync();

        // Update initial state
        UpdateStatus();
    }

    /// <summary>
    /// Обновляет статус подключения из диспетчера.
    /// </summary>
    private void UpdateStatus()
    {
        _isStarted = Dispatcher.IsStarted;
        _isConnected = Dispatcher.IsConnected;
        _isReconnecting = Dispatcher.IsReconnecting;
        _pingData = Dispatcher.LastPingData;
    }

    /// <summary>
    /// Обработчик события подключения.
    /// </summary>
    private void OnConnected()
    {
        if (_disposed)
        {
            return;
        }
        _ = InvokeAsync(() =>
        {
            UpdateStatus();
            StateHasChanged();
        });
    }

    /// <summary>
    /// Обработчик события отключения.
    /// </summary>
    private Task OnDisconnecting()
    {
        if (_disposed)
        {
            return Task.CompletedTask;
        }
        return InvokeAsync(() =>
        {
            UpdateStatus();
            StateHasChanged();
        });
    }

    /// <summary>
    /// Обработчик события остановки.
    /// </summary>
    private void OnStopped()
    {
        if (_disposed)
        {
            return;
        }
        _ = InvokeAsync(() =>
        {
            UpdateStatus();
            StateHasChanged();
        });
    }

    /// <summary>
    /// Обработчик обновления данных ping.
    /// </summary>
    private void OnPingDataUpdated(DiagnosticPingData data)
    {
        if (_disposed)
        {
            return;
        }
        _ = InvokeAsync(() =>
        {
            _pingData = data;
            _isConnected = Dispatcher.IsConnected;
            _isReconnecting = Dispatcher.IsReconnecting;
            StateHasChanged();
        });
    }

    /// <summary>
    /// Обработчик изменения preset чтения.
    /// </summary>
    private void OnReadPresetChanged()
    {
        if (_selectedReadPreset == null)
        {
            return;
        }
        if (_selectedReadPreset.Address > 0)
        {
            _readAddress = _selectedReadPreset.Address;
            _selectedReadType = _selectedReadPreset.Type;
        }
        _readResult = "";
        _readError = null;
    }

    /// <summary>
    /// Обработчик изменения preset записи.
    /// </summary>
    private void OnWritePresetChanged()
    {
        if (_selectedWritePreset == null)
        {
            return;
        }
        if (_selectedWritePreset.Address > 0)
        {
            _writeAddress = _selectedWritePreset.Address;
            _selectedWriteType = _selectedWritePreset.Type;
        }
        _writeError = null;
        _writeSuccess = false;
    }

    /// <summary>
    /// Обработчик изменения режима котла.
    /// </summary>
    private void OnModePresetChanged()
    {
        _modeWriteError = null;
        _modeWriteResult = "";
    }

    /// <summary>
    /// Читает регистр по выбранному типу.
    /// </summary>
    private async Task ReadRegisterAsync()
    {
        _isReading = true;
        _readResult = "";
        _readError = null;

        try
        {
            var docAddress = _selectedReadPreset?.Address > 0 ? _selectedReadPreset.Address : _readAddress;
            if (IsFirmwareVersionPreset())
            {
                await ReadFirmwareVersionAsync();
                return;
            }

            var address = (ushort)(docAddress - Settings.Value.BaseAddressOffset);

            switch (_selectedReadType)
            {
                case "UInt16":
                    var resultU16 = await Reader.ReadUInt16Async(address);
                    if (resultU16.Success)
                    {
                        _readResult = FormatUInt16Result(docAddress, resultU16.Value);
                    }
                    else
                    {
                        _readError = resultU16.Error;
                    }
                    break;

                case "Int16":
                    var resultI16 = await Reader.ReadInt16Async(address);
                    if (resultI16.Success)
                    {
                        _readResult = FormatInt16Result(docAddress, resultI16.Value);
                    }
                    else
                    {
                        _readError = resultI16.Error;
                    }
                    break;

                case "UInt32":
                    var resultU32 = await Reader.ReadUInt32Async(address);
                    if (resultU32.Success)
                    {
                        _readResult = FormatUInt32Result(docAddress, resultU32.Value);
                    }
                    else
                    {
                        _readError = resultU32.Error;
                    }
                    break;

                case "Float":
                    var resultFloat = await Reader.ReadFloatAsync(address);
                    if (resultFloat.Success)
                    {
                        _readResult = resultFloat.Value.ToString("F4");
                    }
                    else
                    {
                        _readError = resultFloat.Error;
                    }
                    break;
            }
        }
        catch (Exception ex)
        {
            _readError = ex.Message;
        }
        finally
        {
            _isReading = false;
        }
    }

    /// <summary>
    /// Записывает регистр по выбранному типу.
    /// </summary>
    private async Task WriteRegisterAsync()
    {
        _isWriting = true;
        _writeError = null;
        _writeSuccess = false;

        try
        {
            var docAddress = _selectedWritePreset?.Address > 0 ? _selectedWritePreset.Address : _writeAddress;
            var address = (ushort)(docAddress - Settings.Value.BaseAddressOffset);
            if (!TryValidateWriteValue(docAddress, _selectedWriteType, _writeValue, out var validationError))
            {
                _writeError = validationError;
                return;
            }

            switch (_selectedWriteType)
            {
                case "UInt16":
                    if (!ushort.TryParse(_writeValue, out var u16Value))
                    {
                        _writeError = "Неверный формат UInt16";
                        return;
                    }
                    var resultU16 = await Writer.WriteUInt16Async(address, u16Value);
                    _writeSuccess = resultU16.Success;
                    _writeError = resultU16.Error;
                    break;

                case "Int16":
                    if (!short.TryParse(_writeValue, out var i16Value))
                    {
                        _writeError = "Неверный формат Int16";
                        return;
                    }
                    var resultI16 = await Writer.WriteInt16Async(address, i16Value);
                    _writeSuccess = resultI16.Success;
                    _writeError = resultI16.Error;
                    break;

                case "UInt32":
                    if (!TryParseUInt32Value(_writeValue, out var u32Value))
                    {
                        _writeError = "Неверный формат UInt32 (dec или 0xHEX)";
                        return;
                    }
                    var resultU32 = await Writer.WriteUInt32Async(address, u32Value);
                    _writeSuccess = resultU32.Success;
                    _writeError = resultU32.Error;
                    break;

                case "Float":
                    if (!float.TryParse(_writeValue, out var floatValue))
                    {
                        _writeError = "Неверный формат Float";
                        return;
                    }
                    var resultFloat = await Writer.WriteFloatAsync(address, floatValue);
                    _writeSuccess = resultFloat.Success;
                    _writeError = resultFloat.Error;
                    break;
            }
        }
        catch (Exception ex)
        {
            _writeError = ex.Message;
        }
        finally
        {
            _isWriting = false;
        }
    }

    /// <summary>
    /// Возвращает true, если выбран готовый preset чтения версии прошивки.
    /// </summary>
    private bool IsFirmwareVersionPreset()
    {
        return _selectedReadPreset?.Kind == RegisterPresetKind.FirmwareVersion;
    }

    /// <summary>
    /// Читает версию прошивки (1055/1056) и возвращает её в человекочитаемом виде.
    /// </summary>
    private async Task ReadFirmwareVersionAsync()
    {
        var majorAddress = (ushort)(FirmwareVersionMajorAddress - Settings.Value.BaseAddressOffset);
        var majorResult = await Reader.ReadUInt16Async(majorAddress);
        if (!majorResult.Success)
        {
            _readError = $"1055 (major): {majorResult.Error}";
            return;
        }

        var minorAddress = (ushort)(FirmwareVersionMinorAddress - Settings.Value.BaseAddressOffset);
        var minorResult = await Reader.ReadUInt16Async(minorAddress);
        if (!minorResult.Success)
        {
            _readError = $"1056 (minor): {minorResult.Error}";
            return;
        }

        _readResult = $"Версия прошивки: v{majorResult.Value}.{minorResult.Value} (1055={majorResult.Value}, 1056={minorResult.Value})";
    }

    /// <summary>
    /// Форматирует результат UInt16 для готовых preset-ов в человекочитаемом виде.
    /// </summary>
    private string FormatUInt16Result(ushort docAddress, ushort value)
    {
        return (IsPresetRead(), docAddress) switch
        {
            (true, 1002) => $"{value} ({FormatBoilerPowerType(value)})",
            (true, 1003) => $"{value} ({FormatPumpType(value)})",
            (true, 1004) => $"{value} ({FormatPressureDeviceType(value)})",
            (true, 1054) => $"{value} ({FormatConnectionType(value)})",
            (true, 1066) => $"{value} ({FormatContactState(value)})",
            (true, 1067) => $"{value} ({FormatContactState(value)})",
            (true, 1068) => $"{value} ({FormatContactState(value)})",
            (true, 1069) => $"{value} ({FormatThreeWayValveState(value)})",
            (true, 1070) => $"{value} ({FormatPumpState(value)})",
            (true, 1071) => $"{value} ({FormatContactState(value)})",
            (true, 1157) => $"{value} ({FormatGasRegulatorType(value)})",
            _ => value.ToString(),
        };
    }

    /// <summary>
    /// Форматирует результат Int16 для готовых preset-ов в человекочитаемом виде.
    /// </summary>
    private string FormatInt16Result(ushort docAddress, short value)
    {
        return (IsPresetRead(), docAddress) switch
        {
            (true, 1005) => $"{value} ({FormatBoilerStatus(value)})",
            _ => value.ToString(),
        };
    }

    /// <summary>
    /// Форматирует результат UInt32 для готовых preset-ов в человекочитаемом виде.
    /// </summary>
    private string FormatUInt32Result(ushort docAddress, uint value)
    {
        return (IsPresetRead(), docAddress) switch
        {
            (true, 1000) => $"Ключ режима: 0x{value:X8} ({FormatModeNameByKey(value)})",
            _ => $"{value} (0x{value:X8})",
        };
    }

    /// <summary>
    /// Возвращает true, если чтение выполняется по готовому preset, а не вручную.
    /// </summary>
    private bool IsPresetRead()
    {
        return _selectedReadPreset is { Address: > 0 };
    }

    /// <summary>
    /// Человекочитаемая расшифровка типа мощности.
    /// </summary>
    private static string FormatBoilerPowerType(ushort value)
    {
        return value switch
        {
            (ushort)BoilerPowerType.NotSet => "Не задан",
            (ushort)BoilerPowerType.Type21_18kW => "Тип 21 (18 кВт)",
            (ushort)BoilerPowerType.Type31_24kW => "Тип 31 (24 кВт)",
            (ushort)BoilerPowerType.Type41_28kW => "Тип 41 (28 кВт)",
            _ => "Неизвестный тип мощности",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка типа насоса.
    /// </summary>
    private static string FormatPumpType(ushort value)
    {
        return value switch
        {
            (ushort)PumpType.NotSet => "Не задан",
            (ushort)PumpType.DWP15_50_G1 => "DWP15-50-G1",
            _ => "Неизвестный тип насоса",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка типа датчика давления.
    /// </summary>
    private static string FormatPressureDeviceType(ushort value)
    {
        return value switch
        {
            (ushort)PressureDeviceType.NotSet => "Не задан",
            (ushort)PressureDeviceType.PressureRelay => "Реле давления",
            _ => "Неизвестный тип датчика давления",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка типа подключения.
    /// </summary>
    private static string FormatConnectionType(ushort value)
    {
        return value switch
        {
            (ushort)ConnectionType.SingleCircuit => "Одноконтурный",
            (ushort)ConnectionType.DualCircuit => "Двухконтурный",
            (ushort)ConnectionType.BoilerWithNTC => "Бойлер с NTC",
            (ushort)ConnectionType.BoilerWithThermostat => "Бойлер с термостатом",
            _ => "Неизвестный тип подключения",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка бинарного контакта.
    /// </summary>
    private static string FormatContactState(ushort value)
    {
        return value switch
        {
            (ushort)ContactState.Open => "Разомкнут",
            (ushort)ContactState.Closed => "Замкнут",
            _ => "Неизвестное состояние контакта",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка состояния трёхходового клапана.
    /// </summary>
    private static string FormatThreeWayValveState(ushort value)
    {
        return value switch
        {
            (ushort)ThreeWayValveState.Unknown => "Неизвестно",
            (ushort)ThreeWayValveState.TransitionToOS => "Переход в ОС",
            (ushort)ThreeWayValveState.OS => "ОС",
            (ushort)ThreeWayValveState.TransitionToDHW => "Переход в ГВС",
            (ushort)ThreeWayValveState.DHW => "ГВС",
            (ushort)ThreeWayValveState.Error => "Ошибка",
            _ => "Неизвестное состояние клапана",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка состояния насоса.
    /// </summary>
    private static string FormatPumpState(ushort value)
    {
        return value switch
        {
            (ushort)PumpState.Off => "Выключен",
            (ushort)PumpState.On => "Включен",
            (ushort)PumpState.Error => "Ошибка",
            _ => "Неизвестное состояние насоса",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка типа газового регулятора.
    /// </summary>
    private static string FormatGasRegulatorType(ushort value)
    {
        return value switch
        {
            (ushort)GasRegulatorType.NotSet => "Не задан",
            (ushort)GasRegulatorType.EBR2008N010901 => "EBR2008N010901",
            _ => "Неизвестный тип регулятора",
        };
    }

    /// <summary>
    /// Человекочитаемая расшифровка статуса котла.
    /// </summary>
    private static string FormatBoilerStatus(short value)
    {
        return value switch
        {
            (short)BoilerStatus.TestingMode => "Тест на линии",
            (short)BoilerStatus.PowerOn => "Включение питания",
            (short)BoilerStatus.BlockB => "Блокировка Б",
            (short)BoilerStatus.BlockA => "Блокировка А",
            (short)BoilerStatus.EmergencyMode => "Аварийный режим",
            (short)BoilerStatus.StandbyMode => "Ожидание",
            (short)BoilerStatus.SetPowerMode => "Установка мощности",
            (short)BoilerStatus.ShortHeatingOS => "Короткий нагрев ОС",
            (short)BoilerStatus.ConstantHeatingOS => "Постоянный нагрев ОС",
            (short)BoilerStatus.LongPurge => "Длинная продувка",
            (short)BoilerStatus.SummerMode => "Лето (ГВС)",
            (short)BoilerStatus.WinterMode => "Зима (ОС+ГВС)",
            _ => "Неизвестный статус",
        };
    }

    /// <summary>
    /// Возвращает имя режима по значению ModeKey.
    /// </summary>
    private static string FormatModeNameByKey(uint modeKey)
    {
        return modeKey switch
        {
            StandModeKey => "Стенд",
            EngineeringModeKey => "Инженерный",
            _ => "Обычный",
        };
    }

    /// <summary>
    /// Записывает выбранный режим котла и проверяет ModeKey.
    /// </summary>
    private async Task SetBoilerModeAsync()
    {
        if (_selectedModePreset == null)
        {
            return;
        }

        _isSettingMode = true;
        _modeWriteError = null;
        _modeWriteResult = "";

        try
        {
            var writeSuccess = await WriteSelectedModeAsync(_selectedModePreset.Mode);
            if (!writeSuccess)
            {
                _modeWriteError = $"Не удалось записать режим \"{_selectedModePreset.Name}\".";
                return;
            }

            var verification = await VerifyModeAsync(_selectedModePreset.Mode);
            if (!verification.Success)
            {
                _modeWriteError = verification.Message;
                return;
            }

            _modeWriteResult = verification.Message;
        }
        catch (Exception ex)
        {
            _modeWriteError = ex.Message;
        }
        finally
        {
            _isSettingMode = false;
        }
    }

    /// <summary>
    /// Выполняет запись ключа режима через AccessLevelManager.
    /// </summary>
    private async Task<bool> WriteSelectedModeAsync(BoilerMode mode)
    {
        return mode switch
        {
            BoilerMode.Stand => await AccessLevelManager.SetStandModeAsync(),
            BoilerMode.Engineering => await AccessLevelManager.SetEngineeringModeAsync(),
            _ => await ResetToNormalModeAsync(),
        };
    }

    /// <summary>
    /// Сбрасывает котел в обычный режим.
    /// </summary>
    private async Task<bool> ResetToNormalModeAsync()
    {
        await AccessLevelManager.ResetToNormalModeAsync();
        return true;
    }

    /// <summary>
    /// Проверяет, что фактический ModeKey соответствует ожидаемому режиму.
    /// </summary>
    private async Task<ModeVerificationResult> VerifyModeAsync(BoilerMode mode)
    {
        if (!Dispatcher.IsConnected)
        {
            return ModeVerificationResult.Fail("Нет подключения к котлу для верификации режима.");
        }

        var timeoutMs = GetModeVerificationTimeoutMs();
        var elapsedMs = 0;

        while (elapsedMs <= timeoutMs)
        {
            var modeKey = Dispatcher.LastPingData?.ModeKey;
            if (modeKey != null && IsExpectedModeKey(mode, modeKey.Value))
            {
                var message = $"Режим подтвержден: {GetModeDisplayName(mode)} ({FormatModeKey(modeKey)})";
                return ModeVerificationResult.Ok(message);
            }

            await Task.Delay(ModeVerificationPollDelayMs);
            elapsedMs += ModeVerificationPollDelayMs;
        }

        var actualModeKey = Dispatcher.LastPingData?.ModeKey;
        var error = $"Режим не подтвержден: ожидался {GetModeDisplayName(mode)}. Фактический ModeKey: {FormatModeKey(actualModeKey)}";
        return ModeVerificationResult.Fail(error);
    }

    /// <summary>
    /// Вычисляет timeout верификации на основе интервала ping.
    /// </summary>
    private int GetModeVerificationTimeoutMs()
    {
        var pingInterval = Math.Clamp(DispatcherOptions.Value.PingIntervalMs, 500, 15000);
        var verifyDelay = Math.Clamp(Settings.Value.WriteVerifyDelayMs, 100, 1000);
        return pingInterval * ModeVerificationCycles + verifyDelay;
    }

    /// <summary>
    /// Проверяет соответствие ModeKey ожидаемому режиму.
    /// </summary>
    private static bool IsExpectedModeKey(BoilerMode mode, uint modeKey)
    {
        return mode switch
        {
            BoilerMode.Stand => modeKey == StandModeKey,
            BoilerMode.Engineering => modeKey == EngineeringModeKey,
            _ => modeKey != StandModeKey && modeKey != EngineeringModeKey,
        };
    }

    /// <summary>
    /// Возвращает отображаемое имя режима.
    /// </summary>
    private static string GetModeDisplayName(BoilerMode mode)
    {
        return mode switch
        {
            BoilerMode.Stand => "Стенд",
            BoilerMode.Engineering => "Инженерный",
            _ => "Обычный",
        };
    }

    /// <summary>
    /// Валидирует специальные ограничения записи по документированным регистрам.
    /// </summary>
    private static bool TryValidateWriteValue(ushort docAddress, string selectedWriteType, string writeValue, out string? error)
    {
        if (docAddress != DisplayBrightnessAddress)
        {
            error = null;
            return true;
        }

        if (selectedWriteType != "UInt16")
        {
            error = "Подсветка дисплея (1048): используйте тип UInt16";
            return false;
        }

        if (!ushort.TryParse(writeValue, out var brightness))
        {
            error = "Подсветка дисплея (1048): нужен UInt16 в диапазоне 10..100";
            return false;
        }

        if (brightness < DisplayBrightnessMin || brightness > DisplayBrightnessMax)
        {
            error = $"Подсветка дисплея (1048): допустимо {DisplayBrightnessMin}..{DisplayBrightnessMax}";
            return false;
        }

        error = null;
        return true;
    }

    /// <summary>
    /// Поддерживает парсинг UInt32 в dec и hex (0x...).
    /// </summary>
    private static bool TryParseUInt32Value(string rawValue, out uint value)
    {
        var normalized = rawValue.Trim();
        if (normalized.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
        {
            return uint.TryParse(
                normalized[2..],
                NumberStyles.AllowHexSpecifier,
                CultureInfo.InvariantCulture,
                out value);
        }

        return uint.TryParse(normalized, NumberStyles.Integer, CultureInfo.InvariantCulture, out value);
    }

    /// <summary>
    /// Форматирует ModeKey для отображения.
    /// </summary>
    private static string FormatModeKey(uint? modeKey)
    {
        if (modeKey == null)
        {
            return "—";
        }
        var suffix = modeKey switch
        {
            0xD7F8DB56 => " (стенд)",
            0xFA87CD5E => " (инженер)",
            _ => ""
        };
        return $"0x{modeKey:X8}{suffix}";
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        if (_manualSessionEntered)
        {
            ManualSessionState.ExitConnectionTest();
            _manualSessionEntered = false;
        }

        // Unsubscribe from events
        Dispatcher.Connected -= OnConnected;
        Dispatcher.Disconnecting -= OnDisconnecting;
        Dispatcher.Stopped -= OnStopped;
        Dispatcher.PingDataUpdated -= OnPingDataUpdated;

        // Stop dispatcher
        await Dispatcher.StopAsync();
    }

    /// <summary>
    /// Предустановка регистра для выбора.
    /// </summary>
    private record RegisterPreset(string Name, ushort Address, string Type, string Description, RegisterPresetKind Kind = RegisterPresetKind.Raw);

    /// <summary>
    /// Категория preset чтения.
    /// </summary>
    private enum RegisterPresetKind
    {
        Raw,
        FirmwareVersion
    }

    /// <summary>
    /// Предустановка режима котла.
    /// </summary>
    private record BoilerModePreset(string Name, BoilerMode Mode, string Description);

    /// <summary>
    /// Режимы котла для ключа 1000/1001.
    /// </summary>
    private enum BoilerMode
    {
        Stand,
        Engineering,
        Normal
    }

    /// <summary>
    /// Результат верификации режима.
    /// </summary>
    private record ModeVerificationResult(bool Success, string Message)
    {
        public static ModeVerificationResult Ok(string message) => new(true, message);
        public static ModeVerificationResult Fail(string message) => new(false, message);
    }
}
