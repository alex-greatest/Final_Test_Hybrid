@using Final_Test_Hybrid.Models.Plc.Tags
@using Final_Test_Hybrid.Services.OpcUa.Subscription
@using Final_Test_Hybrid.Services.Diagnostic.Services
@using Final_Test_Hybrid.Services.Diagnostic.Protocol.CommandQueue
@inject OpcUaSubscription Subscription
@inject BoilerTemperatureService BoilerTemperatureService
@inject IModbusDispatcher Dispatcher
@implements IAsyncDisposable

<div class="header-block-parameter param-ch">
    <div class="field-row-parameter">
        <RadzenLabel Text="Q-CH"/>
        <RadzenTextBox Value="@_qCh" ReadOnly/>
    </div>
    <div class="field-row-parameter">
        <RadzenLabel Text="P-CH"/>
        <RadzenTextBox Value="@_pCh" ReadOnly/>
    </div>
    <div class="field-row-parameter">
        <RadzenLabel Text="T-CH RTN"/>
        <RadzenTextBox Value="@_tChRtn" ReadOnly/>
    </div>
    <div class="field-row-parameter">
        <RadzenLabel Text="T-CH FLOW"/>
        <RadzenTextBox Value="@_tChFlow" ReadOnly/>
    </div>
    <div class="field-row-parameter">
        <RadzenLabel Text="tCH котла"/>
        <RadzenTextBox Value="@_tChBoiler" ReadOnly/>
    </div>
</div>

@code {
    private string _qCh = "N/A";
    private string _pCh = "N/A";
    private string _tChRtn = "N/A";
    private string _tChFlow = "N/A";
    private string _tChBoiler = "N/A";
    private PeriodicTimer? _modbusTimer;
    private CancellationTokenSource? _cts;
    private Task? _pollingTask;
    private volatile bool _disposed;

    protected override async Task OnInitializedAsync()
    {
        await Subscription.SubscribeAsync(MainScreenTags.ChFr, OnQChChanged);
        await Subscription.SubscribeAsync(MainScreenTags.ChPmr, OnPChChanged);
        await Subscription.SubscribeAsync(MainScreenTags.ChTrr, OnTChRtnChanged);
        await Subscription.SubscribeAsync(MainScreenTags.ChTmr, OnTChFlowChanged);

        Dispatcher.Connected += OnDispatcherConnected;
        Dispatcher.Disconnecting += OnDispatcherDisconnecting;

        if (Dispatcher.IsStarted && Dispatcher.IsConnected)
        {
            StartModbusPolling();
        }
    }

    /// <summary>
    /// Обработчик события подключения диспетчера.
    /// </summary>
    private void OnDispatcherConnected()
    {
        if (_disposed) return;
        _ = InvokeAsync(() =>
        {
            if (_disposed) return;
            StartModbusPolling();
            StateHasChanged();
        });
    }

    /// <summary>
    /// Обработчик события отключения диспетчера.
    /// </summary>
    private Task OnDispatcherDisconnecting()
    {
        if (_disposed) return Task.CompletedTask;
        _ = InvokeAsync(() =>
        {
            if (_disposed) return;
            StopModbusPolling();
            ResetModbusValues();
            StateHasChanged();
        });
        return Task.CompletedTask;
    }

    /// <summary>
    /// Сбрасывает значения Modbus в начальное состояние.
    /// </summary>
    private void ResetModbusValues()
    {
        _tChBoiler = "N/A";
    }

    /// <summary>
    /// Останавливает polling Modbus.
    /// </summary>
    private void StopModbusPolling()
    {
        _cts?.Cancel();
    }

    /// <summary>
    /// Запускает polling Modbus.
    /// </summary>
    private void StartModbusPolling()
    {
        if (!Dispatcher.IsConnected) return;
        if (_pollingTask != null && !_pollingTask.IsCompleted) return;

        _cts?.Dispose();
        _cts = new CancellationTokenSource();
        _modbusTimer?.Dispose();
        _modbusTimer = new PeriodicTimer(TimeSpan.FromSeconds(2));
        _pollingTask = PollModbusAsync(_cts.Token);
    }

    /// <summary>
    /// Цикл периодического опроса Modbus.
    /// </summary>
    private async Task PollModbusAsync(CancellationToken ct)
    {
        var timer = _modbusTimer;
        var cts = _cts;
        try
        {
            while (timer != null && await timer.WaitForNextTickAsync(ct).ConfigureAwait(false))
            {
                var result = await BoilerTemperatureService.ReadSupplyLineTemperatureAsync(ct).ConfigureAwait(false);
                _tChBoiler = result.Success ? $"{result.Value}  °C" : "N/A";
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            // Нормальное завершение при отмене
        }
        catch (Exception)
        {
            ResetModbusValues();
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            if (ReferenceEquals(timer, _modbusTimer))
            {
                _modbusTimer?.Dispose();
                _modbusTimer = null;
            }
            if (ReferenceEquals(cts, _cts))
            {
                _cts?.Dispose();
                _cts = null;
            }
        }
    }

    private async Task OnQChChanged(object? value)
    {
        _qCh = FormatValue(value, "  л/мин");
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnPChChanged(object? value)
    {
        _pCh = FormatValue(value, "  бар");
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnTChRtnChanged(object? value)
    {
        _tChRtn = FormatValue(value, "  °C");
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnTChFlowChanged(object? value)
    {
        _tChFlow = FormatValue(value, "  °C");
        await InvokeAsync(StateHasChanged);
    }

    private static string FormatValue(object? value, string unit) =>
        value != null ? $"{value}{unit}" : "N/A";

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        Dispatcher.Connected -= OnDispatcherConnected;
        Dispatcher.Disconnecting -= OnDispatcherDisconnecting;

        StopModbusPolling();

        if (_pollingTask != null)
        {
            try { await _pollingTask; } catch { /* ignored */ }
        }

        _modbusTimer?.Dispose();
        _cts?.Dispose();

        await Subscription.UnsubscribeAsync(MainScreenTags.ChFr, OnQChChanged, removeTag: false, ct: CancellationToken.None);
        await Subscription.UnsubscribeAsync(MainScreenTags.ChPmr, OnPChChanged, removeTag: false, ct: CancellationToken.None);
        await Subscription.UnsubscribeAsync(MainScreenTags.ChTrr, OnTChRtnChanged, removeTag: false, ct: CancellationToken.None);
        await Subscription.UnsubscribeAsync(MainScreenTags.ChTmr, OnTChFlowChanged, removeTag: false, ct: CancellationToken.None);
    }
}
