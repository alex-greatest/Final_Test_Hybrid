@using Final_Test_Hybrid.Components.Errors
@using Final_Test_Hybrid.Components.Main.Modals
@using Final_Test_Hybrid.Models.Steps
@using Final_Test_Hybrid.Services.Common.Settings
@using Final_Test_Hybrid.Services.Main.PlcReset
@using Final_Test_Hybrid.Services.SpringBoot.Operation
@using Final_Test_Hybrid.Services.Steps.Infrastructure.Execution
@using Final_Test_Hybrid.Services.Steps.Infrastructure.Execution.Completion
@using Final_Test_Hybrid.Services.Steps.Infrastructure.Execution.Coordinator
@using Final_Test_Hybrid.Services.Steps.Infrastructure.Execution.ErrorCoordinator
@using Final_Test_Hybrid.Services.Steps.Infrastructure.Execution.PreExecution
@using Final_Test_Hybrid.Services.Steps.Infrastructure.Execution.Scanning
@using Final_Test_Hybrid.Services.Steps.Validation
@using Microsoft.Extensions.Logging
@inject PreExecutionCoordinator PreExecution
@inject ScanModeController ScanModeController
@inject ScanDialogCoordinator DialogCoordinator
@inject BoilerState BoilerState
@inject TestSequenseService TestSequenseService
@inject DialogService DialogService
@inject ReworkDialogService ReworkDialogService
@inject AppSettingsService AppSettingsService
@inject ErrorCoordinator ErrorCoordinator
@inject PlcResetCoordinator PlcResetCoordinator
@inject ExecutionStateManager ExecutionStateManager
@inject TestExecutionCoordinator TestCoordinator
@inject TestCompletionCoordinator CompletionCoordinator
@inject NotificationService NotificationService
@inject ILogger<BoilerInfo> Logger
@implements IDisposable

<div class="field-row field-row-middle">
    <RadzenLabel Text="Тип котла"/>
    <RadzenTextBox Style="width:100%"
                   Value="@(BoilerState.BoilerTypeCycle?.Type ?? "")"
                   ReadOnly="true"/>
</div>
<div class="field-row field-row-middle">
    <RadzenLabel Text="Серийный номер"/>
    <div style="position: relative; width: 100%;">
        <RadzenTextBox
            Style="width: 100%; padding-right: 30px;"
            Value="@GetDisplayValue()"
            ReadOnly="@IsFieldReadOnly"
            @oninput="OnInput"
            @onkeydown="OnKeyDown"
            Placeholder="@Placeholder"/>
        @if (!IsFieldReadOnly && !string.IsNullOrEmpty(GetDisplayValue()))
        {
            <RadzenIcon
                Icon="close"
                Style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); cursor: pointer; color: var(--rz-text-tertiary-color); font-size: 32px;"
                @onclick="ClearSerialNumber"/>
        }
    </div>
</div>

<FloatingErrorPanel
    IsVisible="@_showErrorPanel"
    StepName="@_errorStepName"
    ErrorMessage="@_errorMessage"
    ColumnIndex="0"
    StateManager="@ExecutionStateManager"
    OnClose="@CloseErrorPanel" />

@code {
    private string _manualInput = "";
    private bool _disposed;
    private const string PlaceholderText = "Отсканируйте или введите";

    private bool _showErrorPanel;
    private string? _errorStepName;
    private string? _errorMessage;
    private bool _isSaveProgressDialogOpen;
    private bool? _desiredSaveProgressState;

    private bool IsOnActiveScanStep => TestSequenseService.IsOnActiveScanStep;
    private bool IsFieldReadOnly => !PreExecution.IsAcceptingInput
        || !ScanModeController.IsScanModeEnabled
        || !IsOnActiveScanStep
        || PlcResetCoordinator.IsActive
        || ErrorCoordinator.CurrentInterrupt != null;
    private string Placeholder => !IsFieldReadOnly ? PlaceholderText : "";

    protected override void OnInitialized()
    {
        BoilerState.OnChanged += OnBoilerStateChanged;
        TestSequenseService.OnDataChanged += OnDataChanged;
        PreExecution.OnStateChanged += OnScanStateChanged;
        DialogCoordinator.OnMissingPlcTagsDialogRequested += ShowMissingPlcTagsDialogAsync;
        DialogCoordinator.OnMissingRequiredTagsDialogRequested += ShowMissingRequiredTagsDialogAsync;
        DialogCoordinator.OnUnknownStepsDialogRequested += ShowUnknownStepsDialogAsync;
        DialogCoordinator.OnMissingRecipesDialogRequested += ShowMissingRecipesDialogAsync;
        DialogCoordinator.OnRecipeWriteErrorDialogRequested += ShowRecipeWriteErrorDialogAsync;
        DialogCoordinator.OnReworkDialogRequested += HandleReworkDialogAsync;
        DialogCoordinator.OnBlockErrorDialogRequested += ShowBlockErrorDialogAsync;
        DialogCoordinator.OnBlockErrorDialogCloseRequested += CloseDialogs;
        AppSettingsService.UseMesChanged += OnUseMesChanged;
        ErrorCoordinator.OnReset += CloseDialogs;
        PlcResetCoordinator.OnForceStop += CloseDialogs;
        PlcResetCoordinator.OnActiveChanged += OnBlockingStateChanged;
        ErrorCoordinator.OnInterruptChanged += OnBlockingStateChanged;
        TestCoordinator.OnErrorOccurred += HandleTestErrorOccurred;
        CompletionCoordinator.OnSaveErrorDialogRequested += HandleSaveErrorDialogAsync;
        CompletionCoordinator.OnPrepareErrorDialogRequested += HandlePrepareErrorDialogAsync;
        CompletionCoordinator.OnSaveProgressChanged += HandleSaveProgressChanged;
        ScanModeController.OnStateChanged += OnScanModeStateChanged;
    }

    private void OnScanModeStateChanged() => InvokeIfNotDisposed(StateHasChanged);

    private void CloseDialogs()
    {
        _ = InvokeAsync(() =>
        {
            DialogService.Close();
            CloseErrorPanel();
        });
    }

    private string GetDisplayValue() => BoilerState.SerialNumber ?? PreExecution.CurrentBarcode ?? _manualInput;

    private void OnDataChanged() => InvokeIfNotDisposed(StateHasChanged);

    private void OnScanStateChanged() => InvokeIfNotDisposed(StateHasChanged);

    private void OnBlockingStateChanged() => InvokeIfNotDisposed(StateHasChanged);

    private void OnUseMesChanged(bool _)
    {
        _manualInput = "";
        BoilerState.Clear();
        PreExecution.ClearBarcode();
        InvokeIfNotDisposed(StateHasChanged);
    }

    private void OnInput(ChangeEventArgs e) => _manualInput = e.Value?.ToString() ?? "";

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key != "Enter" || IsFieldReadOnly || string.IsNullOrEmpty(_manualInput)) return;

        PreExecution.SubmitBarcode(_manualInput);
    }

    private void OnBoilerStateChanged()
    {
        if (BoilerState.SerialNumber != null)
        {
            InvokeIfNotDisposed(ClearManualInput);
        }
        else
        {
            InvokeIfNotDisposed(StateHasChanged);
        }
    }

    private void ClearManualInput()
    {
        _manualInput = "";
        StateHasChanged();
    }

    private void ClearSerialNumber()
    {
        _manualInput = "";
        PreExecution.ClearBarcode();
        BoilerState.Clear();
        StateHasChanged();
    }

    private void InvokeIfNotDisposed(Action action)
    {
        if (_disposed)
        {
            return;
        }
        InvokeAsync(() => ExecuteIfNotDisposed(action));
    }

    private void ExecuteIfNotDisposed(Action action)
    {
        if (_disposed)
        {
            return;
        }
        action();
    }

    private async Task ShowMissingPlcTagsDialogAsync(IReadOnlyList<string> missingTags)
    {
        await ShowMissingTagsDialogAsync(
            "Отсутствующие теги для PLC",
            missingTags,
            $"В PLC DB_Recipe отсутствует тегов: {missingTags.Count}");
    }

    private async Task ShowMissingRequiredTagsDialogAsync(IReadOnlyList<string> missingTags)
    {
        await ShowMissingTagsDialogAsync(
            "Отсутствующие обязательные теги",
            missingTags,
            $"В рецептах БД отсутствуют обязательные теги: {missingTags.Count}");
    }

    private async Task ShowMissingTagsDialogAsync(string title, IReadOnlyList<string> missingTags, string infoMessage)
    {
        await InvokeAsync(async () =>
        {
            await DialogService.OpenAsync<MissingTagsDialog>(
                title,
                new Dictionary<string, object>
                {
                    { "MissingTags", missingTags.ToList() },
                    { "InfoMessage", infoMessage }
                },
                CreateFullScreenDialogOptions("missing-tags-dialog-window"));
        });
    }

    private async Task ShowUnknownStepsDialogAsync(IReadOnlyList<UnknownStepInfo> unknownSteps)
    {
        await InvokeAsync(async () =>
        {
            await DialogService.OpenAsync<UnknownStepsDialog>(
                "Неизвестные шаги в последовательности",
                new Dictionary<string, object>
                {
                    { "UnknownSteps", unknownSteps.ToList() }
                },
                CreateFullScreenDialogOptions("unknown-steps-dialog-window"));
        });
    }

    private async Task ShowMissingRecipesDialogAsync(IReadOnlyList<MissingRecipeInfo> missingRecipes)
    {
        await InvokeAsync(async () =>
        {
            await DialogService.OpenAsync<MissingRecipesDialog>(
                "Отсутствующие рецепты",
                new Dictionary<string, object>
                {
                    { "MissingRecipes", missingRecipes.ToList() }
                },
                CreateFullScreenDialogOptions("missing-recipes-dialog-window"));
        });
    }

    private async Task ShowRecipeWriteErrorDialogAsync(IReadOnlyList<RecipeWriteErrorInfo> errors)
    {
        await InvokeAsync(async () =>
        {
            await DialogService.OpenAsync<RecipeWriteErrorDialog>(
                "Ошибка записи рецепта в PLC",
                new Dictionary<string, object>
                {
                    { "Errors", errors.ToList() }
                },
                CreateFullScreenDialogOptions("recipe-write-error-dialog-window"));
        });
    }

    private static DialogOptions CreateFullScreenDialogOptions(string cssClass)
    {
        return new DialogOptions
        {
            Width = "95vw",
            Height = "90vh",
            ShowClose = false,
            CloseDialogOnOverlayClick = false,
            CloseDialogOnEsc = false,
            CssClass = cssClass
        };
    }

    private Task ShowBlockErrorDialogAsync(string stepName, string errorMessage)
    {
        return InvokeAsync(() =>
        {
            _errorStepName = stepName;
            _errorMessage = errorMessage;
            _showErrorPanel = true;
            StateHasChanged();
        });
    }

    private void CloseErrorPanel()
    {
        _showErrorPanel = false;
        _errorStepName = null;
        _errorMessage = null;
        InvokeIfNotDisposed(StateHasChanged);
    }

    private void HandleTestErrorOccurred(StepError error)
    {
        _ = InvokeAsync(() =>
        {
            _errorStepName = error.StepName;
            _errorMessage = error.ErrorMessage;
            _showErrorPanel = true;
            StateHasChanged();
        });
    }

    private Task<ReworkFlowResult> HandleReworkDialogAsync(
        string errorMessage,
        Func<string, string, Task<ReworkSubmitResult>> executeRework)
    {
        return ReworkDialogService.ExecuteReworkFlowAsync(errorMessage, executeRework);
    }

    private async Task<bool> HandleSaveErrorDialogAsync(string? errorMessage)
    {
        var tcs = new TaskCompletionSource<bool>();

        await InvokeAsync(async () =>
        {
            // Показать конкретное сообщение в уведомлении
            if (!string.IsNullOrEmpty(errorMessage))
            {
                NotificationService.Notify(NotificationSeverity.Error, "Ошибка сохранения", errorMessage);
            }

            var result = await DialogService.OpenAsync<SaveErrorDialog>(
                "",
                null,
                new DialogOptions
                {
                    ShowTitle = false,
                    ShowClose = false,
                    CloseDialogOnOverlayClick = false,
                    CloseDialogOnEsc = false
                });
            tcs.TrySetResult(result is true);
        });

        return await tcs.Task;
    }

    private async Task<bool> HandlePrepareErrorDialogAsync(string? errorMessage)
    {
        var tcs = new TaskCompletionSource<bool>();

        await InvokeAsync(async () =>
        {
            if (!string.IsNullOrEmpty(errorMessage))
            {
                NotificationService.Notify(NotificationSeverity.Error, "Ошибка подготовки", errorMessage);
            }

            var result = await DialogService.OpenAsync<PrepareErrorDialog>(
                "",
                null,
                new DialogOptions
                {
                    ShowTitle = false,
                    ShowClose = false,
                    CloseDialogOnOverlayClick = false,
                    CloseDialogOnEsc = false
                });
            tcs.TrySetResult(result is true);
        });

        return await tcs.Task;
    }

    private void HandleSaveProgressChanged(bool isShowing)
    {
        // Сохраняем желаемое состояние синхронно (до InvokeAsync)
        // Это решает race condition: если false придёт до обработки true в UI потоке,
        // UI поток увидит актуальное состояние (false) и не откроет диалог
        _desiredSaveProgressState = isShowing;

        if (_disposed)
        {
            return;
        }

        // Используем паттерн InvokeIfNotDisposed для защиты от dispose между проверкой и вызовом
        InvokeIfNotDisposed(() => ProcessSaveProgressStateAsync());
    }

    private async void ProcessSaveProgressStateAsync()
    {
        try
        {
            // Проверяем актуальное желаемое состояние (могло измениться с момента вызова)
            var desired = _desiredSaveProgressState;

            if (desired == true)
            {
                // Защита от повторного открытия и открытия во время reset
                if (_isSaveProgressDialogOpen || PlcResetCoordinator.IsActive)
                {
                    return;
                }
                _isSaveProgressDialogOpen = true;
                try
                {
                    await DialogService.OpenAsync<SaveProgressDialog>(
                        "",
                        null,
                        new DialogOptions
                        {
                            Width = "500px",
                            Height = "280px",
                            ShowTitle = false,
                            ShowClose = false,
                            CloseDialogOnOverlayClick = false,
                            CloseDialogOnEsc = false,
                            CssClass = "save-progress-dialog-window"
                        });
                    // Не закрываем здесь - это делает второй вызов ProcessSaveProgressStateAsync
                    // от события false (либо обработчики reset в самом SaveProgressDialog)
                }
                finally
                {
                    _isSaveProgressDialogOpen = false;
                }
            }
            else if (desired == false && _isSaveProgressDialogOpen)
            {
                DialogService.Close();
            }
        }
        catch (Exception ex)
        {
            // Ошибки UI не должны прерывать сохранение
            Logger.LogWarning(ex, "Ошибка отображения диалога прогресса сохранения");
        }
    }

    public void Dispose()
    {
        _disposed = true;
        BoilerState.OnChanged -= OnBoilerStateChanged;
        TestSequenseService.OnDataChanged -= OnDataChanged;
        PreExecution.OnStateChanged -= OnScanStateChanged;
        DialogCoordinator.OnMissingPlcTagsDialogRequested -= ShowMissingPlcTagsDialogAsync;
        DialogCoordinator.OnMissingRequiredTagsDialogRequested -= ShowMissingRequiredTagsDialogAsync;
        DialogCoordinator.OnUnknownStepsDialogRequested -= ShowUnknownStepsDialogAsync;
        DialogCoordinator.OnMissingRecipesDialogRequested -= ShowMissingRecipesDialogAsync;
        DialogCoordinator.OnRecipeWriteErrorDialogRequested -= ShowRecipeWriteErrorDialogAsync;
        DialogCoordinator.OnReworkDialogRequested -= HandleReworkDialogAsync;
        DialogCoordinator.OnBlockErrorDialogRequested -= ShowBlockErrorDialogAsync;
        DialogCoordinator.OnBlockErrorDialogCloseRequested -= CloseDialogs;
        AppSettingsService.UseMesChanged -= OnUseMesChanged;
        ErrorCoordinator.OnReset -= CloseDialogs;
        PlcResetCoordinator.OnForceStop -= CloseDialogs;
        PlcResetCoordinator.OnActiveChanged -= OnBlockingStateChanged;
        ErrorCoordinator.OnInterruptChanged -= OnBlockingStateChanged;
        TestCoordinator.OnErrorOccurred -= HandleTestErrorOccurred;
        CompletionCoordinator.OnSaveErrorDialogRequested -= HandleSaveErrorDialogAsync;
        CompletionCoordinator.OnPrepareErrorDialogRequested -= HandlePrepareErrorDialogAsync;
        CompletionCoordinator.OnSaveProgressChanged -= HandleSaveProgressChanged;
        ScanModeController.OnStateChanged -= OnScanModeStateChanged;
    }
}
